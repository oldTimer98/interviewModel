## 视频讲解：

此处为语雀视频卡片，点击链接查看：[如何提升JS代码性能.mp4](https://www.yuque.com/u1598738/zqco83/vrb4gg673bfzmptt#B56Ga)

## 通用

### 1. 避免使用 `with()` 语句

这是因为 with() 语句将会在作用域链的开始添加额外的变量。

![img](https://cdn.nlark.com/yuque/0/2023/png/32786640/1700137322903-a1958980-c815-4498-ae03-8498d7999edc.png)

额外的变量意味着，当任何变量需要被访问的时候，JavaScript引擎都需要先扫描with()语句产生的变量，然后才是局部变量，最后是全局变量。  因此with()语句同时给局部变量和全局变量的性能带来负面影响。



### 2. 避免使用 `eval`

在 JavaScript 中，eval() 函数是用于执行字符串中的 JavaScript 代码的方法。虽然 eval() 可以在某些情况下提供灵活性和动态性，但它也会带来一些性能成本和潜在的安全风险。性能成本：

1. **解析和执行**：eval() 函数在运行时将字符串解析为可执行的 JavaScript 代码，并立即执行。这个过程涉及到动态解析和编译，相对于静态的 JavaScript 代码，会增加一定的性能开销；
2. **无法进行编译优化**：由于 eval() 中的代码是在运行时动态生成和执行的，因此 JavaScript 引擎无法对其进行静态分析和编译优化。这可能导致执行速度较慢，并且无法充分利用 JavaScript 引擎的优化机制(JIT)。

![img](https://cdn.nlark.com/yuque/0/2023/png/32786640/1700138851818-df026d93-b43c-4026-9256-c6c235fb2a44.png)

其次，`eval`还有较高的安全风险：

1. 潜在的代码注入攻击：由于 eval() 可以执行任意的 JavaScript 代码，如果在执行 eval() 之前未对字符串进行充分的验证和过滤，那么恶意的用户输入可能会导致代码注入攻击。
2. 作用域和变量泄漏：eval() 函数在执行时会在当前作用域中创建变量，并可能导致变量泄漏和作用域混乱的问题。这可能会导致代码的可读性和可维护性下降

PS: 类似的，也应该尽可能避免使用 `new Function` 风格代码。



### 3. 避免使用全局变量

全局变量除了会导致一系列可维护性问题外，在性能上也会带来额外负担，原因：

1. **优先级及查找时间**：JavaScript解析器需要通过作用域链来查找变量。全局变量在作用域链的最末端，因此查找全局变量需要的时间最长。如果在一个函数中频繁使用全局变量，而不是函数的局部变量，就会产生更多的查询时间。
2. **内存释放慢**：全局变量直到应用程序结束才会被销毁 —— 某种程度上可以理解为永远不会被**自动** GC(除非手动设置为 null)，所以它们会更长时间地占用内存。这不仅可能导致浏览器消耗更多的内存资源，还会增加 GC 负担；

![img](https://cdn.nlark.com/yuque/0/2023/png/32786640/1700138399458-408eda3d-e04a-466f-b8eb-a22f40fafa4d.png)



为此，应该尽可能减少全局变量的使用，多用 let/const。



### 4. 对象属性和数组元素的速度都比变量慢

JavaScript 的数据，一般有4种访问方式：数值、变量、对象属性和数组元素。在考虑优化时，数值和变量的性能差不多，并且速度显著优于对象属性和数组元素。

因此当你多次引用一个对象属性或者数组元素的时候，你可以通过定义一个变量来获得性能提升，例如：

```javascript
// 低性能版本
console.log(foo.bar.tap.count);
console.log(foo.bar.tap.count + 1);

// 高性能版本
const count = foo.bar.tap.count;
console.log(count);
console.log(count + 1);
```

这里的底层逻辑，是将嵌套属性单独提取为局部变量，下次取值时不再需要通过这条链路索引取值，提升性能。



### 5. 使用 `**Object Pooling**`

这是一个不太常见的优化技术，在 JS 中，创建 & 销毁 JS 对象的动作需要引擎帮我们做好内存区域分配、索引、填充值、删除索引等动作，存在性能成本，某些场景下我们可能需要频繁创建 & 销毁 JS 对象(例如图形图像处理、游戏场景等)，此时可以用 `Object Pooling` 技术做好对象缓存，**避免重复分配 & 回收。**

对象池（Object Pool）简单说，就是预创建好若干对象，使用时将值填充入现有对象中，销毁时也只需要标记为失活对象即可，从而减少了初始化和垃圾回收带来的性能开销。如果对象的结构相对固定，还可以借助 JIT 优化达到更优效果。

JIT 优化：JS 引擎会在运行过程中动态标记代码热区，对于执行频率高且数据类型固化的场景会标记为热区并预编译为效率更高的机器语言低码，下次执行时需要再做解释动作，从而达到优化效果。

不过，这并不容易使用，有许多注意事项：

1. **对象重置**：当对象被从对象池中取出使用并归还时，需要确保该对象的状态被正确重置，避免对象的前一个状态影响到后续的使用。重置包括清除该对象的所有数据，将所有字段恢复到初始状态等。
2. **大小管理**：对象池的大小管理是一个需要关注的问题。理想的情况是，池的大小刚好满足应用的并发需求，不浪费内存资源。过小的池可能导致请求等待，而过大的池则可能浪费内存资源(也可以借助一些动态伸缩算法，动态生成)。
3. **对象的声明周期管理**：如果你的对象需要进行一些特殊的清理操作（如释放网络连接），这么做可能需要额外的逻辑来正确处理。
4. **错误处理**：如果创建对象或重置对象的操作可能引发错误，需要确保这些错误被正确处理，而且不会影响到对象池的正常工作。
5. **性能**：在一些情况下，对象池可能会带来负面影响。例如，如果对象很小，或者创建和销毁的开销很低，对象池可能会引入额外不必要的复杂性和开销。在这种情况下，最好进行性能测试，以确保对象池真正改善了性能。
6. **内存泄漏**：尤其在JavaScript这种自动垃圾回收的环境下，要特别注意避免因为一直对对象的引用而造成无法释放内存的泄漏。



### 6. 适配 JIT

turbofan

如上所述：JS 引擎会在运行过程中动态标记代码热区，对于执行频率高且数据类型固化的场景会标记为热区并预编译为**效率更高的机器语言代码**，下次执行时需要再做解释动作，从而达到优化效果，也就是所谓的 JIT 优化。

要充分利用 JavaScript 的 JIT（Just-In-Time）编译能力，可以遵循以下一些原则：

- **尽可能保持数据类型的一致性**：JIT 编译器对具有确定类型的代码进行优化。如果数据类型经常变更，编译器就会不断地进行优化和反优化，这会浪费资源并降低性能。
- **减少不必要的属性动态添加和删除**：动态添加属性，特别是在对象后期添加，会导致 JIT 引擎更难进行优化。原则上建议一开始就设置好对象的所有属性。
- **高频函数尽量简洁**：频繁调用的函数（或者热点函数）应该尽量简洁，且出入参应该尽可能保持结构一致。



## web 场景

### 1. 减少 JS 导致的页面回流

重绘和回流是渲染页面时产生的代价高昂的操作，应避免频繁修改样式 & dom 结构，这类操作常见的有：

- 修改样式、添加 class，导致布局信息发生变化(position/top/left/width/margin/padding 等)
- 插入、修改、删除 dom 可视(display != none)结构；
- 查询 dom 元素几何属性，如：dom.offsetTop

![img](https://cdn.nlark.com/yuque/0/2023/png/32786640/1700138665104-1a30563a-b283-4539-a415-110d11ce7ec0.png)



为此，可以：

- 使用文档片段（Document Fragments）进行离线操作，最后再将其附加到文档中；
- 减少会触发重排的接口调用，包括各种**"查询 / 调用节点几何属性**"接口如`dom.offsetTop`
- 使用 animation + transform + rAF 代替 js 实现动画效果；



### 2. 使用 Webworker 执行 CPU 密集型计算

fs.readFile vs fs.readFileSync

JS Runtime 只有单一主线程，所有异步操作都通过事件循环方案循环执行，避免阻塞操作造成的 CPU 卡顿；但同步操作依然会占用 CPU，在执行 CPU 密集型计算时可能卡顿较久，可能导致页面长期无响应、FPS 降低，甚至卡死。

而使用 Webworker 则可以将耗时操作托管到独立线程执行，主线程依然保持较空闲状态，及时响应用户交互，保持页面流畅，因此可以有意识地将耗时操作托管到 Webworker 执行，常见场景有：

- 计算内容 hash 值；
- 压缩/解压缩；
- 多媒体资源编解码；
- 可视化布局与渲染(配合离屏 canvas)；
- 大规模数据处理；
- AST 解析；
- 复杂算法运算，包括：路径规划、物理模拟、加解密算法等；



### 3. 尽可能减少 JS 资源体积

这应该已经是一个尝试：减少JS 资源体积，有助于提升网站整体性能，但为什么呢？主要是两方面：

- 资源体积减少，相应的网络负担也就小了；
- 这一点是很多人没关注到的：同等体积下，浏览器处理多媒体资源(如图片、视频等)的速度，远比JS 要快得多，因为多媒体资源加载回来后，通常交给 GPU 处理即可，而 JS 资源还需要经过解释、执行，两种资源的处理速度可能相差 100 倍！

为此，我们应该尽可能减少页面需要加载的资源总数，对应的优化方案有：

- 模块按需加载：有助于减少首屏需要加载处理的 js 总量；
- tree-shaking：删除掉不需要的模块后，引擎需要解释执行的代码相应减少了；
- 代码结构优化，尽可能减少重复(为此可以引入一些重复度检测工具)
- 使用 WASM：这个方法其实有点 trick，如果我们将代码逻辑交给 WASM 实现，那确实能相对减少 JS 的体积和负载，但 WASM 是在主线程上执行的，与 JS 线程互斥 —— 这意味着 WASM 的执行会抢占 JS 的时间，最终整体性能可能是持平(结果取决于很多因素，不能一概而论)的；但进一步的，也可以考虑在 Webworker 上执行 WASM ，这样就能克服“互斥”问题，达到更优性能



相应的，其他一些常见优化措施，并不是用于提升 JS 执行性能，记得不要混淆！包括：

- 代码压缩：有助于减少需要传输的网络流量，但从解释执行视角看，并没有减少多少代码，对执行性能的提升有一定帮助但并不明显；
- 代码合并：同样只是优化了 IO 速度，需要执行的代码量在合并前后相等，对执行速度无明显优化；
- 使用 CDN：这只是提升了网络 IO 速度，与 JS 执行速度无关



### 4. 使用事件委托

在 web page 中，绑定 dom 事件需要消耗：

- 内存成本：每个事件绑定都需要在内存中记录映射关系，势必存在内存消耗；
- 事件查找：浏览器回调时需要针对特定节点查找对应事件绑定列表，当绑定量较大时，查找成本可能比较高；
- 事件冒泡和捕获：没错，冒泡 & 捕获流程本身也会占用性能！当事件触发时，浏览器会执行事件冒泡或捕获阶段中的每个绑定的事件处理程序。如果事件冒泡或捕获的层级较深或者绑定的处理程序较多，可能会导致性能下降。

而使用事件委托，能够将事件处理程序绑定到容器元素上，利用事件冒泡机制来处理子元素的事件，从而：减少事件映射记录所需要的内存消耗；减少事件查找的时间消耗；降低事件冒泡捕获需要处理的层级。从而提升事件处理性能。



### 5. 使用 IntersectionObserver 检测区域可视度

IntersectionObserver 是一个用于检测元素与特定区域相交度的 API，可以检测元素进入或离开视窗、元素与其他元素的交叉(其实就是两个元素是否发生重叠)等情况，从而实现一些懒加载、无限滚动、动态加载内容等交互效果。

举个例子，在传统的图片懒加载方案中，我们可能会给图片设定一个占位符，当占位符的位置快要出现在视口时再发出请求，拉取图片资源，而这个“快要出现在视口”的判断通常是判断页面的 scroll 回调中判断图片位置与 `offsetTop` 的差值是否小于阈值实现的，这种方案很低效：

- scroll 会频繁触发回调，带来事件处理成本；
- scroll 回调会阻塞页面响应 —— 这意味着，如果执行判断逻辑期间，页面会一直 block 住直到回调函数执行完毕；
- 而，调用 `offsetTop`又会强制触发回流；

所以，整体来说这并不是一个性能最优的方案。

而 IntersectionObserver 则是浏览器原生提供的“区域交叉”检测功能，它是异步执行的，且由浏览器原生提供，因此其性能要好很多：

- 可以有效地减少监听器的数量；
- 可以避免频繁的事件处理和重排操作；
- 由浏览器底层(c++层)完成区域碰撞检测，远比dom 交互 => 事件 => JS 判断的逻辑链路，要高效的多，且浏览器的执行算法是在不断迭代优化的，未来必然会越来越快；



### 6. 使用 WebSocket 代替轮询

在 WebSocket 出现之前，我们处理事实通讯数据通常基于长轮询方式实现，大致方案是在浏览器端不断发送请求到服务端，检查是否有数据更新，这个过程存在如下问题：

- 需要独占一条 TCP 链接，而 TCP 连接是昂贵的，需要消耗端口、内存、线程等；
- 需要占用浏览器并发连接限额，影响其他请求的及时性；
- JS 轮询逻辑可能长期处于空转状态；



而使用 WebSocket 之后，客户端不在需要“不断发送”请求，建立 WS 连接之后静静等待服务端主动下发的 `message` 即可，也就不在需要空转，不需要占用并发连接限额等(不过依然需要占用专用 TCP 连接)。



### 7. 使用数据缓存

通常而言，web page 的总会存在一些实时性不敏感的数据，例如各种字典、用户信息、权限数据等，它们的变化较少，如果每次都依赖服务端返回，那 js 会花不少时间在“等待 IO”上，因此针对这部分数据，可以使用 localStorage 等方式做本地缓存，减少 IO 次数。

其次，对于大数处理场景，也应该尽可能优化算法，多用缓存方式记录中间结果，尽可能减少 CPU 计算量。



### 8. 防抖节流

这个方案应该比较常见了，对于一些频繁触发的操作，比如window的resize或scroll事件，连续的触发可能会导致性能问题。通过防抖（debounce）和节流（throttle）的技术，我们可以控制事件的触发频率，优化性能。



### 9. 不能提升 JS 性能的操作

也有一些性能优化操作，其实是用于优化 web page 其他方面性能的，与 JS 执行效率无关，这里也罗列学习一下，包括：

- 虚拟列表：优化的是页面渲染性能，但可视列表的计算反而会消耗更多 JS 时间；
- 图片等多媒体资源压缩：只是优化了这些资源的 IO 速度，与 JS 无关；
- 使用 defer & async：这两个属性都只用于避免 JS 阻塞 DOM 树构建，但并不能提升 JS 执行性能；



## Node 场景

未完待续







## 