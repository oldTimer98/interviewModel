## 基础

BigInt 是 ES6 引入的新数据类型，用于表示“任意大的整数”，与 Number 类似都能用于完成数学运算，但功能效果略有差异，主要区别有：

1. **数据范围**：number类型表示的是双精度浮点数，它可以表示的数值范围是从 `Number.MIN_VALUE` 到`Number.MAX_VALUE`，约为±5 x 10^-324 到 ±1.8 x 10^308。而bigint类型可以表示任意大的整数，不受数值范围的限制。

```javascript
const num = 9007199254740992;
const big = 9007199254740992n;

console.log(num + 1); // 9007199254740992，精度损失
console.log(big + 1n); // 9007199254740993，精确结果
```

1. **边界问题**：number类型可以表示小数和整数，而bigint类型仅用于表示整数，如果给bigint赋予一个小数值或者null或者字符串，它会直接报错。

```javascript
const num1 = BigInt(10.5);
console.log(num1); // RangeError
const num2 = BigInt("月哥"); 
console.log(num2); // TypeError
const num3 =BigInt(null) 
console.log(num3); // SyntaxError
```

![img](https://cdn.nlark.com/yuque/0/2024/png/1931776/1730734671947-664c6473-601d-4e2e-b122-7520d115e272.png)

1. **字面量表示**：number类型的字面量可以直接写作数字，例如42或3.14。而bigint类型的字面量必须加上后缀n，例如42n或3141592653589793238462643n，以表示它是一个bigint类型的值；注意，BigInt 字面量不允许使用小数，否则报语法错误：

```javascript
const num1 = 1.2n; // 报错：Uncaught SyntaxError: Invalid or unexpected token
```

1. **运算方式**：number类型的运算遵循浮点数运算规则，而bigint类型的运算遵循整数运算规则。这意味着在进行运算时，number类型可能会遇到精度损失和舍入误差，而bigint类型的运算结果始终是精确的整数(不过，bitint 只能用于表示整数，因此无法直接进用于解决“0.1+0.2!==0.3” 的问题)。
2. **类型转换**：number和bigint之间可以进行相互转换。使用Number()函数可以将bigint转换为number，这可能会导致精度损失(**超出 number 数值范围的部分会丢失**)。而使用BigInt()函数可以将number转换为bigint，这会将number转换为最接近的整数(小数部分都会丢失)。
3. **数值操作**：传统的 `Math` 函数不适用于 BitInt(这也正是它在推广上最大的问题)，ES6 也没有提供对应的替代版本，因此许多操作需要自行实现(例如 `Math.sqrt` 平方根函数)；
4. **类型判断**：两者使用 `typeof` 时，返回值不同；也因此，需要注意判断方法：

```javascript
console.log(typeof num); // "number"
console.log(typeof big); // "bigint"

1n == 1  // true
1n === 1 // false
```

1. **无法 JSON 序列化**：BigInt 虽然是一种原子类型，但无法被 `JSON.stringify`

报错：

![img](https://cdn.nlark.com/yuque/0/2023/png/32786640/1696578348329-09c5b870-43c8-4b4b-9fca-edbcc5894d4e.png)

一个性价比较高的解决方案，是使用字符串代替：

```javascript
const big = 12345678901234567890n;
const stringifiedBig = big.toString(); // 转换为字符串
const json = JSON.stringify(stringifiedBig); // 序列化字符串
console.log(json); // "12345678901234567890"
```





## 进阶

### 为什么

注意，关键点是“无范围限制的**整数**”

ES6引入bigint类型是为了解决JavaScript中整数范围的限制。在之前的JavaScript版本中，数字类型（number）只能准确表示在-2^53到2^53之间的整数，超出这个范围的整数会丢失精度。这对于许多应用场景来说是不够的，特别是在需要处理大整数的情况下，如密码学、大数计算、货币处理等。

因此，为了满足这些需求，ES6引入了bigint类型，它可以表示任意大的整数，没有范围限制。bigint类型支持大整数的运算，包括加法、减法、乘法、除法等，使得开发人员能够更方便地处理大整数运算，并获得准确的结果。

设计bigint类型的目的是为了提供一种原生的、高效的方式来处理大整数，而不需要依赖第三方库或自定义实现。这使得JavaScript能够更好地应对需要处理大整数的场景，提高了语言的灵活性和实用性。

需要注意的是，由于bigint类型在内部表示上需要更多的内存和计算资源，因此相对于普通的整数运算，它可能会更耗费资源，具体来说：

1. **内存消耗**：bigint 类型的值需要更多的内存空间来存储，因为它们需要额外的位数来表示大整数。这意味着在处理大量大整数运算时，会占用更多的内存资源。如果频繁创建和操作大整数，可能会对内存使用造成显著影响。
2. **运算速度**：相对于普通的整数运算，bigint 类型的运算速度较慢。这是因为大整数的运算需要更多的位操作和更复杂的算法。特别是对于大位数的大整数，运算时间可能会显著增加。因此，在进行大量大整数运算时，需要考虑到性能方面的影响。
3. **转换开销**：在 bigint 类型与其他类型（如 number）之间进行转换时，会存在一定的开销。将 bigint 转换为 number 可能会涉及精度损失，而将 number 转换为 bigint 则需要额外的计算操作。这些转换操作可能会对性能产生一定的影响。



### 注意事项

BitInt 的操作方式与 Number 差异比较大，实操中需要注意：

1. **使用bigint类型**：不要跟 number 弄混了，定义时确保使用后缀n标记整数字面量，或者使用 `BigInt()`函数将number类型转换为bigint类型。
2. **运算符和函数支持**：

1. 许多常用的数学函数（如Math.pow()、Math.sqrt()）不适用于bigint类型，ES6 也没有提供对应替代版本，因此常常需要自行实现(或者使用 `bignumber.js` 代替)；
2. 加减乘除只能作用于两个 bigint，记得做好数值类型转换；

1. **整数除法**：在进行除法运算时，bigint类型的除法结果将取整，舍弃小数部分。如果需要得到精确的小数结果，可以将运算数转换为number类型进行除法运算，然后再将结果转换为bigint类型。
2. **运算结果类型**：bigint类型的运算结果始终是bigint，不会自动转换为number类型。确保在需要时将结果转换为number类型，以便与其他数据进行比较或进行其他操作。
3. **性能**：bigint类型的运算相对于普通的整数运算会更耗费计算资源和内存。因此，在处理大量大整数运算时，要注意性能方面的考虑。



### 问题

透彻地理解优缺点

综上，不难总结出 `BitInt` 存在如下问题：

1. 只适用于整数，不支持小数运算；
2. 与 number 功能相似但不能互操作，使用时需要注意做好类型装换，否则很容易出现类型问题；
3. 不支持 `Math.sqrt`等方法，且未提供替代版本的函数；
4. 内存占用大，性能成本更高；