```html
项目 github地址：
https://github.com/DevWizardFeng/MicroFrontendLab/tree/main
项目亮点
1. 微前端 概念 及应用
2. systemJS源码
3. single-spa实战及源码
4. qiankun实战及源码(沙箱原理)(蚂蚁金服)
5. MicroApp、WebComponent实战及源码(京东零售)
6. wujie实战使用(腾讯)
7. webpack5 Module Federation Emp2实战
一、为什么需要微前端
 微前端就是将不同的功能按照不同的维度拆分成多个子应用。通过主应用来加载这些子应用。  
对比(丰贺): DeepTable DeepUx DeepModel DeepFlow DeepBI
 微前端的核心在于拆, 拆完后在合，实现分而治之！  

1.微前端解决的问题
1. 不同团队（技术栈不同），同时开发一个应用 
2. 每个团队开发的模块都可以独立开发，独立部署 
3. 实现增量迁移  
2.如何实现微前端 
我们可以将一个应用划分成若干个子应用，将子应用打包成一个个的模块。当路径切换时加载不同的子应用。这样每个子应用都是独立的，技术栈也不用做限制了！  
3.实现微前端的技术方案
1. 采用何种方案进行应用拆分？ 
2. 采用何种方式进行应用通信？
3. 应用之间如何进行隔离？  
 1）iframe 
● 微前端的最简单方案，通过iframe加载子应用。
● 通信可以通过postMessage进行通信。 
● 完美的沙箱机制自带应用隔离。 
缺点：用户体验差 （弹框只能在iframe中、在内部切换刷新就会丢失状态）  
 2）Web Components  
●  将前端应用程序分解为自定义 HTML 元素。  
●  基于CustomEvent实现通信  。
●  Shadow DOM天生的作用域隔离  。
 缺点：浏览器支持问题、学习成本、调试困难、修改样式困难等问题。  
 3）single-spa  
● single-spa 通过路由劫持实现应用的加载(采用SystemJS),提供应用间公共组件加载及公共业务逻辑处理。
● 子应用需要暴露固定的钩子bootstrap、mount、 unmount接入协议。 
● 基于props主子应用间通信 无沙箱机制，需要实现自己实现JS沙箱以及CSS沙箱  
 缺点：学习成本、无沙箱机制、需要对原有的应用进行改造、子应用间相同资源重复加载问题。  
 4）Module federation 
●  通过模块联邦将组件进行打包导出使用
● 共享模块的方式进行通信
● 无CSS沙箱和JS沙箱  
 缺点：需要webpack5。  
4.Why Not Iframe 为什么不是 iframe
为什么不用 iframe，这几乎是所有微前端方案第一个会被 challenge 的问题。但是大部分微前端方案又不约而同放弃了 iframe 方案，自然是有原因的，并不是为了 "炫技" 或者刻意追求 "特立独行"。

如果不考虑体验问题，iframe 几乎是最完美的微前端解决方案了。

iframe 最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。但他的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题。

1url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。
2UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..
3全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。
4慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。

其中有的问题比较好解决(问题1)，有的问题我们可以睁一只眼闭一只眼(问题4)，但有的问题我们则很难解决(问题3)甚至无法解决(问题2)，而这些无法解决的问题恰恰又会给产品带来非常严重的体验问题， 最终导致我们舍弃了 iframe 方案。
 二.SystemJS剖析
 SystemJS 是一个通用的模块加载器，它能在浏览器上动态加载模块。微前端的核心就是 加载微应 用，我们将应用打包成模块，在浏览器中通过 SystemJS 来加载模块。  
        // 直接加载子应用, 导入打包后的包 来进行加载， 采用的规范 system规范
        // 这个地方是自己实现systemjs  
        // 1) systemjs 是如何定义的 先看打包后的结果 System.register(依赖列表,后调函数返回值一个setters，execute）
        // 2) react , react-dom  加载后调用setters 将对应的结果赋予给webpack
        // 3) 调用执行逻辑  执行页面渲染
        // 模块规范 用来加载system模块的
        const newMapUrl = {};
        // 解析 importsMap 
        function processScripts() {
            Array.from(document.querySelectorAll('script')).forEach(script => {
                if (script.type === "systemjs-importmap") {
                    const imports = JSON.parse(script.innerHTML).imports; // 解析JSON对象
                    Object.entries(imports).forEach(([key, value]) => newMapUrl[key] = value)
                }
            })
        }
        // 加载资源
        function load(id) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = newMapUrl[id] || id; // 支持cdn的查找
                script.async = true; //异步加载
                document.head.appendChild(script);
                // 此时会执行代码
                script.addEventListener('load', function () {
                    // 拿到注册表的内容 并且 清空注册表 指针转移
                    let _lastRegister = lastRegister;
                    lastRegister = undefined
                    resolve(_lastRegister);
                })
            })
        }
        let set = new Set(); // 1）先保存window上的属性
        function saveGlobalProperty() {
            for (let k in window) {
                set.add(k);
            }
        }
        saveGlobalProperty();
        function getLastGlobalProperty() {  // 看下window上新增的属性
            for (let k in window) {
                if (set.has(k)) continue;

                set.add(k);
                return window[k]; // 我通过script新增的变量
            }
        }
        let lastRegister;
        // 模块规范 用来加载System模块的
        class SystemJs {
            import(id) { // 这个id原则上可以是一个第三方路径cdn
                return Promise.resolve(processScripts()).then(() => {
                    // 1）去当前路径查找 对应的资源 index.js 完整路径
                    const lastSepIndex = location.href.lastIndexOf('/');
                    const baseURL = location.href.slice(0, lastSepIndex + 1);
                    if (id.startsWith('./')) {
                        return baseURL + id.slice(2);
                    }
                    // http  https
                }).then((id) => {
                    // 根据文件的路径 来加载资源
                    let execute
                    return load(id).then((register) => {
                        let { setters, execute:exe } = register[1](() => { })
                        execute = exe
                        // execute 是真正执行的渲染逻辑 
                        // setters 是用来保存加载后的资源，加载资源调用setters
                        //    console.log(setters,execute)
                        return [register[0], setters]
                    }).then(([registeration, setters]) => {
                        return Promise.all(registeration.map((dep, i) => {
                            return load(dep).then(() => {
                                const property = getLastGlobalProperty()
                                // 加载完毕后，会在window上增添属性 window.React window.ReactDOM
                                setters[i](property)
                            })
                            // 拿到的是函数，加载资源 将加载后的模块传递给这个setter
                        }))
                    }).then(() => {
                        execute();
                    })
                })
            }
            register(deps, declare) {
                // 将回调的结果保存起来
                lastRegister = [deps, declare]
            }
        }
        const System = new SystemJs()
        System.import('./index.js').then(() => {
            console.log('模块加载完毕')
        })
        // 本质就是先加载依赖列表 再去加载真正的逻辑 
        // (内部通过script脚本加载资源 ， 给window拍照保存先后状态) 快照
        // JSONP
        // single-spa 如何借助了 这个system 来实现了模块的加载
 三.single-spa实战  
1.安装脚手架
 npm install create-single-spa -g 
 create-single-spa substrate  // 通过single-spa-cli创建基座 应用

 # 创建子项目 
single-spa application / parcel 
# 用于跨应用共享JavaScript逻辑的微应用 
in-browser utility module (styleguide, api cache, etc) 
# 创建基座容器 
> single-spa root config  
 生成基座项目，用于加载子应用  
1)主应用的root-config文件
import { registerApplication, start } from "single-spa";

// 注册应用

registerApplication({
  name: "@single-spa/welcome",
  app: () =>
    System.import( // 远程加载模块
      "https://unpkg.com/single-spa-welcome/dist/single-spa-welcome.js"
    ),
  activeWhen: (location)=>location.pathname === '/' ,
});

registerApplication({
  name: "@jw/react", // 不重名即可
  app: () =>
    System.import('@jw/react'),
  activeWhen: (location)=>location.pathname.startsWith('/react')  ,
});

registerApplication({
  name: "@jw/vue", // 不重名即可
  app: () =>
    System.import('@jw/vue'),
  activeWhen: (location)=>location.pathname.startsWith('/vue')  ,
});

// registerApplication({
//   name: "@jw/navbar",
//   app: () => System.import("@jw/navbar"),
//   activeWhen: ["/"]
// });

start({
  urlRerouteOnly: true,
});
// 根应用
// 父应用的加载过程  9000 -> index.ejs -> @jw/root-config -> jw-root-config
// 匹配路径加载应用


// 写实现原理 我们给你加载一下
// 动态加载方式
2)主应用的ejs文件
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Root Config</title>
  <script src="https://cdn.jsdelivr.net/npm/regenerator-runtime@0.13.7/runtime.min.js"></script>
 
  <script type="systemjs-importmap">
    {
      "imports": {
        "single-spa": "https://cdn.jsdelivr.net/npm/single-spa@5.9.0/lib/system/single-spa.min.js"
      }
    }
  </script>
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/single-spa@5.9.0/lib/system/single-spa.min.js" as="script">

  <!-- Add your organization's prod import map URL to this script's src  -->
  <!-- <script type="systemjs-importmap" src="/importmap.json"></script> -->

  <% if (isLocal) { %>
  <script type="systemjs-importmap">
    {
      "imports": {
        "@jw/root-config": "//localhost:9000/jw-root-config.js",
        "@jw/react":"//localhost:3000/jw-react.js",
        "@jw/vue":"//localhost:4000/js/app.js"
      }
    }
  </script>
  <% } %>

  <script src="https://cdn.jsdelivr.net/npm/import-map-overrides@2.2.0/dist/import-map-overrides.js"></script>
  <% if (isLocal) { %>
  <script src="https://cdn.jsdelivr.net/npm/systemjs@6.8.3/dist/system.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/systemjs@6.8.3/dist/extras/amd.js"></script>
  <% } else { %>
  <script src="https://cdn.jsdelivr.net/npm/systemjs@6.8.3/dist/system.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/systemjs@6.8.3/dist/extras/amd.min.js"></script>
  <% } %>
</head>
<body>
  <main>
    <a onClick="go('/')">去welcome</a>
    <a onClick="go('/react')">去react</a>
    <a onClick="go('/vue')">去vue</a>
  </main>
  <script>
    function go(url){
      history.pushState({},null,url)
    }
    System.import('@jw/root-config');
  </script>

  <div id="vue"></div>
  <div id="react"></div>
</body>
</html>
3)主应用 加载流程
根应用
父应用的加载过程  9000 -> index.ejs -> @jw/root-config -> jw-root-config
匹配路径加载应用
 2.生成react子应用 
 create-single-spa react-project  
1）配置路由
 npm install react-router-dom  
import { BrowserRouter as Router, Route, Link, Routes } from 'react-router-dom'
import Home from './components/Home.js'
import About from './components/About.js'
export default function Root(props) {
return <Router basename="/react">
          <div>
          <Link to="/">Home React </Link>
          <Link to="/about">About React</Link>
          </div>
			<Routes>
				<Route path="/" element={<Home />} />
				<Route path="/about" element={<About />} />
			</Routes>
			</Router>
}

 2) webpack.config.js配置
delete defaultConfig.externals; // 关闭 externals
return merge(defaultConfig,{
  devServer:{
    	port: 3000 //修改端口
  	}
	});
3) 注册子应用
在index.ejs中
<script type="systemjs-importmap">
 {
   "imports": {
   "@jw/root-config": "//localhost:9000/jw-root-config.js",
   "@jw/react":"//localhost:3001/jw-react.js"
 	}
 }
</script>
在jw-root-config.js中
registerApplication({
  name: "@jw/react",
  app: () => System.import('@jw/react'),
  activeWhen: (location)=> location.pathname.startsWith('/react'),
});
3.生成 vue子应用
 create-single-spa vue-project  
 1）vue.config.js配置  :
const { defineConfig } = require('@vue/cli-service')
module.exports = defineConfig({
    transpileDependencies: true,
    publicPath: 'http://localhost:3002',
    devServer: {
      port: 3002
 			},
		chainWebpack: (config) => {
     // 优化构建 减少冲突
			if (config.plugins.has("SystemJSPublicPathWebpackPlugin")) {
				config.plugins.delete("SystemJSPublicPathWebpackPlugin");
 			}
		 }
	})
2）注册子应用
<script type="systemjs-importmap">
 {
 "imports": {
     "@jw/root-config": "//localhost:9000/jw-root-config.js",
     "@jw/react":"//localhost:3001/jw-react.js",
     "@jw/vue":"//localhost:3002/js/app.js"
 	}
 }
</script>
registerApplication({
    name: "@jw/vue",
    app: () => System.import("@jw/vue"),
    activeWhen: location => location.pathname.startsWith('/vue'),
});

在substrate/index.ejs中  添加路由跳转
<main>
    <a onClick="go('/')">去welcome</a>
    <a onClick="go('/react')">去react</a>
    <a onClick="go('/vue')">去vue</a>
  </main>
  <script>
    function go(url){
      history.pushState({},null,url);
    }
    System.import('@jw/root-config');
  </script>
然后启动 root-config和jw/react jw/vue三个项目，就可以完整看到效果了。

点击不同的 路由 跳转不同应用
四、single-spa源码解析
1.回顾single-spa的核心功能
创建index.html页面
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- <a href="#/a">a应用</a>
    <a href="#/b">b应用</a> -->
    <!-- <script src="https://cdn.bootcdn.net/ajax/libs/single-spa/5.9.3/umd/single-spa.min.js"></script> -->
    <script type="module">
        // 微前端 就是可以加载不同的应用  基于路由的微前端
        // 如何接入已经写好的应用 对于single-spa而言，我们需要改写子应用 （接入协议） bootstrap， mount， unmount
        // /a  /b
        import { registerApplication, start } from './single-spa/single-spa.js'
        // let { registerApplication, start } = singleSpa
        let app1 = {
            bootstrap: [
                async () => console.log('app1 bootstrap1'),
                async () => console.log('app1 bootstrap2')
            ],
            mount: [
                async (props) => {
                    // new Vue().$mount()...
                    console.log('app1 mount1', props)
                },
                async () => {
                    // new Vue().$mount()...
                    console.log('app1 mount2')
                }
            ],
            unmount: async (props) => {
                console.log('app1 unmount')
            }
        }
        let app2 = {
            bootstrap: async () => console.log('app2 bootstrap1'),
            mount: [
            async () => {
                // new Vue().$mount()...
                return new Promise((resolve,reejct)=>{
                    setTimeout(()=>{
                        console.log('app2 mount')
                        resolve()
                    },1000)
                })
            }
            ],
            unmount: async () => {
                console.log('app2 unmount')
            }
        }
        // 当路径是#/a 的时候就加载 a应用
        // 所谓的注册应用 就是看一下路径是否匹配，如果匹配则“加载”对应的应用
        registerApplication('a', async () => app1, location => location.hash.startsWith('#/a'), { a: 1 })
        registerApplication('b', async () => app2, location => location.hash.startsWith('#/b'), { a: 1 })
        // 开启路径的监控，路径切换的时候 可以调用对应的mount unmount
        start()


        // 这个监控操作 应该被延迟到 当应用挂挂载完毕后再行
        window.addEventListener('hashchange', function () {
            console.log(window.location.hash, 'p----')
        })
        // window.addEventListener('popstate',function(){
        //     console.log(window.location.hash,'p----')
        // })
    </script>
<a onclick="go('#/a')">a应用</a>
<a onclick="go('#/b')">b应用</a>
<script>
    function go(url) { // 用户调用pushState replaceState 此方法不会触发逻辑reroute
        history.pushState({}, null, url)
    }
</script>
</body>

</html>
由此可见，single-spa的核心功能就是 注册应用 registerApplication 启动应用 start
以及应用的生命周期 也可以称作为接入协议
bootstrap, mount, and unmount的实现是必须的，unload则是可选的
生命周期函数是 single-spa 在注册的应用上调用的一系列函数，single-spa 会在各应用的主文件中，查找对应的函数名并进行调用。
2.实现核心方法 registerApplication & start
index.html
用自己实现的single-spa方法替代 CDN
<script src="https://cdn.bootcdn.net/ajax/libs/single-spa/5.9.3/umd/single-spa.min.js"></script>
import { registerApplication, start } from './single-spa/single-spa.js'
single-spa文件夹下  目录树
single-spa
│
├── application   // 主应用
│   ├── app.helpers.js      // 定义应用状态和辅助函数，如判断应用是否激活、应加载或卸载等。
│   └── app.js              // 处理应用的注册逻辑，包括保存注册的应用和执行重路由。
│
├── lifecycles //生命周期
│   ├── bootstrap.js        // 处理应用的启动逻辑，将应用状态从未启动转变为未挂载。
│   ├── load.js             // 处理应用的加载逻辑，将应用状态从未加载转变为未启动。
│   ├── mount.js            // 处理应用的挂载逻辑，将应用状态从未挂载转变为已挂载。
│   └── unmount.js          // 处理应用的卸载逻辑，将应用状态从已挂载转变为未挂载。
│
├── navigation  // 路由导航系统
│   ├── navigation-event.js // 劫持和处理路由事件，确保应用根据URL变化正确响应。
│   └── reroute.js          // 核心路由重定向逻辑，决定何时加载、启动、挂载或卸载应用。
│
├── single-spa.js          // 框架的入口文件，导出 `registerApplication` 和 `start` 方法。
└── start.js               // 定义 `start` 方法，启动 `single-spa` 应用，允许应用挂载。

export { registerApplication } from "./application/app.js"; // 根据路径加载应用
export { start } from "./start.js"; // 开启应用 挂载组件
主应用 application下：
app.js 的主要作用
1. 应用注册
  ○ app.js 提供了 registerApplication 函数，用于注册微前端应用。这是微前端架构中的一个关键步骤，因为它决定了如何和何时加载各个独立的应用。
  ○ 在注册应用时，需要提供应用的名称、加载函数、激活条件（例如特定的路由路径），以及自定义属性。
2. 状态管理
  ○ 通过 apps 数组来管理所有注册的应用。每个应用都有其对应的状态，如未加载、加载中、已加载等。
  ○ 状态的变更通常会触发相应的生命周期事件（例如加载、挂载、卸载）。
3. 重路由逻辑
  ○ 在应用注册后，app.js 通过调用 reroute 函数来处理可能的路由变化。这是确保应用根据当前URL正确加载和展示的关键。
app.js 的核心流程
1. 应用注册
  ○ 当调用 registerApplication 函数时，会创建一个包含应用信息的对象，并将其添加到 apps 数组中。这个对象包含应用的名称、加载函数、激活条件、自定义属性和当前状态。
2. 初始化应用状态
  ○ 初始状态设置为 NOT_LOADED，表示应用尚未加载。
3. 触发重路由
  ○ 注册应用后，调用 reroute 函数。reroute 负责检查当前URL，确定哪些应用需要被加载、激活或卸载。
4. 应用加载与激活
  ○ 基于当前URL和应用的激活条件，reroute 决定哪些应用应该被加载。加载过程由应用的加载函数控制，这通常涉及到下载和执行代码。
  ○ 一旦应用被加载，它将根据其生命周期进入下一阶段，比如启动和挂载。

import { reroute } from "../navigation/reroute.js";
import { NOT_LOADED } from "./app.helpers.js"

export const apps = []
export function registerApplication(appName,loadApp,activeWhen,customProps){
    const registeration = {
        name:appName,
        loadApp,
        activeWhen,
        customProps,
        status:NOT_LOADED
    }
    apps.push(registeration)

    // 我们需要给每个应用添加对应的状态变化

    // 未加载 -》 加载 -》挂载 -》 卸载

    // 需要检查哪些应用要被加载，还有哪些应用要被挂载，还有哪些应用要被移除
    reroute(); // 重写路由
}
app.helpers.js 主要作用
应用状态定义
● 状态常量：定义了一系列描述应用生命周期各阶段的常量，如 NOT_LOADED（未加载），LOADING_SOURCE_CODE（加载中），NOT_BOOTSTRAPED（未启动），NOT_MOUNTED（未挂载），MOUNTED（已挂载）等。这些状态对应于应用从被注册到被加载、启动、挂载和最终卸载的整个过程。
状态判断函数
● isActive：判断一个应用是否处于已挂载状态（即当前正被用户使用）。
● shouldBeActive：根据应用的激活规则（通常是基于URL的规则）判断一个应用是否应该被激活（即是否应该加载和挂载）。
应用变更辅助函数
● getAppChanges：这个函数是 single-spa 中非常关键的部分，它负责计算出基于当前URL应该被加载、挂载或卸载的应用集合。具体而言，它会遍历所有已注册的应用，并根据它们的当前状态和激活规则，将它们归类为待加载（appsToLoad）、待挂载（appsToMount）和待卸载（appsToUnmount）。
import { apps } from "./app.js";

// app status
export const NOT_LOADED = 'NOT_LOADED'; // 没有被加载 
export const LOADING_SOURCE_CODE = 'LOADING_SOURCE_CODE'; // 路径匹配了 要去加载这个资源
export const LOAD_ERROR = 'LOAD_ERROR'

// 启动的过程
export const NOT_BOOTSTRAPED = 'NOT_BOOTSTRAPED'; // 资源加载完毕了 需要启动，此时还没有启动
export const BOOTSTRAPING = 'BOOTSTRAPING'; // 启动中
export const NOT_MOUNTED = 'NOT_MOUNTED'; // 没有被挂载

// 挂载流程 
export const MOUNTING = 'MOUNTING'; // 正在挂载
export const MOUNTED = 'MOUNTED'; // 挂载完成

// 卸载流程
export const UNMOUNTING = 'UNMOUNTING'; // 卸载中


// 加载正在下载应用 LOADING_SOURCE_CODE，激活已经运行了


// 看一下这个应用是否正在被激活 
export function isActive(app){
    return app.status === MOUNTED; // 此应用正在被激活
}
// 看一下此应用是否被激活
export function shouldBeActive(app){
    return app.activeWhen(window.location)
}

export function getAppChanges(){
    const appsToLoad = []
    const appsToMount = []
    const appsToUnmount = []

    apps.forEach((app)=>{
        let appShouldBeActive = shouldBeActive(app)
        switch(app.status){
            case NOT_LOADED:
            case LOADING_SOURCE_CODE:
                // 1） 标记当前路径下 哪些应用要被加载
                if(appShouldBeActive){
                    appsToLoad.push(app)
                }
                break;
            case NOT_BOOTSTRAPED:  
            case BOOTSTRAPING:
            case NOT_MOUNTED:
                // 2) 当前路径下 哪些应用要被挂在
                if(appShouldBeActive){
                    appsToMount.push(app)
                }
                break;
            case MOUNTED:
                // 3） 当前路径下 哪些应用要被卸载
                if(!appShouldBeActive){
                    appsToUnmount.push(app)
                }
                break
            default:
                break;
        }
    })
    return {appsToLoad,appsToMount,appsToUnmount}
}
生命周期lifecycles下:
应用的生命周期管理（bootstrap、load、mount、unmount）

bootstrap.js
这个文件处理应用的启动流程。
● toBootstrapPromise 函数：
  ○ 检查应用是否处于未启动状态（NOT_BOOTSTRAPED），如果是，则将状态改变为启动中（BOOTSTRAPING）。
  ○ 然后执行应用的 bootstrap 方法（通常用于初始化操作），并在完成后将状态改变为未挂载（NOT_MOUNTED）。
import { BOOTSTRAPING, NOT_BOOTSTRAPED, NOT_MOUNTED } from "../application/app.helpers.js";

export function toBootstrapPromise(app){
    return Promise.resolve().then(()=>{
        if(app.status !== NOT_BOOTSTRAPED){
            // 此应用加载完毕了 
            return app;
        }
        app.status = BOOTSTRAPING

        return app.bootstrap(app.customProps).then(()=>{
            app.status = NOT_MOUNTED;
            return app
        })
    })
}
load.js
这个文件处理应用的加载流程。
toLoadPromise 函数：
● 检查应用是否处于未加载状态（NOT_LOADED），如果是，则将状态改变为加载中（LOADING_SOURCE_CODE）。
● 然后加载应用（loadApp 方法），通常包括下载和执行代码。
● 加载完成后，将状态改为未启动（NOT_BOOTSTRAPED），并准备应用的启动、挂载和卸载方法。
import { LOADING_SOURCE_CODE, NOT_BOOTSTRAPED, NOT_LOADED } from "../application/app.helpers.js"


function flattenArrayToPromise(fns) {
    fns = Array.isArray(fns) ? fns : [fns]
    return function(props){ // redux 
        return fns.reduce((rPromise,fn)=>rPromise.then(()=>fn(props)), Promise.resolve())
    }
}
export function toLoadPromise(app){
    return Promise.resolve().then(()=>{
        if(app.status !== NOT_LOADED){
            // 此应用加载完毕了 
            return app;
        }
        app.status = LOADING_SOURCE_CODE; // 正在加载应用

        // loadApp 对于之前的内容 System.import()
        return app.loadApp(app.customProps).then(v=>{
            const {bootstrap,mount,unmount} = v;
            app.status = NOT_BOOTSTRAPED;
            app.bootstrap = flattenArrayToPromise(bootstrap);
            app.mount = flattenArrayToPromise(mount);
            app.unmount = flattenArrayToPromise(unmount);

            return app
        })
    })
}
mount.js
这个文件处理应用的挂载流程。
oMountPromise 函数：
● 检查应用是否处于未挂载状态（NOT_MOUNTED），如果是，则执行挂载操作（mount 方法）。
● 挂载完成后，将应用状态改为已挂载（MOUNTED）。
import {  MOUNTED, NOT_MOUNTED } from "../application/app.helpers.js";

export function toMountPromise(app){
    return Promise.resolve().then(()=>{
        if(app.status !== NOT_MOUNTED){
            return app;
        }
        return app.mount(app.customProps).then(()=>{
            app.status = MOUNTED;
            return app
        })
    })
}
unmount.js
这个文件处理应用的卸载流程。
toUnmountPromise 函数：
● 检查应用是否处于已挂载状态（MOUNTED），如果是，则执行卸载操作（unmount 方法）。
● 卸载完成后，将应用状态改为未挂载（NOT_MOUNTED）。
import { MOUNTED, NOT_MOUNTED, UNMOUNTING } from "../application/app.helpers.js"

export function toUnmountPromise(app){
    return Promise.resolve().then(()=>{
        if(app.status !== MOUNTED){
            return app;
        }
        app.status = UNMOUNTING;
        // app.unmount 方法用户可能写的是一个数组。。。。。
        return app.unmount(app.customProps).then(()=>{
            app.status = NOT_MOUNTED;
        })
    })
}
导航系统 navigation下：
navigation-event.js主要作用
navigation-event.js 文件在 single-spa 微前端框架中扮演着重要的角色，主要负责劫持和管理浏览器的路由事件，以确保在URL变化时，应用能够按需加载、激活或卸载。下面是对其核心流程的概括和解释：
劫持路由事件
● 监听路由变化：通过监听 hashchange 和 popstate 事件，navigation-event.js 能够捕捉到浏览器地址栏的变化。这些变化通常表示用户正在进行导航（比如点击后退按钮或更改URL）。
● 重写事件监听器：该文件重写了 window.addEventListener 和 window.removeEventListener 方法。这样做是为了能够控制这些事件的监听器，即确保 single-spa 能够在必要时触发重路由逻辑，而不是仅依赖于浏览器默认行为。
管理自定义事件监听器
● capturedEventListeners：用于存储被框架捕获的事件监听器。当路由事件（如 hashchange 或 popstate）触发时，这些监听器将被调用。
● 调整事件监听器的行为：当应用尝试添加或移除路由事件监听器时，navigation-event.js 会根据其内部逻辑调整这些监听器的行为，以确保框架能够正确地处理路由变化。
触发重路由逻辑
● callCaptureEventListeners：当路由发生变化时，这个函数负责调用所有被捕获的监听器，并最终触发 reroute 方法，启动应用加载或卸载的流程。
拦截历史API的调用
● patchFn：对 window.history.pushState 和 window.history.replaceState 进行了补丁，以便在这些方法被调用时（即使是程序性地修改URL），也能触发 reroute 方法。
// 对用户的路径切换 进行劫持，劫持后，重新调用reroute方法，进行计算应用的加载

import { reroute } from "./reroute.js";


function urlRoute() {
    reroute(arguments)
}

window.addEventListener('hashchange', urlRoute)
window.addEventListener('popstate', urlRoute); // 浏览器历史切换的时候会执行此方法


// 但是当路由切换的时候 我们触发single-spa的addEventLister, 应用中可能也包含addEventLister


// 需要劫持原生的路由系统，保证当我们加载完后再切换路由

const capturedEventListeners = {
    hashchange: [],
    popstate: []
}

const listentingTo = ['hashchange', 'popstate']
const originalAddEventListener = window.addEventListener;
const originalRemoveEventListener = window.removeEventListener;

window.addEventListener = function (eventName, callback) {
    // 有要监听的事件， 函数不能重复
    if (listentingTo.includes(eventName) && !capturedEventListeners[eventName].some(listener => listener === callback)) {
        return capturedEventListeners[eventName].push(callback)
    }
    return originalAddEventListener.apply(this, arguments)
}
window.removeEventListener = function (eventName, callback) {
    // 有要监听的事件， 函数不能重复
    if (listentingTo.includes(eventName)) {
        capturedEventListeners[eventName] = capturedEventListeners[eventName].filter(fn => fn !== callback)
        return
    }
    return originalRemoveEventListener.apply(this, arguments)
}

export function callCaptureEventListeners(e) {
    if (e) {
        const eventType = e[0].type;
        if (listentingTo.includes(eventType)) {
            capturedEventListeners[eventType].forEach(listener => {
                listener.apply(this, e)
            });
        }
    }
}

function patchFn(updateState, methodName) {
    return function () {
        const urlBefore = window.location.href;
        const r = updateState.apply(this, arguments); // 调用此方法 确实发生了路径的变化
        const urlAfter = window.location.href;

        if (urlBefore !== urlAfter) {
            // 手动派发popstate事件
            window.dispatchEvent(new PopStateEvent("popstate"))
        }
        return r;
    }
}

window.history.pushState = patchFn(window.history.pushState, 'pushState')

window.history.replaceState = patchFn(window.history.replaceState, 'replaceState')
reroute.js主要作用
确定应用状态变更
● 计算应用变更：reroute 使用 getAppChanges 函数来确定哪些应用需要被加载、挂载或卸载。这是基于每个应用的当前状态（如未加载、未挂载等）和激活条件（通常是基于URL的规则）。
管理应用加载和挂载
● 加载应用：如果确定某些应用需要被加载（它们处于 NOT_LOADED 或 LOADING_SOURCE_CODE 状态），reroute 会调用相应的加载逻辑（通常是 toLoadPromise）。
● 挂载应用：对于已加载但未挂载的应用，reroute 会触发它们的挂载流程（通过 toMountPromise）。
处理应用卸载
● 卸载应用：如果当前路由状态不再需要某些已挂载的应用，reroute 会调用卸载逻辑（toUnmountPromise）以释放资源和清理。
处理并发路由变更
● 异步队列管理：reroute 还处理并发的路由变更请求。如果在一个应用变更过程中，另一个路由变更被触发，它会将这个新请求放入一个队列中，以便按顺序处理。
触发应用更新
● 应用更新：在路由变更后，reroute 确保每个应用都处于正确的状态，并且已挂载的应用能够响应最新的路由状态。
import { getAppChanges, shouldBeActive } from "../application/app.helpers.js";
import { toBootstrapPromise } from "../lifecycles/bootstrap.js";
import { toLoadPromise } from "../lifecycles/load.js";
import { toMountPromise } from "../lifecycles/mount.js";
import { toUnmountPromise } from "../lifecycles/unmount.js";
import { started } from "../start.js";
import './naviation-event.js'
import { callCaptureEventListeners } from "./naviation-event.js";



// 后续路径变化 也需要走这里， 重新计算哪些应用被加载或者写在

let appChangeUnderWay = false;
let peopleWaitingOnAppChange = []
export function reroute(event) {

    // 如果多次触发reroute 方法我们可以创造一个队列来屏蔽这个问题
    if(appChangeUnderWay){
        return new Promise((resolve,reject)=>{
            peopleWaitingOnAppChange.push({
                resolve,reject
            })
        })
    }
    // 获取app对应的状态 进行分类
    const { appsToLoad, appsToMount, appsToUnmount } = getAppChanges()
    // 加载完毕后 需要去挂载的应用
    if(started){
        appChangeUnderWay = true
        // 用户调用了start方法 我们需要处理当前应用要挂载或者卸载
        return performAppChange();
    }
    // 先拿到应用去加载  -》
    return loadApps();
    function loadApps() {
        // 应用的加载
        return Promise.all(appsToLoad.map(toLoadPromise)).then(callEventListener)// 目前我们没有调用start 
    }
    function performAppChange(){
        // 将不需要的应用卸载掉, 返回一个卸载的promise
        // 1) 稍后测试销毁逻辑
        const unmountAllPromises = Promise.all(appsToUnmount.map(toUnmountPromise))

        // 流程加载需要的应用  -》 启动对应的应用 -》 卸载之前的 -》 挂载对应的应用

        // 2) 加载需要的应用（可能这个应用在注册的时候已经被加载了）

        // 默认情况注册的时候 路径是 /a , 但是当我们start的时候应用是/b
        const loadMountPromises = Promise.all(appsToLoad.map(app=> toLoadPromise(app).then(app=>{
            // 当应用加载完毕后 需要启动和挂载，但是要保证挂载前 先卸载掉来的应用
            return  tryBootstrapAndMount(app,unmountAllPromises)
        })));

        // 如果应用 没有加载   加载 -》启动挂载   如果应用已经加载过了  挂载
        const MountPromises = Promise.all(appsToMount.map(app=> tryBootstrapAndMount(app,unmountAllPromises)))

        function tryBootstrapAndMount(app,unmountAllPromises){
            if(shouldBeActive(app)){
                // 保证卸载完毕在挂载
                return toBootstrapPromise(app).then(app=> unmountAllPromises.then(()=> toMountPromise(app)))
            }
        }
        
        return Promise.all([loadMountPromises,MountPromises]).then(()=>{ // 卸载完毕后
            callEventListener();
            appChangeUnderWay = false;
            if(peopleWaitingOnAppChange.length > 0){
                peopleWaitingOnAppChange = []; // 多次操作 我缓存起来，。。。。
            }
           
        })
    }

    function callEventListener(){
        callCaptureEventListeners(event)
    }

}
五、qiankun从入门到实战
创建 React 主应用（Substrate）
1. 创建 React 应用：首先，你需要使用 Create React App 创建一个新的 React 应用。打开终端并运行以下命令：
npx create-react-app substrate
cd substrate
2. 安装乾坤：在你的主应用中安装乾坤依赖。
npm install qiankun --save
3. 配置主应用：接下来，你需要在主应用中配置乾坤。打开 src/App.js 并修改文件，以便注册子应用并启动乾坤。
import { registerMicroApps, start } from 'qiankun';

function App() {
  // 在这里注册子应用
  registerMicroApps([
     {
        name: 'reactApp',
        entry: '//localhost:40000', // 默认react启动的入口是10000端口
        activeRule: '/react', // 当路径是 /react的时候启动
        container: '#container', // 应用挂载的位置
        loader,
        props: { a: 1, util: {} }
    },
    {
        name: 'vueApp',
        entry: '//localhost:20000', // 默认react启动的入口是10000端口
        activeRule: '/vue', // 当路径是 /react的时候启动
        container: '#container', // 应用挂载的位置
        loader,
        props: { a: 1, util: {} }
    }
  ]);

  // 启动乾坤
  start();

  return (
    <div className="App">
    <h1>主应用</h1>
    <div id="subapp-container" />
    </div>
  );
}

export default App;
4. 启动主应用：最后，运行你的主应用。
npm start
创建 React 子应用（m-react）
1. 创建 React 子应用：在新的终端窗口中，使用 Create React App 创建另一个 React 应用。
npx create-react-app m-react
cd m-react
2. 安装乾坤子应用依赖：为了使该应用作为乾坤的子应用运行，你需要安装一些依赖。
npm install qiankun @rescripts/cli -D
@rescripts/cli 是一个工具，允许你在不需要'eject'的情况下，自定义 Create React App 的 webpack 配置。在微前端架构中，通常需要对子应用的 webpack 配置进行一些调整，以确保它们能够正确地作为微前端子应用运行。例如，你可能需要修改输出格式、设置 public path 等。使用 @rescripts/cli 可以让你轻松地进行这些配置，而无需对 Create React App 的默认配置进行破坏性的修改。
3. 配置子应用：修改 package.json，以便使用 @rescripts/cli。
"scripts": {
  	"start": "rescripts start",
    "build": "rescripts build",
    "test": "rescripts test",
    "eject": "rescripts eject"
}
然后，在子应用的根目录下创建一个 .rescriptsrc.js 文件来配置子应用的 webpack。
qiankun前端要求应用暴露的方式是umd格式。
module.exports = {
    webpack:(config)=>{
        config.output.libraryTarget = 'umd';
        config.output.library = 'm-react'; // 打包的格式是umd格式
        return config
    },
    devServer:(config)=>{
        config.headers = {
            'Access-control-Allow-Origin':"*"
        }
        return config
    }
}
4. 修改子应用入口文件：在 src/index.js 中，将子应用暴露给乾坤。
import './registerApps';
创建一个新文件 src/registerApps.js，包含子应用的启动逻辑。
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';

function render(props) {
  const { container } = props;
  ReactDOM.render(<App />, container ? container.querySelector('#root') : document.querySelector('#root'));
}
// 独立运行时
if (!window.__POWERED_BY_QIANKUN__) {
  render({});
}

export async function bootstrap() {
  console.log('React 子应用 bootstraped');
}

export async function mount(props) {
  console.log('React 子应用 mount');
  render(props);
}

export async function unmount(props) {
  const { container } = props;
  ReactDOM.unmountComponentAtNode(container ? container.querySelector('#root') : document.querySelector('#root'));
}
在 m-react项目的src目录下新建public-path.js 
if(window.__POWERED_BY_QIANKUN__){//检查子应用是否在乾坤环境中运行
  //如果子应用是通过乾坤加载的，window.__POWERED_BY_QIANKUN__ 会被设置为 true。
  // 当子应用在乾坤环境下运行时，这行代码会将 webpack 的 public path 设置为乾坤注入的 public path。
  //保证静态资源正常加载
  // eslint-disable-next-line no-undef
    __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__
}
在根目录下 新建 .env文件
PORT=40000 
WDS_SOCKET_PORT=40000
1. PORT=40000：
  ○ 这个环境变量用于指定应用运行时使用的端口号。
  ○ 默认情况下，CRA 会让 React 应用运行在 3000 端口。通过设置 PORT 环境变量，你可以改变应用运行的端口。
  ○ 在这个例子中，将 PORT 设置为 40000 意味着当你运行这个 React 应用时，它将在 localhost:40000 上可用。
2. WDS_SOCKET_PORT=40000：
  ○ WDS 代表 Webpack Dev Server，它是一个提供实时重载功能的小型 Express 服务器。
  ○ WDS_SOCKET_PORT 环境变量用于指定 Webpack Dev Server 用于 WebSocket 连接的端口。
  ○ 这在你需要 Webpack Dev Server 监听一个特定端口以实现例如实时重新加载的功能时很有用。
  ○ 设置 WDS_SOCKET_PORT 为 40000 意味着 Webpack Dev Server 的 WebSocket 连接将使用这个端口。
5. 启动 React 子应用：在 3001 端口上启动 React 子应用。
npm start
创建 Vue 子应用（m-vue）
1. 创建 Vue 子应用：使用 Vue CLI 创建 Vue 应用。
vue create m-vue
cd m-vue
2. 安装乾坤子应用依赖：和 React 子应用一样，安装所需依赖。
npm install qiankun -S
3. 配置 Vue 子应用：修改 vue.config.js 文件，配置子应用的 webpack。
const { defineConfig } = require('@vue/cli-service')
module.exports = defineConfig({
  transpileDependencies: true,
  devServer:{
    port:20000,
    headers:{
      'Access-Control-Allow-Origin':"*" //子应用跨域
    }
  },
  configureWebpack:{
    output:{
      libraryTarget:'umd',
      library:'m-vue'
    }
  }
})

4. 修改子应用入口文件：在 src/main.js 中配置子应用的生命周期。
import './public-path.js'
import { createApp } from 'vue'
import { createRouter, createWebHashHistory, createWebHistory } from 'vue-router';
import App from './App.vue'
import routes from './router'

let app;
let history;
let router;
function render(props) {
    app = createApp(App)
    history = createWebHistory(window.__POWERED_BY_QIANKUN__ ? '/vue' : '/')
    router = createRouter({
        history,
        routes
    })
    app.use(router)
    const container = props.container
    app.mount(container ? container.querySelector('#app') : document.getElementById('app'))
}

if (!window.__POWERED_BY_QIANKUN__) {
    render({})
}

export async function bootstrap() {
    console.log('vue bootsrap')
}
export async function mount(props) {
    render(props)
}
export async function unmount() {
    app.unmount()
    history.destroy();
    app = null;
    router = null
}
5.在src目录下 添加 public-path.js 文件
当子应用在乾坤环境下运行时，这行代码会将 webpack 的 public path 设置为乾坤注入的 public path
保证静态资源的正常加载
if(window.__POWERED_BY_QIANKUN__){
    // eslint-disable-next-line no-undef
    __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__
}
动态加载static子应用
一些非 webpack 构建的项目，例如 jQuery 项目、jsp 项目，都可以按照这个处理。
接入之前请确保你的项目里的图片、音视频等资源能正常加载，如果这些资源的地址都是完整路径（例如 https://qiankun.umijs.org/logo.png），则没问题。如果都是相对路径，需要先将这些资源上传到服务器，使用完整路径。
接入非常简单，只需要额外声明一个 script，用于 export 相对应的 lifecycles。例如:
1. 声明 entry 入口
<!DOCTYPE html>
  <html lang="en">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Purehtml Example</title>
  </head>
  <body>
  <div>
  Purehtml Example
  </div>
  </body>

  + <script src="//yourhost/entry.js" entry></script>
  </html>
2. 在 entry js 里声明 lifecycles
const render = ($) => {
  $('#purehtml-container').html('Hello, render with jQuery');
  return Promise.resolve();
};


((global) => {
  global['m-static'] = {
    bootstrap: () => {
      console.log('purehtml bootstrap');
      return Promise.resolve();
    },
    mount: () => {
      console.log('purehtml mount');
      return render($);
    },
    unmount: () => {
      console.log('purehtml unmount');
      return Promise.resolve();
    },
  };
})(window);
3.在substrate基座里面可以通过 loadMicroApp动态加载 无需注册
import React from 'react'
import {BrowserRouter, Link} from 'react-router-dom'
import { useEffect } from 'react';
import { loadMicroApp} from 'qiankun'
function App() {
  const containerRef = React.createRef();
 
  useEffect(()=>{
    loadMicroApp({
      name:'m-static',
      entry: 'http://localhost:30000',
      container:containerRef.current
    })
  })
  // keep-alive 可以实现动态的加载
  return (
    <div className="App">
      <BrowserRouter>
          <Link to="/react">React应用</Link>
          <Link to="/vue">Vue应用</Link>
      </BrowserRouter>

      <div ref={containerRef}></div>

      <div id='container'></div>
    </div>  
  );
}

export default App;

4.http-server -p 30000 --cors  通过 http-server 来启动静态资源
主子应用间通讯
initGlobalState

在主应用定义全局状态，并返回通信方法，微应用通过 props 获取通信方法
全局开启sandbox
start({
    sandbox: {
        // 实现了动态样式表
        // css-module,scoped 可以再打包的时候生成一个选择器的名字  增加属性 来进行隔离
        // BEM
        // CSS in js
        // shadowDOM 严格的隔离

        // strictStyleIsolation:true,
        experimentalStyleIsolation: true // 缺点 就是子应用中的dom元素如果挂在到了外层，会导致样式不生效
    }
})
1. experimentalStyleIsolation（实验性样式隔离）
experimentalStyleIsolation 是一种较为轻量的样式隔离方式。它在运行时动态地给子应用的所有 DOM 元素添加一个独特的属性（如 data-qiankun），并重写子应用的所有 CSS 选择器，使它们只对带有该特定属性的元素生效。
registerMicroApps([
  {
    name: 'app1',
    entry: '//localhost:3001',
    container: '#container',
    activeRule: '/app1',
    props: { ... },
    // 开启实验性样式隔离
    experimentalStyleIsolation: true
  },
  // ...其他子应用配置
]);

2. strictStyleIsolation（严格样式隔离）
strictStyleIsolation 是一种更为严格的样式隔离方式，它利用了 Shadow DOM 的封装特性。通过将子应用的 DOM 封装在一个 Shadow DOM 容器中，子应用的 CSS 样式完全隔离，不会影响到外部的 DOM。
registerMicroApps([
  {
    name: 'app2',
    entry: '//localhost:3002',
    container: '#container',
    activeRule: '/app2',
    props: { ... },
    // 开启严格样式隔离
    strictStyleIsolation: true
  },
  // ...其他子应用配置
]);
缺点:
● experimentalStyleIsolation：由于是在运行时重写 CSS 选择器，可能会有性能影响，尤其是在子应用有大量样式规则时。同时，这种方法可能不适用于动态插入的样式或使用 Shadow DOM 的组件。
● strictStyleIsolation：使用 Shadow DOM 可以提供最彻底的样式隔离，但需要考虑浏览器的兼容性。旧版浏览器可能不支持 Shadow DOM，或者支持不完全。
● 子应用中的dom元素如果挂在到了外层，会导致样式不生效。
Web Components
是一种浏览器标准，允许开发者创建可重用的定制元素，并且在Web应用中封装代码和结构。Web Components由三个主要技术组成：Custom Elements、Shadow DOM和HTML Templates。
1. Custom Elements: 自定义元素允许您创建自己的HTML标签。您可以定义新的HTML元素或扩展现有的元素，并为它们添加自定义行为。
2. Shadow DOM: Shadow DOM是一种封装技术，它允许Web组件的内部结构、样式和行为隐藏起来，不受外部文档的干扰。这意味着组件的内部结构对外界是不可见的，外部样式也不会影响到组件内部。
3. HTML Templates (<template> 和 <slot>): <template>标签用于声明性地定义一段HTML代码，该代码可以在创建组件时复用。<slot>标签则用于定义可插入内容的位置，使得组件可以接收外部内容。
Shadow DOM是Web Components中的重要组成部分，它通过创建一个“影子”DOM树来实现封装。这个影子DOM树与主DOM树分离，拥有自己的作用域。这意味着在Shadow DOM中定义的CSS样式不会泄露到外部，外部的CSS样式也不会影响到Shadow DOM内部。
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="outer">abc</div>
    <script>
        // 影子dom  video audio标签
        const template = `<div id="qiankun-xxx">
            <div id="inner">bcd</div>    
            <style>div{color:red}</style>
        </div>`;//创建模板字符串
        const container = document.createElement('div');//创建容器元素
        container.innerHTML = template;
        const appElement = container.firstChild//获取模板的第一个子元素
        let oldContent = appElement.innerHTML; // 备份原始内容
        appElement.innerHTML = ''
        let shadow = appElement.attachShadow({ mode: 'closed' })//开启Shadow DOM
        shadow.innerHTML = oldContent; // 放到影子dom中
        document.body.appendChild(appElement)

        console.dir(shadow.querySelector('#inner'))
    </script>
</body>
</html>
六、qiankun JS沙箱原理
乾坤（Qiankun）是一个基于微前端架构的框架，它提供了JavaScript沙箱机制来保证主应用和微应用之间的隔离，特别是在全局环境（如window对象）的修改上。乾坤中的JS沙箱主要通过以下几种方式实现：
1. 代理沙箱（Proxy Sandbox）
乾坤使用代理（Proxy）对象来创建一个虚拟的全局环境。这个环境对微应用来说就像是一个独立的全局环境，但实际上它是对真实全局环境的一个层层封装。当微应用尝试修改全局环境（如更改window对象的属性）时，这些更改实际上只影响代理对象，而不是真正的全局环境。
2. 快照沙箱（Snapshot Sandbox）
乾坤还提供了快照沙箱机制。这种机制在微应用激活时对全局环境（如window对象）进行"快照"，在微应用卸载或失活时，再将全局环境还原到快照时的状态。这样，即使微应用对全局环境进行了修改，这些修改也不会影响到主应用或其他微应用。
1.快照沙箱的实现（Snapshot Sandbox）
 class SnapshotSandbox {
            constructor(){
                this.modifyPropsMap = {}; // 存储全局哪些属性被修改了
            }
            active(){
                this.windowSnapShot = {};
                // 给window拍照
                Object.keys(window).forEach(prop=>{
                    this.windowSnapShot[prop] = window[prop]
                })
                Object.keys(this.modifyPropsMap).forEach(prop=>{
                    window[prop] = this.modifyPropsMap[prop]
                })
            }
            inactive(){
                this.modifyPropsMap = {}
                Object.keys(window).forEach(prop=>{
                    if(window[prop] !== this.windowSnapShot[prop]){
                        this.modifyPropsMap[prop] = window[prop];  
                        window[prop] = this.windowSnapShot[prop];
                    }
                })
            }
        }
        let sandbox = new SnapshotSandbox();
        sandbox.active();
        window.a = 100;
        window.b = 200;
        sandbox.inactive();
        console.log(window.a,window.b)
        sandbox.active();
        console.log(window.a,window.b)
缺点就是 浪费内存， window快照， 存储修改的或者添加的属性，不要给window拍照。
2.传统沙箱的实现（LegacySandbox）
class LegacySandbox {
            constructor(){
                // 1) 修改的内容  2) 新增的内容  3) 不管修改还是新增的
                this.modifyPropsMap = new Map();
                this.addedPropsMap = new Map();
                this.currentPropsMap = new Map();

                const fakeWindow = Object.create(null)
                const proxy = new Proxy(fakeWindow,{
                    get:(target,key,recevier)=>{
                        return window[key]
                    },
                    set:(target,key,value)=>{
                        if(!window.hasOwnProperty(key)){
                            // 添加的属性
                            this.addedPropsMap.set(key,value)
                        }else if(!this.modifyPropsMap.has(key)){
                            // 保存修改的前的值
                            this.modifyPropsMap.set(key,window[key])
                        }
                        // 所有的修改操作都保留了一份最新的
                        this.currentPropsMap.set(key,value);
                        window[key] = value;// 修改成最新的内容 
                    },
                })
                this.proxy = proxy
            }
            setWindowProp(key,value){
                if(value == undefined){
                    delete window[key];
                }else{
                    window[key] = value; // 覆盖修改前的
                }
            }
            active(){
                this.currentPropsMap.forEach((value,key)=>{
                    this.setWindowProp(key,value)
                })
            }
            inactive(){
                this.modifyPropsMap.forEach((value,key)=>{
                    this.setWindowProp(key,value)
                })
                this.addedPropsMap.forEach((value,key)=>{
                    this.setWindowProp(key,undefined)
                })
            }
        }
        let sandbox = new LegacySandbox();
        sandbox.proxy.a = 100;
        console.log(window.a,sandbox.proxy.a)
        sandbox.inactive();
        console.log(window.a,sandbox.proxy.a)
        sandbox.active();
        console.log(window.a,sandbox.proxy.a)
基于proxy的沙箱 （如果两个应用一起运行 window就一个 就乱了。。。）
相比较Snapshot更加节约内存
快照 、 基于proxy 只能单例的情况下使用，同时加载两个应用就会混乱 风险
3.多实例Proxy快照(ProxySandbox)
class ProxySandbox {
            constructor() {
                this.running = false
                const fakeWindow = Object.create(null)
                this.proxy = new Proxy(fakeWindow, {
                    get: (target, key) => {
                        return key in target ? target[key] : window[key]
                    },
                    set: (target, key, value) => {
                        if (this.running) {
                            target[key] = value;
                        }
                        return true;
                    }
                    // 修改不在操作window属性
                })
            }
            active() {
                if (!this.running) this.running = true
            }
            inactive() {
                this.running = false;
            }
        }
        let sandbox1 = new ProxySandbox();
        let sandbox2 = new ProxySandbox();
        sandbox1.active();
        sandbox2.active();
        sandbox1.proxy.a = 100;
        sandbox2.proxy.a = 100; // 不会影响window
        console.log(sandbox1.proxy.a)
        console.log(sandbox2.proxy.a)
        sandbox1.inactive();
        sandbox2.inactive();
        sandbox1.proxy.a = 200;
        sandbox2.proxy.a = 200;
        console.log(sandbox1.proxy.a, window.a)
        console.log(sandbox2.proxy.a)
            (function (window) {
            })(sandbox1.proxy)

            (function (window) {
            })(sandbox2.proxy)
多个fakeWindow实例来操作，如果是active激活态就是能够挂载属性，如果是inactive失活态就是不允许修改。
七、qiankun-master源码解析
1.源码核心方法 讲解
github下载qiankun master源码
https://github.com/umijs/qiankun/tree/master
针对src目录下的index.ts
/**
 * @author Kuitos
 * @since 2019-04-25
 */
export { loadMicroApp, registerMicroApps, start } from './apis';
export { initGlobalState } from './globalState';
export { getCurrentRunningApp as __internalGetCurrentRunningApp } from './sandbox';
export * from './errorHandler';
export * from './effects';
export * from './interfaces';
export { prefetchImmediately as prefetchApps } from './prefetch';
registerMicroApps 注册微应用组 底层基于single-spa的包装
export function registerMicroApps<T extends ObjectType>(
  apps: Array<RegistrableApp<T>>, // 本次要注册的应用
  lifeCycles?: FrameworkLifeCycles<T>, // 自己编写的生命周期
) {
  // 拿到没有被注册过的应用  name 属性就是用来区分不同的应用的
  const unregisteredApps = apps.filter((app) => !microApps.some((registeredApp) => registeredApp.name === app.name));
  // 最新要注册的应用
  microApps = [...microApps, ...unregisteredApps];
  // 循环注册未注册的应用
  unregisteredApps.forEach((app) => {
    // appConfig 应用的配置
    const { name, activeRule, loader = noop, props, ...appConfig } = app;
    // 注册应用的逻辑采用的是single-spa （路由劫持）
    registerApplication({
      name,
      app: async () => {
        loader(true);
        await frameworkStartedDefer.promise; // 等待调用start方法
        // loadApp方法返回的事一个函数 (loadApp())()，  沙箱的处理
        const { mount, ...otherMicroAppConfigs } = (
          await loadApp({ name, props, ...appConfig }, frameworkConfiguration, lifeCycles)
        )();

        return { // 返回的是应用的接入协议
          mount: [async () => loader(true), ...toArray(mount), async () => loader(false)],
          ...otherMicroAppConfigs,
        };
      },
      activeWhen: activeRule,
      customProps: props,
    });
    // 目前不会执行逻辑  会等待路径匹配后执行app方法
  });
}
核心方法 start()实现
注册采用的是single-spa start也是single-spa
1.预先加载的功能  -》 利用空闲时间进行加载其他应 requsetIdleCallback。
2.沙箱功能  css沙箱（创建一个sandbox 让你的execScript方法运行在sandbox） 样式隔离 (影子dom ， scopedcss)。
3.获取导出的接入协议（在沙箱中执行的） 进行扩展（增加了用户提供的生命周期）。

export function start(opts: FrameworkConfiguration = {}) {
  // 在start参数中 增加了 prefetch（预加载） （singular单例模式） （sandbox）沙箱
  frameworkConfiguration = { prefetch: true, singular: true, sandbox: true, ...opts };
  const {
    prefetch,
    sandbox,
    singular,
    urlRerouteOnly = defaultUrlRerouteOnly,
    ...importEntryOpts
  } = frameworkConfiguration;
  // 如果支持预加载，则开始调用预加载的策略
  if (prefetch) {
    doPrefetchStrategy(microApps, prefetch, importEntryOpts);
  }
  // 对沙箱来做降级处理 有的沙箱不支持proxy
  frameworkConfiguration = autoDowngradeForLowVersionBrowser(frameworkConfiguration);

  startSingleSpa({ urlRerouteOnly }); // 就是single-spa的start方法
  started = true;

  frameworkStartedDefer.resolve(); // 调用成功的promise
}

核心方法 doPrefechStrategy预加载策略
// 预先加载的策略
export function doPrefetchStrategy(
  apps: AppMetadata[],
  prefetchStrategy: PrefetchStrategy,
  importEntryOpts?: ImportEntryOpts,
) {
  const appsName2Apps = (names: string[]): AppMetadata[] => apps.filter((app) => names.includes(app.name));
  // prefetch:true
  if (Array.isArray(prefetchStrategy)) { // prefetch:[]
    prefetchAfterFirstMounted(appsName2Apps(prefetchStrategy as string[]), importEntryOpts);
  } else if (isFunction(prefetchStrategy)) { // pretch:function(){return []}
    (async () => {
      // critical rendering apps would be prefetch as earlier as possible
      const { criticalAppNames = [], minorAppsName = [] } = await prefetchStrategy(apps);
      prefetchImmediately(appsName2Apps(criticalAppNames), importEntryOpts);
      prefetchAfterFirstMounted(appsName2Apps(minorAppsName), importEntryOpts);
    })();
  } else {
    switch (prefetchStrategy) {
      case true:
        // 等待第一个应用加载完毕后 加载其他应用
        prefetchAfterFirstMounted(apps, importEntryOpts);
        break;

      case 'all':
        prefetchImmediately(apps, importEntryOpts);
        break;

      default:
        break;
    }
  }
}
prefetchAfterFirstMounted 等待第一个应用加载完毕后 加载其他应用
function prefetchAfterFirstMounted(apps: AppMetadata[], opts?: ImportEntryOpts): void {
  // single-spa中 默认内部 dispatchEvent('single-spa:first-mount')
  window.addEventListener('single-spa:first-mount', function listener() {
    // 获取到所谓未加载的app
    const notLoadedApps = apps.filter((app) => getAppStatus(app.name) === NOT_LOADED);

    if (process.env.NODE_ENV === 'development') {
      const mountedApps = getMountedApps();
      console.log(`[qiankun] prefetch starting after ${mountedApps} mounted...`, notLoadedApps);
    }
    // 获取没有加载的应用依次去加载
    notLoadedApps.forEach(({ entry }) => prefetch(entry, opts));
    // 加载完毕后移除监听
    window.removeEventListener('single-spa:first-mount', listener);
  });
}
prefech方法
使用import-html-entry 包 替代了 Systemjs进行 文件加载解析 (html加载 script注释 link外链加载)
function prefetch(entry: Entry, opts?: ImportEntryOpts): void {
  if (!navigator.onLine || isSlowNetwork) { // 如果慢网的情况或者无网的情况 结束
    // Don't prefetch if in a slow network or offline
    return;
  }

  requestIdleCallback(async () => {
    // 预加载入口文件  替代systemjs -> import-html-enttry  加载html注释掉 js和css文件
    const { getExternalScripts, getExternalStyleSheets } = await importEntry(entry, opts);
    requestIdleCallback(getExternalStyleSheets); // 获取额外的样式表和脚本的操作
    requestIdleCallback(getExternalScripts);
  });
}
沙箱降级方案autoDowngradeForLowVersionBrowser  有的沙箱不支持proxy
SnapshotSandbox LegacySandbox ProxySandbox
const autoDowngradeForLowVersionBrowser = (configuration: FrameworkConfiguration): FrameworkConfiguration => {
  const { sandbox, singular } = configuration;
  if (sandbox) {
    if (!window.Proxy) { // 不支持proxy 采用的是快照沙箱
      console.warn('[qiankun] Miss window.Proxy, proxySandbox will degenerate into snapshotSandbox');

      if (singular === false) {
        console.warn(
          '[qiankun] Setting singular as false may cause unexpected behavior while your browser not support window.Proxy',
        );
      }

      return { ...configuration, sandbox: typeof sandbox === 'object' ? { ...sandbox, loose: true } : { loose: true } };
    }
  }

  return configuration;
};
核心方法loadApp

export async function loadApp<T extends ObjectType>(
  app: LoadableApp<T>,
  configuration: FrameworkConfiguration = {},
  lifeCycles?: FrameworkLifeCycles<T>,
): Promise<ParcelConfigObjectGetter> {
  const { entry, name: appName } = app;
  // 给当前加载的应用起一个名字
  const appInstanceId = genAppInstanceIdByName(appName);

  const markName = `[qiankun] App ${appInstanceId} Loading`;
  if (process.env.NODE_ENV === 'development') {
    performanceMark(markName);
  }

  const {
    singular = false,
    sandbox = true,
    excludeAssetFilter,
    globalContext = window,
    ...importEntryOpts
  } = configuration;

  // get the entry html content and script executor
  // 获取html文件，并且拿到脚本的执行器
  const { template, execScripts, assetPublicPath, getExternalScripts } = await importEntry(entry, importEntryOpts);
  // trigger external scripts loading to make sure all assets are ready before execScripts calling

  // 获取额外的脚本
  await getExternalScripts();

  // as single-spa load and bootstrap new app parallel with other apps unmounting
  // (see https://github.com/CanopyTax/single-spa/blob/master/src/navigation/reroute.js#L74)
  // we need wait to load the app until all apps are finishing unmount in singular mode
  if (await validateSingularMode(singular, app)) { // 等待上一个卸载后，在去挂载
    await (prevAppUnmountedDeferred && prevAppUnmountedDeferred.promise);
  }
  // 获取文件内容， 对模板进行了处理
  const appContent = getDefaultTplWrapper(appInstanceId, sandbox)(template);
  // shadowDOM加载css方式
  const strictStyleIsolation = typeof sandbox === 'object' && !!sandbox.strictStyleIsolation;

  if (process.env.NODE_ENV === 'development' && strictStyleIsolation) {
    console.warn(
      "[qiankun] strictStyleIsolation configuration will be removed in 3.0, pls don't depend on it or use experimentalStyleIsolation instead!",
    );
  }
  // 作用域css的处理
  const scopedCSS = isEnableScopedCSS(sandbox);
  let initialAppWrapperElement: HTMLElement | null = createElement(
    appContent,
    strictStyleIsolation,
    scopedCSS,
    appInstanceId,
  );
  // 将应用初始化在哪里
  const initialContainer = 'container' in app ? app.container : undefined;
  const legacyRender = 'render' in app ? app.render : undefined;

  const render = getRender(appInstanceId, appContent, legacyRender);

  // 第一次加载设置应用可见区域 dom 结构
  // 确保每次应用加载前容器 dom 结构已经设置完毕
  render({ element: initialAppWrapperElement, loading: true, container: initialContainer }, 'loading');

  const initialAppWrapperGetter = getAppWrapperGetter(
    appInstanceId,
    !!legacyRender,
    strictStyleIsolation,
    scopedCSS,
    () => initialAppWrapperElement,
  );

  let global = globalContext;
  let mountSandbox = () => Promise.resolve();
  let unmountSandbox = () => Promise.resolve();
  const useLooseSandbox = typeof sandbox === 'object' && !!sandbox.loose; // 快照沙箱
  // enable speedy mode by default
  const speedySandbox = typeof sandbox === 'object' ? sandbox.speedy !== false : true;//proxy
  let sandboxContainer;
  if (sandbox) {
    sandboxContainer = createSandboxContainer( // 创建一个沙箱
      appInstanceId,
      // FIXME should use a strict sandbox logic while remount, see https://github.com/umijs/qiankun/issues/518
      initialAppWrapperGetter,
      scopedCSS,
      useLooseSandbox,
      excludeAssetFilter,
      global,
      speedySandbox,
    );
    // 用沙箱的代理对象作为接下来使用的全局对象
    global = sandboxContainer.instance.proxy as typeof window;
    mountSandbox = sandboxContainer.mount;
    unmountSandbox = sandboxContainer.unmount;
  }

  // execScripts 在沙箱中运行 默认在执行前 需要给global（假的window，子应用的window）扩展自定义的属性

  const {
    beforeUnmount = [],
    afterUnmount = [],
    afterMount = [],
    beforeMount = [],
    beforeLoad = [],
  } = mergeWith({}, getAddOns(global, assetPublicPath), lifeCycles, (v1, v2) => concat(v1 ?? [], v2 ?? []));

  await execHooksChain(toArray(beforeLoad), app, global);

  // get the lifecycle hooks from module exports
  // 根据指定的沙箱环境执行脚本
  const scriptExports: any = await execScripts(global, sandbox && !useLooseSandbox, {
    scopedGlobalVariables: speedySandbox ? cachedGlobals : [],
  });
  // 获取到应用导出的接入协议，可以使用了， 获取在window上最后增加的属性 之后拿到对应的脚本执行后拿到协议
  const { bootstrap, mount, unmount, update } = getLifecyclesFromExports(
    scriptExports,
    appName,
    global,
    sandboxContainer?.instance?.latestSetProp,
  );
  // qiankun3 中要被移除掉了
  const { onGlobalStateChange, setGlobalState, offGlobalStateChange }: Record<string, CallableFunction> =
    getMicroAppStateActions(appInstanceId);

  // FIXME temporary way
  const syncAppWrapperElement2Sandbox = (element: HTMLElement | null) => (initialAppWrapperElement = element);

  const parcelConfigGetter: ParcelConfigObjectGetter = (remountContainer = initialContainer) => {
    let appWrapperElement: HTMLElement | null;
    let appWrapperGetter: ReturnType<typeof getAppWrapperGetter>;

    const parcelConfig: ParcelConfigObject = {
      name: appInstanceId,
      bootstrap,
      mount: [
        async () => {
          if (process.env.NODE_ENV === 'development') {
            const marks = performanceGetEntriesByName(markName, 'mark');
            // mark length is zero means the app is remounting
            if (marks && !marks.length) {
              performanceMark(markName);
            }
          }
        },
        async () => {
          // 单例模式要卸载后才能挂载
          if ((await validateSingularMode(singular, app)) && prevAppUnmountedDeferred) {
            return prevAppUnmountedDeferred.promise;
          }

          return undefined;
        },
        // initial wrapper element before app mount/remount
        async () => {
          appWrapperElement = initialAppWrapperElement;
          appWrapperGetter = getAppWrapperGetter(
            appInstanceId,
            !!legacyRender,
            strictStyleIsolation,
            scopedCSS,
            () => appWrapperElement,
          );
        },
        // 添加 mount hook, 确保每次应用加载前容器 dom 结构已经设置完毕
        async () => {
          const useNewContainer = remountContainer !== initialContainer;
          if (useNewContainer || !appWrapperElement) {
            // element will be destroyed after unmounted, we need to recreate it if it not exist
            // or we try to remount into a new container
            appWrapperElement = createElement(appContent, strictStyleIsolation, scopedCSS, appInstanceId);
            syncAppWrapperElement2Sandbox(appWrapperElement);
          }

          render({ element: appWrapperElement, loading: true, container: remountContainer }, 'mounting');
        },
        mountSandbox, // 沙箱挂载后
        // exec the chain after rendering to keep the behavior with beforeLoad
        async () => execHooksChain(toArray(beforeMount), app, global),
        async (props) => mount({ ...props, container: appWrapperGetter(), setGlobalState, onGlobalStateChange }),
        // finish loading after app mounted
        async () => render({ element: appWrapperElement, loading: false, container: remountContainer }, 'mounted'),
        async () => execHooksChain(toArray(afterMount), app, global),
        // initialize the unmount defer after app mounted and resolve the defer after it unmounted
        async () => {
          if (await validateSingularMode(singular, app)) {
            prevAppUnmountedDeferred = new Deferred<void>();
          }
        },
        async () => {
          if (process.env.NODE_ENV === 'development') {
            const measureName = `[qiankun] App ${appInstanceId} Loading Consuming`;
            performanceMeasure(measureName, markName);
          }
        },
      ],
      unmount: [
        async () => execHooksChain(toArray(beforeUnmount), app, global),
        async (props) => unmount({ ...props, container: appWrapperGetter() }),
        unmountSandbox,
        async () => execHooksChain(toArray(afterUnmount), app, global),
        async () => {
          render({ element: null, loading: false, container: remountContainer }, 'unmounted');
          offGlobalStateChange(appInstanceId);
          // for gc
          appWrapperElement = null;
          syncAppWrapperElement2Sandbox(appWrapperElement);
        },
        async () => {
          if ((await validateSingularMode(singular, app)) && prevAppUnmountedDeferred) {
            prevAppUnmountedDeferred.resolve();
          }
        },
      ],
    };

    if (typeof update === 'function') {
      parcelConfig.update = update;
    }

    return parcelConfig;
  };

  return parcelConfigGetter;
}
流程总结:
1. 注册采用的是single-spa start()也是single-spa。
2. 预先加载的功能  -> 利用空闲时间进行加载其他应 requestIdleCallback。
3. 沙箱功能  css沙箱（创建一个sandbox 让你的execScript方法运行在sandbox） 样式隔离 (影子dom ， scopedcss)。
4. 获取导出的接入协议（在沙箱中执行的） 进行扩展（增加了用户提供的生命周期）。
2.qiankun 有哪些 问题？
微前端框架qiankun是基于single-spa的一种实现，专门用于解决微前端架构中的一些问题，比如应用间的隔离、通信、加载等。
1. 依赖复用的问题：
  ○ 创建共享模块，独立打包部署到CDN上，通过加载应用时传入，或者在子应用中引入。
  ○ 联邦模块：Webpack 5 引入的 Module Federation 可以帮助处理微前端环境下的依赖共享问题。它允许一个JavaScript应用动态地从另一个应用加载代码，而无需将其包含在构建中。
  ○ 两个应用之间加载资源的地址相同即可复用(http缓存)
2. 组件复用问题：
  ○ 将可复用的组件单独打包并在多个应用中引用，是解决组件复用问题的一种方法。这可以通过NPM包或者将组件部署到CDN上来实现。
3. Vite支持问题：
  ○ 目前，基于 Vite 构建的项目可能存在与 qiankun 的集成问题，因为 Vite 使用原生ES模块，而 qiankun 是umd规范需要转译过的代码。一种解决方案是在生产环境中接入 Vite，或者使用插件转换模块格式。
4. qiankun嵌套问题：
  ○ 在使用qiankun时，应避免多重沙箱嵌套。在子应用中关闭沙箱是一个解决方案，以确保应用之间的正确交互和隔离。
5. CSS沙箱问题：
  ○ strictStylelsolation完全隔离问题，样式无法传递到子应用中。
  ○ experimentalStylelsolation 子应用dom 结构插入到 body中，样式无法生效。
后续将移除 globalState、addGlobalUncaughtErrorHandler、shadowDOM样式隔离
方案。
八、MicroApp 使用（）

(https://micro-zoe.github.io/micro-app/)京东零售团队打造
1.按照上文qiankun 新建 三个项目 substrate(基座)m-vue(vue微应用)m-react(react微应用)
substrate应用中安装依赖
npm i @micro-zoe/micro-app --save
在基座substrate应用中引入 microApp 并 初始化启动
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import microApp from '@micro-zoe/micro-app'
microApp.start()

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
    <App />
);
2.嵌入子应用
新建 vue子应用组件
export default function Page2(){
    return <div>
        Vue项目
        <micro-app name='app1' url='http://localhost:8080/' baseroute='/vue'></micro-app>
    </div>
}
新建react子应用组件
export default function Page1(){
    return <div>
        React项目
        {/* 这个标签是通过webComponents 来实现的 */}
        <micro-app name='app1' 
        url='http://localhost:10000/' 
        baseroute='/react'
        
        ></micro-app>
    </div>
}
在substrate中引入路由绑定组件 src/app.js
import {BrowserRouter, Link, Routes,Route} from 'react-router-dom'
import Page1 from './page-1.js';
import Page2 from './page-2.js';
function App() {
  return (
    <div className="App">
        <BrowserRouter>
          <Link to="/react">React项目</Link>  
          <Link to="/vue">Vue项目</Link>  

          <Routes>
            <Route path="/react/*" element={<Page1/>}></Route>
            <Route path="/vue/*" element={<Page2/>}></Route>
          </Routes>
        </BrowserRouter>
    </div>
  );
}

export default App;

3.子应用改造
vue子应用：vue.config.js 跨域支持
const { defineConfig } = require('@vue/cli-service')
module.exports = defineConfig({
  transpileDependencies: true,
  devServer:{
    headers:{
      'Access-Control-Allow-Origin':'*'
    }
  }
})

vue子应用：router改造 注入 MicroApp变量 __MICRO_APP_BASE_ROUTE__
import { createRouter, createWebHistory } from 'vue-router'
import HomeView from '../views/HomeView.vue'

const routes = [
  {
    path: '/',
    name: 'home',
    component: HomeView
  },
  {
    path: '/about',
    name: 'about',
    // route level code-splitting
    // this generates a separate chunk (about.[hash].js) for this route
    // which is lazy-loaded when the route is visited.
    component: () => import(/* webpackChunkName: "about" */ '../views/AboutView.vue')
  }
]

const router = createRouter({
  history: createWebHistory(window.__MICRO_APP_BASE_ROUTE__?window.__MICRO_APP_BASE_ROUTE__:'/'),
  routes
})

export default router
react子应用改造：创建 public-path.js 在 index.js中引入
if (window.__MICRO_APP_ENVIRONMENT__) {
    // eslint-disable-next-line no-undef
    __webpack_public_path__ = window.__MICRO_APP_PUBLIC_PATH__
  }
4.扩展WebComponent MicroApp   基于WebComponent实现
WebComponent 是一种允许开发者创建可重用的自定义元素的 Web 标准，这些元素的功能完全封装，不受外部样式和脚本的影响。它基于以下四个主要技术：
1. 自定义元素（Custom Elements）：允许开发者定义自己的 HTML 标签。
2. Shadow DOM：用于封装元素的标记和样式，防止外部 CSS 影响内部样式。
3. HTML 模板（HTML Templates）：<template> 和 <slot> 标签用于声明性地定义元素的结构。
4. HTML 导入（HTML Imports）（已被废弃，现在更推荐使用 ES6 模块）：用于导入 HTML 文档。
5. 生命周期回调: connectedCallback、disconnectedCallback、adoptedCallback和attributeChangedCallback是Web Components的生命周期回调函数。例如，connectedCallback会在元素插入DOM时调用，类似于Vue的mounted。
6. 属性监听（observedAttributes）: static get observedAttributes()定义了需要监听的属性变化。在这个例子中，当type属性变化时，attributeChangedCallback会被调用。
7. 事件处理: 这段代码通过dispatchEvent触发自定义事件（如mounted1），并在元素上添加事件监听器来处理这些事件。
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!--
        1.custorm elements:允许用户自定义一个元素  随便起名字
        2.shadow DOM 样式隔离是webcomponent一部分
        3.可以支持组件的特点 模板 、 插槽、 生命周期 、 属性 都是组件的特点
     -->
    <my-button type="primary"></my-button>
    <!-- template是浏览器内容的，默认不会显示出来 -->
    <template id="btn">
        <button class="my-button"><slot>按钮</slot></button>
    </template>

    <button class="my-button"></button>

    <script>
        // 思想：iframe webcomponent  路由劫持 （通信） 隔离（js 隔离 css隔离）
        // 缺点是： 没有统一方案；

        // micro-app 核心是将你的应用 变成自定义元素，插入到基座中
        // webComponent兼容性不好 2010年就出现了，兼容性不好
        class MyButton extends HTMLElement{
            connectedCallback(){ // vue组件中的mounted
                // 元素挂载完成后，我们需要获取传入的属性，并且使用对应的模板来渲染
                this.shadow = this.attachShadow({mode:'open'})
                let btn =  document.getElementById('btn');// => 获取远程html
                const btnType = this.getAttribute('type') || 'default';
                this.types = {
                    'primary':{
                        background:'blue',
                    },
                    'default':{
                        background:'#a1a1a1'
                    }
                }
                let types = this.types
                let style = document.createElement('style')
                style.innerHTML =`
                    .my-button{
                        background:${types[btnType].background};
                        color:#fff;
                        padding:10px 20px
                    }
                `
                let tpl = btn.content.cloneNode(true);
                this.shadow.appendChild(style) // 样式隔离
                this.shadow.appendChild(tpl) // dom隔离
                this.dispatchEvent(new CustomEvent('mounted1')); // 自定义发射的事件
            }
            static get observedAttributes(){
                return ['type']
            }
            attributeChangedCallback(name,oldVal,newVal){
                if(this.shadow){
                   const btn =  this.shadow.querySelector('.my-button');
                   btn.style.background =  this.types[newVal].background;
                   this.dispatchEvent(new CustomEvent('update1'))
                }
            }
            disconnectedCallback(){
            } // 组件卸载触发
            adoptedCallback(){} // 移动到其他地方会触发
        }
        const customBtn = document.querySelector('my-button')
        customBtn.addEventListener('mounted1',function(){
            console.log('mounted')
        })
        customBtn.addEventListener('update1',function(){
            console.log('update')
        })
        window.customElements.define('my-button',MyButton);
        // customBtn.parentNode.removeChild(customBtn)
        
        // setTimeout(()=>{
        //     customBtn.setAttribute('type','default')
        // },1000)
    </script>
</body>
</html>
MicroApp源码分析
github clone micro-app-master
index.ts入口文件分析
export {
  default,
  MicroApp,
  getActiveApps,
  getAllApps,
  unmountApp,
  unmountAllApps,
} from './micro_app'
export {
  default as preFetch,
} from './prefetch'
export {
  removeDomScope,
  pureCreateElement,
  version,
} from './libs/utils'
export {
  EventCenterForMicroApp,
} from './interact'

// 1) 对于我们的micro-app 他里面的核心是创建一个webComponent组件
// 2) 获取html， 将模板放到 webComponent中
// 3) css 做作用域隔离   js 做proxy沙箱 （function (window){with(window){}}(proxyWindow)） new Function
// 4) 执行完毕后应用可以正常挂载

// qiankun 改造的子应用 mount / unmount, 让以前的qiankun项目也能接入进来
在micro_app.ts 中查看 MicroApp class
提供了一系列配置项，例如是否使用 Shadow DOM、是否禁用作用域 CSS、是否启用沙箱等。
export class MicroApp extends EventCenterForBaseApp implements MicroAppConfigType {
  tagName = 'micro-app'
  shadowDOM?: boolean
  destroy?: boolean
  inline?: boolean
  disableScopecss?: boolean
  disableSandbox?: boolean
  ssr?: boolean
  lifeCycles?: lifeCyclesType
  plugins?: plugins
  fetch?: fetchType
  preFetch = preFetch
  excludeAssetFilter?: (assetUrl: string) => boolean
  start (options?: OptionsType): void {
    // 是否支持webComponet, 不兼容低版本浏览器
    if (!isBrowser || !window.customElements) {
      return logError('micro-app is not supported in this environment')
    }

    if (options?.tagName) { //  自定义元素的名字
      if (/^micro-app(-\S+)?/.test(options.tagName)) {
        this.tagName = options.tagName
      } else {
        return logError(`${options.tagName} is invalid tagName`)
      }
    }

    if (window.customElements.get(this.tagName)) {
      return logWarn(`element ${this.tagName} is already defined`)
    }
    // 全局的初始化 globalEnv
    initGlobalEnv()

    if (options && isPlainObject(options)) {
      // 用户参数处理的 disableScopecss:false  disableSandbox:false
      this.shadowDOM = options.shadowDOM
      this.destroy = options.destroy
      /**
       * compatible with versions below 0.4.2 of destroy
       * do not merge with the previous line
       */
      // @ts-ignore
      this.destory = options.destory
      this.inline = options.inline
      this.disableScopecss = options.disableScopecss
      this.disableSandbox = options.disableSandbox
      this.ssr = options.ssr
      isFunction(options.fetch) && (this.fetch = options.fetch)

      isPlainObject(options.lifeCycles) && (this.lifeCycles = options.lifeCycles)

      // load app assets when browser is idle
      options.preFetchApps && preFetch(options.preFetchApps)

      // load global assets when browser is idle
      options.globalAssets && getGlobalAssets(options.globalAssets)

      isFunction(options.excludeAssetFilter) && (this.excludeAssetFilter = options.excludeAssetFilter)

      if (isPlainObject(options.plugins)) {
        const modules = options.plugins!.modules
        if (isPlainObject(modules)) {
          for (const appName in modules) {
            const formattedAppName = formatAppName(appName)
            if (formattedAppName && appName !== formattedAppName) {
              modules[formattedAppName] = modules[appName]
              delete modules[appName]
            }
          }
        }

        this.plugins = options.plugins
      }
    }

    // define customElement after init
    // WebComponent 来自定义标签
    defineElement(this.tagName)
  }
}
initGlobalEnv()方法中在全局的初始化 globalEnv。
1. 全局声明：这段代码扩展了 Window、Node 和 HTMLStyleElement 接口的类型声明，为这些类型添加了微前端相关的属性。
2. globalEnv 对象：这是一个用于存储全局变量和原生方法引用的对象。
3. initGlobalEnv 函数：这个函数是用于初始化全局环境的关键函数。当在浏览器环境中运行时，它会捕获并存储许多原生 DOM 方法和 Window 方法的引用，这些方法后续将用于微应用的沙箱实现和生命周期管理。
  ○ 捕获 DOM 方法，如 setAttribute、appendChild 等。
  ○ 捕获 Document 的创建元素和查询元素的方法。
  ○ 创建 ImageProxy，这是一个代理，用于在创建 Image 实例时添加微应用的名称作为标识。
  ○ 捕获 Window 和 Document 的事件监听方法和定时器方法。
4. 标记基础应用：通过在 window 对象上设置 __MICRO_APP_BASE_APPLICATION__ 标记当前应用为基础应用。
5. 全局效果处理：
  ○ rejectMicroAppStyle：可能用于拒绝或处理微应用的样式。
  ○ releaseUnmountOfNestedApp 和 listenUmountOfNestedApp：这两个方法可能用于处理嵌套微应用的卸载监听。
代码通过捕获和代理原生方法，建立了一套机制来管理微应用的生命周期和沙箱环境。这对于微前端框架能够在不同应用之间提供隔离、控制和通信是非常关键的
MicroApp 微前端框架的关键特性和实现方式可以归纳如下：
1. WebComponent 组件创建：MicroApp 的核心在于创建一个 WebComponent 组件。WebComponents 是一种浏览器标准，允许开发者创建自定义、封装的 HTML 标签。在微前端架构中，使用 WebComponents 可以有效地将不同的微应用隔离开来，每个微应用都作为一个自定义元素存在，从而实现界面和逻辑的封装和隔离。
2. HTML 模板处理：微应用的 HTML 内容被获取后，会被放置到对应的 WebComponent 中。这意味着每个微应用都有自己的 DOM 结构和作用域，与其他微应用相互独立。
3. CSS 作用域隔离：为了避免样式冲突，MicroApp 对 CSS 进行作用域隔离。这通常通过 CSS Scoping 实现，确保每个微应用的样式只在其自身的 DOM 内部生效，不会影响到其他微应用或主应用。
4. JavaScript 沙箱环境：JavaScript 代码在一个 Proxy 沙箱环境中执行，常见的实现方式是通过 new Function 或 with 语句来创建一个隔离的上下文。这个沙箱环境提供了一个假的全局对象（通常是 proxy 化的 window 对象），确保微应用的 JavaScript 代码运行在一个隔离和受控的环境中，防止相互干扰。
5. 应用挂载与卸载：微应用在执行完毕后可以正常挂载到指定的容器中。此外，MicroApp 还兼容了 qiankun 微前端框架改造的子应用的挂载（mount）和卸载（unmount）机制。这意味着原本基于 qiankun 构建的项目也能够无缝接入到 MicroApp 框架中，增强了框架的兼容性和灵活性。
九、wujie的实现和使用
1.wujie简易实现
简易版本的无界 采用 webcomponent + iframe 的沙箱模式
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div>基座的代码，不被子应用的样式所污染</div>

    <!-- 加载子应用的div -->
    <div id="container"></div>
    <!-- 
        以前我们的js都是放到沙箱（自己实现的）中跑的  -> iframe
        我们的css隔离 （scopedCSS） -> webComponent(shadowRoot)
        渲染采用webComponent （拉取html模板 生成自定义组件插入到指定的dom种）
     -->

     <script>
        const strTmpWithCSS = `
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Document</title>
        </head>
        <body>
            <div id="inner">hello jw</div>
            <style>
                div{background:red;color:#fff}
             </style>
        </body>
        </html>
        `
        const strScript = `
            window.a = 100; // 此属性不会影响父应用
            console.log(window.a); // 100
            const ele = document.querySelector('#inner')
            console.log(ele);
        `

        function createIframe(){
            const iframe = document.createElement('iframe');
            iframe.src = 'about:blank'
            document.body.appendChild(iframe);
            return iframe
        }

        function createSandbox(){
            const sandbox = {
                iframe:createIframe(), // 创建了一个iframe沙箱
                shadowRoot:null
            }
            return sandbox
        }
        function injectTemplate(sandbox,template){
            const wrapper =  document.createElement('div');
            wrapper.innerHTML = template;
            sandbox.shadowRoot.appendChild(wrapper)
        }
        
        function runScirptInSandbox(sandbox,script){
            const iframeWindow = sandbox.iframe.contentWindow;
            const scriptElement = iframeWindow.document.createElement('script');

            // 获取head 将script插入进去
            const headElement = iframeWindow.document.querySelector('head');


            // 我们希望在脚本执行之前，有些方法用的是父应用的
            // document.querySelector 应该用的不是iframe中的 -》 shadowRoot 去弄
            // 添加弹框的时候 document.createElement().appendChild() -> 代理到全局的window上去

            // iframe中的路由管理  history.pushState -> 将一些常用方法进行同步到主应用
            // ......
            Object.defineProperty(iframeWindow.Document.prototype, 'querySelector',{
                get(){
                   // 加载的脚本内部调用了querySelector
                   // document.querySeletor('abc')  -> sandbox.shadowRoot['querySelector']
                   return new Proxy(sandbox.shadowRoot['querySelector'],{
                        apply(target,thisArgs,args){
                            return thisArgs.querySelector.apply(sandbox.shadowRoot,args)
                        }
                   })
                }
            })
            scriptElement.textContent = script;
            headElement.appendChild(scriptElement)
        }
        function createCustomElement(){
            class WujieApp extends HTMLElement{
                connectedCallback(){
                    // 1)创建沙箱
                    const sandbox = createSandbox();
                    // 2)创建shadowdDOM
                    sandbox.shadowRoot = this.attachShadow({mode:'open'})
                    // 3)将html、css放入到shadowdDOM
                    injectTemplate(sandbox,strTmpWithCSS)
                    // 4)将js放入沙箱执行
                    runScirptInSandbox(sandbox,strScript)
                }
            }
            window.customElements.define('wujie-app',WujieApp);
            container.appendChild(document.createElement('wujie-app'))
        }
        // 定义一个组件来使用
        createCustomElement()
     </script>
</body>
</html>
2.无界的使用:
首先 通过 脚手架 建立 base(react基座)  m-vue m-react 子应用
在base/src/app.js 创建路由链接 引入 子应用 Page1.js Page2.js

import { BrowserRouter, Routes, Route, Link } from 'react-router-dom'
import Page1 from './Page1.js';
import Page2 from './Page2.js';
function App() {
  return (
    <div className="App">
      <BrowserRouter>
        <Link to="/react">React应用</Link>
        <Link to="/vue">vue应用</Link>

        <Routes>
          <Route path="/react" element={<Page1></Page1>}></Route>
          <Route path="/vue" element={<Page2></Page2>}></Route>
        </Routes>
      </BrowserRouter>
    </div>
  );
}

export default App;

首先我们在 src/components/下封装wujie-react.js组件
import {useRef,useEffect} from 'react'
import {startApp,destroyApp} from 'wujie'

export default function WujieReact(props){
    const myRef = useRef(null);
    let destroy = null;
    const startAppFunc = async()=>{
        destroy = await startApp({
            ...props,
            el:myRef.current
        })
    }
    useEffect(()=>{
        startAppFunc();
        return () =>{
            if(destroy){
                destroyApp(destroy)
            }
        }
    })
    const {width,height} = props
    return <div style={{width,height}} ref={myRef}></div>
}
参考官网:如果主应用是vue框架可直接使用 wujie-vue，react框架可直接使用 wujie-react
startApp setupApp
Page1.js
import WujieReact from "wujie-react";

export default function Page1(){

    return <WujieReact 
        name='ReactApp' 
        url="http://localhost:3001"
        width="100%"
        height="100%"
    ></WujieReact>
}
Page2.js
import WujieReact from "wujie-react";
export default function Page2(){
    return <WujieReact 
    name='VueApp' 
    url="http://localhost:8080"
    width="100%"
    height="100%"
    sync={true}
></WujieReact>
}
m-vue子应用 加上 webpack跨域改造
const { defineConfig } = require('@vue/cli-service')
module.exports = defineConfig({
  transpileDependencies: true,
  devServer:{
    headers:{
      'Access-Control-Allow-Origin':'*'
    }
  }
})
十、Webpack5模块联邦与微前端EMP2实践
1.基础知识
1.1 EMP
● emp2是一个用于构建企业级微前端应用的框架。它允许您将大型前端应用程序分解为独立的、可独立开发、部署和维护的模块。这种模块化方法提高了可维护性和可扩展性，同时降低了开发复杂性
1.2 Module Federation
1.2.1 动机
● Module Federation的动机是为了不同开发小组间共同开发一个或者多个应用
● 应用将被划分为更小的应用块，一个应用块，可以是比如头部导航或者侧边栏的前端组件，也可以是数据获取逻辑的逻辑组件
● 每个应用块由不同的组开发
● 应用或应用块共享其他其他应用块或者库

1.2.2 概念
● 使用Module Federation时，每个应用块都是一个独立的构建，这些构建都将编译为容器
● 容器可以被其他应用或者其他容器引用
● 一个被引用的容器被称为remote, 引用者被称为host，remote暴露模块给host, host则可以使用这些暴露的模块，这些模块被成为remote模块

1.2.3 配置参数
字段	类型	含义
name	string	必传值，即输出的模块名，被远程引用时路径为${name}/${expose}
filename	string	指定导出的 remoteEntry 文件的名称。这个文件包含了模块联邦的运行时和引导代码
remotes	object	定义其他应用程序的引用映射。这个参数是一个对象，键是别名，值是远程应用的 URL。当我们想在当前应用中引用其他应用的模块时，可以使用这个别名
exposes	object	定义当前应用要暴露给其他应用的模块。这个参数是一个对象，键是别名，值是模块的相对路径。别名将用于其他应用在引用该模块时
shared	object	定义哪些模块应该在应用程序之间共享。这个参数可以是一个数组，包含共享模块的名称，或者是一个对象，包含共享模块的名称及其配置选项。共享模块可以避免重复加载，从而减少应用的体积和加载时间
1.3 webpack-chain
● webpack-chain是一个用于创建和修改 Webpack 配置的 Node.js 库。它提供了一种直观的链式 API，允许您以可读的方式构建复杂的 Webpack 配置 这个库的主要目的是让您可以通过链式方法调用轻松地对 Webpack 配置进行更改，而无需直接操作配置对象。这使得配置更加可读和易于维护。以下是 webpack-chain 的一些主要特性
  ○ 链式 API：webpack-chain 使用了流行的链式 API 设计模式，允许您通过链式方法调用轻松地修改 Webpack 配置。这种设计模式提高了代码的可读性和维护性
  ○ 命名规则和插件：您可以为规则和插件分配名称，稍后可以轻松地修改它们。这可以帮助您组织和管理配置中的各个部分

1.3.1 use.js
// 导入 'webpack-chain' 模块，它是一个构造函数，用于创建配置 API
const Config = require('./webpack-chain');
// 实例化一个新的配置 API 对象
const config = new Config();
// 使用链式 API 修改配置
config
  // 添加一个入口点
  .entry('index')
  // 为入口点添加文件路径
  .add('src/index.js')
  // 结束对当前入口点的操作并返回 config 实例
  .end()
  // 修改输出设置
  .output
  // 设置输出目录
  .path('dist')
  // 设置输出文件名
  .filename('[name].bundle.js');
// 将配置转换为 webpack 可以使用的配置对象
const options = config.toConfig();
// 打印配置对象
console.log(options);

/**
{
  entry: { index: [ 'src/index.js' ] },
  output: { path: 'dist', filename: '[name].bundle.js' }
}
 */
1.3.2 webpack-chain\index.js
chain\webpack-chain\index.js
const ChainedMap = require('./ChainedMap');
const ChainedSet = require('./ChainedSet');
const Output = require('./Output');
class Config extends ChainedMap {
  constructor(parent) {
    super(parent);
    this.entryPoints = new ChainedMap(this);
    this.output = new Output(this);
  }
  entry(name) {
    return this.entryPoints.getOrCompute(name, () => new ChainedSet(this));
  }
  toConfig() {
    const entryPoints = this.entryPoints.entries();
    return {
      entry: Object.keys(entryPoints).reduce(
        (acc, key) =>
          Object.assign(acc, { [key]: entryPoints[key].values() }),
        {},
      ),
      output: this.output.entries()
    }
  }
}
module.exports = Config;
1.3.3 ChainedMap.js
chain\webpack-chain\ChainedMap.js
const Chainable = require('./Chainable');
class ChainedMap extends Chainable {
  constructor(parent) {
    super(parent);
    this.store = new Map();
  }
  extend(methods) {
    this.shorthands = methods;
    methods.forEach((method) => {
      this[method] = (value) => this.set(method, value);
    });
    return this;
  }
  getOrCompute(key, fn) {
    if (!this.has(key)) {
      this.set(key, fn());
    }
    return this.get(key);
  }
  has(key) {
    return this.store.has(key);
  }
  set(key, value) {
    this.store.set(key, value);
    return this;
  }
  get(key) {
    return this.store.get(key);
  }
  entries() {
    const entries = [...this.store].reduce((acc, [key, value]) => {
      acc[key] = value;
      return acc;
    }, {});
    return entries;
  }
}
module.exports = ChainedMap
1.3.4 ChainedSet.js
chain\webpack-chain\ChainedSet.js
const Chainable = require('./Chainable');
class ChainedSet extends Chainable {
  constructor(parent) {
    super(parent);
    this.store = new Set();
  }
  add(value) {
    this.store.add(value);
    return this;
  }
  values() {
    return [...this.store];
  }
}
module.exports = ChainedSet;
1.3.5 Chainable.js
chain\webpack-chain\Chainable.js
class Chainable {
  constructor(parent) {
    this.parent = parent;
  }
  end() {
    return this.parent;
  }
};
module.exports = Chainable;
1.3.6 Output.js
chain\webpack-chain\Output.js
const ChainedMap = require('./ChainedMap');
module.exports = class extends ChainedMap {
  constructor(parent) {
    super(parent);
    this.extend([
      'path',
      'filename'
    ]);
  }
};
1.4 其它工具
● @babel/core: Babel的核心编译器，用于将ES6+代码转换为向后兼容的JavaScript版本
● @babel/preset-env: Babel预设，根据目标环境自动确定需要的Babel插件和polyfills
● @babel/preset-react: Babel预设，用于转换React JSX语法为普通的JavaScript
● babel-loader: Webpack加载器，允许使用Babel和Webpack一起转换JavaScript文件
● commander: 一个功能强大的命令行界面库，用于创建Node.js命令行应用
● fs-extra: 一个扩展了Node.js内置fs模块的库，提供额外的文件系统相关功能
● git-promise: 一个用于在Node.js中处理Git命令的简单Promise封装库
● html-webpack-plugin: 一个Webpack插件，用于简化HTML文件的创建，以便为你的bundle提供服务
● inquirer: 一个交互式命令行用户界面的集合，用于在Node.js中创建自定义的命令行界面
● nanospinner: 一个轻量级的命令行spinner库，用于在命令行中显示加载进度
● webpack: 一个用于现代JavaScript应用程序的静态模块打包工具
● webpack-chain: 一个流畅的API，用于编程地配置Webpack
● webpack-cli: Webpack的命令行工具，用于在命令行中运行Webpack
● webpack-dev-server: 一个开发服务器，使用热模块替换（HMR）提供实时重新加载功能
● axios: 一个基于Promise的HTTP客户端库，用于浏览器和Node.js中进行AJAX请求
2.EMP2启动
npm i -g @efox/emp
emp init -d https://static.zhufengpeixun.com/template_1680930323773.json
emp dev
3.实现init
3.1 安装依赖
npm install @babel/core @babel/preset-env @babel/preset-react babel-loader commander fs-extra git-promise html-webpack-plugin inquirer nanospinner webpack webpack-chain webpack-cli webpack-dev-server axios --save
3.2 package.json
package.json
{
    "bin": {
        "zmp6": "./bin/zmp6.js"
    }
}
3.3 bin\zmp6.js
bin\zmp6.js
// 声明一个 Node.js 脚本，并指定使用的解释器
#!/usr/bin/env node
// 引入 commander 库，用于处理命令行参数和选项
const program = require('commander');
// 引入 package.json 文件，以获取版本号等信息
const pkg = require('../package.json');
// 引入自定义的 CLI 模块
const cli = require('../cli');
// 设置版本号，并添加一个用于显示版本号的选项
program.version(pkg.version, '-v, --version').usage('<command> [options]');
// 添加 init 命令，用于初始化项目
program.command('init')
  .description('初始化项目')
  .option('-d, --data [data]', 'JSON数据 http地址或者文件路径相对、绝对路径')
  .action((options) => {
    cli.exec('init', options);
  });
// 添加 dev 命令，用于启动开发服务器
program.command('dev')
  .description('Dev Server')
  .action(async (options) => {
    console.log('dev', options);
  });
// 解析命令行参数
program.parse(process.argv);
3.4 cli\index.js
cli\index.js
// 定义一个名为 ZMPScript 的类
class ZMPScript {
  // 定义一个名为 exec 的异步方法，接受两个参数：name 和 options
  async exec(name, options) {
    // 使用 require 动态加载指定名称的模块（文件），并调用其 setup 方法，传递 options 参数
    await require(`./${name}`).setup(options);
  }
}
// 创建一个 ZMPScript 类的实例，并导出该实例
module.exports = new ZMPScript();
3.5 cli\init.js
cli\init.js
// 导入依赖模块
const { createSpinner } = require('nanospinner');
const git = require('git-promise');
const fs = require('fs-extra');
const path = require('path');
const axios = require('axios');

// 定义项目模板的URL
const templates = {
  'remote': `https://gitee.com/zhufengpeixun/remote.git`,
  'host': `https://gitee.com/zhufengpeixun/host.git`,
};

// 定义 Init 类
class Init {
  templates = templates
  // 检查传入的URL是否是HTTP地址，并返回数据
  async checkData(url) {
    if (/^http(s)?:\/\/.+/.test(url)) {
      const { data } = await axios.get(url);
      return data;
    } else {
      const filepath = path.join(process.cwd(), url);
      this.templates = require(filepath);
    }
  }
  // 设置模板
  async setup(options) {
    if (typeof options.data === 'string') {
      const data = await this.checkData(options.data);
      if (data) {
        this.templates = data;
      }
    }
    await this.selectTemplate();
  }
  // 选择模板
  async selectTemplate() {
    const inquirer = await (await import('inquirer')).default;
    let answers = await inquirer.prompt([{
      type: 'input',
      name: 'name',
      message: '请输入项目名:',
      default: function () {
        return 'zmp-project';
      }
    }, {
      type: 'list',
      name: 'template',
      message: '请选择模板:',
      choices: Object.keys(this.templates)
    }]);
    let downLoadUrl = this.templates[answers.template];
    const downLoadName = answers.name;
    await this.downloadRepo(downLoadUrl, downLoadName);
  }
  // 下载仓库
  async downloadRepo(repoPath, localPath) {
    const spinner = createSpinner().start();
    spinner.start({ text: `[downloading]\n` });
    await git(`clone ${repoPath} ./${localPath}`);
    fs.removeSync(`./${localPath}/.git`);
    spinner.success({
      text: ` cd ${localPath} && npm i && npm run dev`
    });
  }
}
// 导出 Init 类的实例
module.exports = new Init();
4.实现dev
4.1 bin\zmp6.js
bin\zmp6.js
#!/usr/bin/env node
const program = require('commander');
const pkg = require('../package.json');
const cli = require('../cli');
program.version(pkg.version, '-v, --version').usage('<command> [options]');
program.command('init')
  .description('初始化项目')
  .option('-d, --data [data]', 'JSON数据 http地址或者文件路径相对、绝对路径')
  .action((options) => {
    cli.exec('init', options);
  });
program.command('dev')
  .description('Dev Server')
  .action(async (options) => {
    +        cli.exec('dev',options);
  });
program.parse(process.argv);
4.2 cli\dev.js
cli\dev.js
// 引入 webpack-dev-server 模块
const WebpackDevServer = require('webpack-dev-server'); 
// 引入 webpack 模块
const webpack = require('webpack'); 
// 引入 getConfig 方法，用于获取 webpack 配置
const { getConfig } = require('../config');
class devServer {
  // 定义异步的 setup 方法
  async setup() { 
    // 调用 setServer 方法来设置服务器
    await this.setServer();
  }
  // 定义异步的 setServer 方法
  async setServer() { 
    // 通过 getConfig 方法获取 webpack 配置
    const config = getConfig(); 
    // 使用 webpack 函数创建一个编译器实例
    const compiler = webpack(config); 
    // 创建一个新的 webpack-dev-server 实例，传入 devServer 配置和编译器实例
    this.server = new WebpackDevServer(config.devServer, compiler); 
    // 启动 webpack-dev-server
    this.server.start(); 
  }
}
// 导出 devServer 类的一个实例
module.exports = new devServer();
4.3 config\index.js
config\index.js
// 引入 path、webpack 和 WebpackChain 模块
const path = require('path');
const webpack = require('webpack');
const WebpackChain = require('webpack-chain');
// 导出 defineConfig 函数，接收一个配置对象并返回它
exports.defineConfig = (config) => {
  return config;
}
// 导出 getConfig 函数，返回经过处理后的 webpack 配置对象
exports.getConfig = () => {
  // 创建一个 webpack-chain 实例
  const webpackChain = new WebpackChain();
  // 解析 emp-config.js 配置文件，并获取其导出值
  const configPath = path.resolve(process.cwd(), 'emp-config.js');
  const configExport = require(configPath);
  // 对默认配置进行处理，如将 server 属性提取到 devServer 属性中
  const config = processDefault(configExport);
  // 将处理后的配置与 webpack-chain 实例合并
  webpackChain.merge(config);
  // 将合并后的 webpack-chain 实例转换成 webpack 配置对象并返回
  return webpackChain.toConfig();
}
// 处理默认配置的函数，返回处理后的配置对象
function processDefault(configExport) {
  // 将 server 属性提取到 devServer 属性中
  const devServer = configExport.server || {};
  delete configExport.server;
  // 将 empShare 属性的值作为 mfOptions 的一部分，并将 empShare 属性删除
  const mfOptions = {
    filename: "emp.js",
    ...configExport.empShare
  }
  delete configExport.empShare;
  // 返回处理后的配置对象
  return {
    context: process.cwd(),
    mode: 'development',
    devtool: false,
    devServer,
    plugin: {
      html: {
        plugin: require('html-webpack-plugin'),
        args: [{
          template: path.join(__dirname, '../template/index.html')
        }]
      },
      mf: {
        plugin: webpack.container.ModuleFederationPlugin,
        args: [mfOptions]
      }
    },
    module: {
      rule: {
        compile: {
          test: /\.js$/,
          exclude: [/node_modules/],
          use: {
            'babel-loader': {
              loader: require.resolve('babel-loader'),
              options: {
                presets: [
                  require.resolve('@babel/preset-env'),
                  require.resolve('@babel/preset-react')
                ]
              }
            }
          }
        }
      }
    },
    ...configExport,
  }
}
4.4 template\index.html
template\index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
  </head>
  <body>
    <div id="emp-root"></div>
  </body>
</html>xxxxxxxxxx <!-- template/index.html --><!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title></title>  </head>  <body>    <div id="emp-root"></div>  </body></html>html
```
