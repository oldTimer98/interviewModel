## 是什么

参考服务端微服务架构模式，将单体应用拆解成若干个小、简单、逻辑内聚的子应用，之后再通过技术手段将他们聚合成单个应用的架构风格

![img](https://cdn.nlark.com/yuque/0/2022/png/26698409/1665832253443-09c25aad-ebc3-44da-a432-69ad59c2a4e4.png) 

## 为什么

因为大！现代 SPA 应用体积越来越大(巨石单体应用)，在一些复杂业务场景中甚至会出现上百人维护同一个项目的情况，这会带来很多问题：

- 应用越大，通常逻辑越复杂，开发维护成本越高
- 技术栈固化，好处是统一，缺点是不再有适应性
- 团队协作成本高
- 优点：

- 每一个子应用可以独立开发、测试、部署，甚至可以有自己的技术栈，能有效解耦各团队协作流程

- 技术方案：

- iframe 嵌套
- url 互跳
- js 动态加载、执行

## 实现

### 方案：MPA，对，这本质上也是一种微前端

- 将系统分为多个**仓库**维护，在首页或各个页面的导航栏提供统一的导航组件，兼容不同页面互跳
- 优点：简单
- 缺点：

- 只能以页面维度拆分，无法拆分至区块部分(组件化？)。
- 需要在不同页面间跳转，每次跳转浏览器需要完整走一遍 url 到渲染出内容的过程，无法达到 SPA 的顺畅度
- 不同应用自闭环所有数据管理逻辑，可能出现重复加载数据的情况
- 不同应用间通讯成本极高(主要依赖 url 带参数)

### 方案：构建阶段静态组合

- NPM 方案：**子应用构建为独立 npm 包**(独立仓库 or monorepo)，在主应用中引入并运行

- 子应用各自闭环，各自构建
- 升级维护麻烦，需要子应用更新包版本，主应用修改后重新发布
- 子应用间公用依赖包重复引入！！！

- webpack 模块联邦：可以将部分内容构建为独立的产物包，之后在不同地方使用

![img](https://cdn.nlark.com/yuque/0/2022/png/26698409/1665825814753-ae356362-fc1f-47f1-a68e-26a5b133ab02.png)

- 方案整体比较优雅，且能解决公共依赖问题；
- 但是：

- 新特性，不确定稳定性，不过我见过不少实现效果很不错的例子
- 本质上只是在浏览器端实现了远程模块加载与运行的能力，不具备环境隔离能力(相关实践：[EMP](https://emp2.netlify.app/))

### 方案：运行时动态组合

- iframe：主应用不同部位嵌入不同 iframe 标签，实现较丝滑的用户体验

- 优点：

- 天然提供了内容隔离能力
- 天然支持不同框架运行在统一应用中的效果

- 缺点：

- 隔离性强，无法突破，应用间无法共享内存状态，只能通过 postMessage 接口实现通讯
- 每一个 iframe 都需要走完整的加载渲染流程，形成事实上的孤岛效果
- 应用之间无法共享基础设施代码
- iframe 不支持 url 前进后退，会导致状态丢失

- js(基座应用) 动态加载并执行子应用(qiankun、无界等)

- qiankun：

- 预先注册子应用(激活路由、子应用资源、生命周期函数)
- 监听路由的变化，匹配到了激活的路由则加载子应用资源，顺序调用生命周期函数并最终渲染到容器
- 缺点：

- 基于路由匹配，无法同时激活多个子应用，也不支持子应用保活
- 改造成本较大，从 webpack、代码、路由等等都要做一系列的适配

- 无界：

- 运行时动态加载子应用资源
- 在主应用中创建一个shadowdom节点和一个iframe
- 将js注入iframe内运行，将dom、css放到shadowdom节点下。同时劫持js中的dom操作并指向shadowdom。

- 。。。

## 难点

- 样式隔离：构建时加前缀、域隔离(例如 `#app-1 xxx`)、webcomponent、iframe 等
- js 沙箱：iframe、proxy、快照、ShadowRealm API 等
- 通讯：子应用之间，主应用子应用自荐通讯与状态共享
- 路由劫持：劫持 [window.history](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FHistory) 的 [pushState](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FHistory%2FpushState) 和 [replaceState](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FHistory%2FreplaceState) 方法，以及监听 popstate 和 hashChange 事件，并根据当前 URL 动态渲染匹配成功的微应用。



资料：

- https://webpack.docschina.org/concepts/module-federation
- https://emp2.netlify.app/
- https://juejin.cn/post/6885212507837825038
- https://wujie-micro.github.io/doc/guide/
- https://juejin.cn/post/7125646119727529992
- [https://juejin.cn/post/7093740002311405581](https://juejin.cn/post/7093740002311405581#heading-2)