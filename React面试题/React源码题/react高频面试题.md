react为什么需要合成事件
点题收敛
React需要合成事件（SyntheticEvent）是为了解决浏览器兼容性问题，提供了一种跨浏览器的事件处理机制。在React中，合成事件是在浏览器原生事件（native event）的基础上构建的，提供了与原生事件相似的API和属性。


详细回答
React的合成事件具有以下特点：
跨浏览器兼容性：React合成事件能够屏蔽不同浏览器之间的事件差异，使得开发者可以编写统一的事件处理代码，而不需要考虑浏览器兼容性问题。
性能优化：React使用了事件池（event pooling）的技术，通过复用事件对象来减少内存分配和垃圾回收的开销，从而提高性能。
合成嵌套：React合成事件支持事件冒泡和捕获，可以在一个组件中注册多个事件处理函数，避免了事件处理函数之间的相互影响。
支持事件委托：React合成事件支持事件委托，可以在父组件中注册事件处理函数，处理子组件的事件。

总结收敛
总之，React合成事件是为了提供一种跨浏览器的事件处理机制，同时也为了提高性能和扩展事件处理的功能。

拓展理解和原生事件
在 React 中，合成事件（SyntheticEvent）是一种封装了浏览器原生事件的事件系统，提供了一种跨浏览器的事件处理机制，与原生事件有以下区别：
原生事件是浏览器原生实现的事件，而合成事件是 React 内部实现的事件，通过对原生事件的封装实现的。
在 React 中，合成事件是经过优化的事件处理机制，相比原生事件，合成事件更轻量、更快速、更节省资源，因为合成事件使用了事件池来减少内存分配和垃圾回收的开销。
在 React 中，合成事件是跨浏览器兼容的。不同浏览器对事件的处理有差异，而合成事件通过屏蔽这些差异，提供了一种跨浏览器的事件处理机制。
合成事件是可合成的。合成事件可以合并多个事件成为一个事件进行处理，从而提高了性能。
在 React 中，合成事件支持事件池、事件委托、事件冒泡和捕获等功能。
总之，React 合成事件是为了提供一种跨浏览器的事件处理机制，同时还提供了更快速、更节省资源的事件处理方式，从而提高了 React 应用的性能和可扩展性。

react fiber的特点
点题收敛
React Fiber 是 React 的一种新的协调引擎，它具有改进协调算法、支持增量渲染、可中断和恢复、支持并发模式、向后兼容和支持错误边界等特点，从而提高了 React 应用的性能、可扩展性和健壮性。

详细回答
React Fiber 是 React 的一种新的协调引擎，它的特点包括：
改进了协调算法：React Fiber 使用的是基于优先级的协调算法，将任务分解为多个小任务，并根据任务的优先级来调度任务的执行，从而提高了应用的性能。
支持增量渲染：React Fiber 支持增量渲染，即在处理任务时可以中断任务，并优先处理更高优先级的任务，从而使得用户能够更快地看到页面的变化。
可中断和恢复：React Fiber 允许开发者在组件渲染的过程中对任务进行中断和恢复，从而支持更细粒度的控制，提高了应用的性能和响应速度。
支持并发模式：React Fiber 的设计是支持并发模式的，可以在多个线程中同时执行任务，从而提高了应用的性能。
向后兼容：React Fiber 的设计是向后兼容的，可以在不影响旧的应用的情况下逐步升级到新的版本，从而使得 React 应用的升级变得更加容易。
支持错误边界：React Fiber 支持错误边界机制，当组件发生错误时，可以通过错误边界机制来捕获错误并展示友好的错误信息，从而提高了应用的健壮性和用户体验。

react fiber的执行流程
点题收敛
总之，React Fiber 的执行流程包括初始化阶段、任务调度阶段、协调阶段（Reconciliation 和 Commit）、完成阶段等，通过优先级调度器、协调算法、diff 算法等来提高 React 应用的性能和响应速度。

详细回答
React Fiber 是 React 的一种新的协调引擎，其执行流程如下：
初始化阶段：React Fiber 通过调用 render() 方法来生成虚拟 DOM 树，并将其存储在 Fiber 节点中。在这个阶段，React Fiber 还会创建一些全局变量，如 workInProgressRoot、nextUnitOfWork 等，用于记录当前的工作进度和任务单元。
任务调度阶段：React Fiber 通过优先级调度器（Priority Scheduler）来决定当前要执行的任务单元。每个任务单元都是一个 Fiber 节点，记录了该任务的类型、状态、子节点等信息。React Fiber 将任务单元按照优先级分为多个批次（Batch），每个批次包含一组任务单元。React Fiber 首先会执行高优先级的批次，然后执行低优先级的批次。
协调阶段：在每个任务单元执行前，React Fiber 会检查该任务单元是否需要更新。如果需要更新，则会进入协调阶段，根据当前节点和子节点的状态来决定该任务单元的执行方式。协调阶段分为两个步骤：Reconciliation 和 Commit。
Reconciliation 阶段：React Fiber 通过遍历 Fiber 树来比较新旧虚拟 DOM 的差异，找出需要更新的节点，并标记这些节点为“脏节点”。React Fiber 通过 diff 算法来比较新旧虚拟 DOM 的差异，尽可能地重用已有的节点，从而减少 DOM 操作的次数。
Commit 阶段：在 Reconciliation 阶段完成后，React Fiber 会进入 Commit 阶段，将所有“脏节点”更新到真实的 DOM 上。在 Commit 阶段，React Fiber 会调用各个生命周期方法，如 componentDidMount、componentDidUpdate 等，以完成组件的更新和挂载。
完成阶段：在 Commit 阶段完成后，React Fiber 将当前的工作进度标记为完成，并将结果返回给调用者。如果还有未完成的任务单元，React Fiber 会继续执行任务调度和协调阶段，直到所有任务都完成。

React.memo和 useMemo的区别
点题收敛
React.memo和 useMemo 都是 React 中用于性能优化的方法，但它们的应用场景和作用不同。

详细回答
React.memo 是一个高阶组件，用于优化函数组件的渲染性能。它会对组件的 props 进行浅层比较（shallow comparison），如果新旧 props 相同，则跳过重新渲染组件，从而避免不必要的渲染和更新操作。
示例：
import React from 'react';

const MyComponent = React.memo((props) => {
  return <div>{props.text}</div>;
});

useMemo 是一个 Hook，用于缓存函数的计算结果，避免重复计算，从而提高应用的性能。它接收一个工厂函数和一个依赖数组作为参数，只有当依赖数组中的值发生变化时才会重新计算函数的值，否则直接返回缓存的结果。
示例：
import React, { useMemo } from 'react';

const MyComponent = (props) => {
  const result = useMemo(() => {
    // 计算结果的复杂逻辑return someExpensiveComputation(props.value);
  }, [props.value]);

  return <div>{result}</div>;
};

总结收敛
可以看出，React.memo 主要用于优化组件的渲染性能，避免不必要的重新渲染，而 useMemo 主要用于优化计算性能，避免重复计算。它们的应用场景和作用不同，但都可以帮助我们提高应用的性能。


react.memo和useMemo的使用场景（拓展了解）
React.memo() 和 useMemo() 都是 React 提供的性能优化工具，用于减少不必要的渲染和计算，提高组件的性能。它们的使用场景有以下区别：
React.memo() 用于优化组件的渲染，当组件的 props 没有变化时，可以避免重新渲染组件。React.memo() 的使用场景包括：
纯函数组件（Functional Component）：由于纯函数组件的 props 传入后就不会再改变，所以可以使用 React.memo() 来避免不必要的渲染。
高阶组件（Higher Order Component）：高阶组件的作用是封装组件逻辑，返回一个新的组件。在使用高阶组件时，可以使用 React.memo() 来避免重新渲染。
useMemo() 用于优化组件的计算，当组件的计算结果没有变化时，可以避免重复计算。useMemo() 的使用场景包括：
大量计算：当组件需要进行大量的计算时，可以使用 useMemo() 来缓存计算结果，避免重复计算。
依赖变化：当组件的计算结果依赖于某些变量时，可以使用 useMemo() 来监听这些变量的变化，当变量没有变化时，可以避免重复计算。

同上总结
综上所述，React.memo() 和 useMemo() 的使用场景有所区别。React.memo() 用于避免不必要的渲染，适用于纯函数组件和高阶组件；而 useMemo() 用于避免重复计算，适用于大量计算和依赖变化的场景。

react hooks的使用限制
点缀下，可以不答这里，了解下话术
React Hooks 是 React 16.8 版本引入的新特性，可以使函数组件拥有类组件的一些特性（如 state 和生命周期函数），并且可以更方便地实现代码复用。React Hooks 的使用需要遵守一定的规范和限制，只有在遵守这些限制的前提下才能保证其正确性和可靠性
直接答前面的标题，加粗的后面解释不问不答！方便你们理解

只能在函数组件或自定义 Hook 中使用：React Hooks 只能在函数组件或自定义 Hook 中使用，不能在普通的 JavaScript 函数中使用。
不能在条件语句中使用：React Hooks 的使用必须遵守相同的顺序，不能在条件语句中使用，因为这样会导致不同条件下的 Hooks 调用顺序不同，从而引发错误。
只能在 React 函数组件的最顶层使用：React Hooks 必须在函数组件的最顶层使用，不能在循环、嵌套函数、嵌套代码块中使用。
useState 的值不能直接修改：使用 useState 定义的状态值不能直接修改，必须使用其返回的 setState 函数进行修改。
useEffect 的回调函数中不能使用异步函数：在 useEffect 的回调函数中使用异步函数可能会引发一些问题，如无法正确地获取组件的 props 和 state 值。
useContext 必须在 useContext 所对应的 Context.Provider 中使用：使用 useContext 必须在 useContext 所对应的 Context.Provider 中使用，否则将无法获取到对应的值。

react hooks的原理
点题收敛


React Hooks 的实现原理主要是基于两个机制：函数组件和闭包。


详细回答


首先，React Hooks 的设计初衷是为了让函数组件具有类组件的一些特性（如 state 和生命周期函数），并且可以更方便地实现代码复用。为了实现这个目标，React 通过 Fiber 架构对组件的渲染过程进行了重构，将组件的状态和逻辑与渲染过程分离，使得组件的状态和逻辑可以在函数组件中进行处理。
其次，React Hooks 的实现还涉及到闭包的概念。Hooks 通过闭包机制来实现对状态和逻辑的封装和管理，使得组件的状态和逻辑可以被保存和复用。每一个 Hook 都对应一个闭包，其中保存了组件状态的值以及一些管理状态的函数，这些函数可以在组件的生命周期内被多次调用，从而实现对状态的更新和管理。


具体实现（拓展理解）
具体来说，React Hooks 的实现可以分为以下几个步骤：
在函数组件中调用 Hook 函数：Hook 函数是 React 提供的一些内置函数，如 useState、useEffect、useContext 等，用于管理组件的状态和逻辑。
创建对应的闭包：每次调用 Hook 函数时，React 会为当前组件创建一个对应的闭包，其中保存了组件状态的值以及一些管理状态的函数。
在渲染过程中使用闭包中保存的状态和函数：在组件的渲染过程中，React 会根据闭包中保存的状态和函数来执行组件的逻辑，更新组件的状态。
更新状态后重新渲染组件：当组件的状态发生变化时，React 会重新渲染组件，从而更新组件的 UI。
总之，React Hooks 的实现原理主要是基于函数组件和闭包的机制，通过对组件状态和逻辑的封装和管理，实现了对组件的复用和优化。

react setState是同步还是异步
点题收敛
在 React 中，setState 可能是同步的也可能是异步的，这取决于当前的执行环境。

详细回答
在 React 的合成事件和生命周期函数中，setState 是异步的，也就是说，调用 setState 方法并不会立即更新组件的状态，而是将更新放入一个更新队列中，等待后续的批量更新。这种机制被称为“批量更新”（batching），它可以优化性能并避免不必要的重复渲染。
在其他的代码执行环境中，setState 可能是同步的，也就是说，调用 setState 方法会立即更新组件的状态，不会等待后续的批量更新。这种情况可能会导致一些意想不到的问题，如组件的状态更新不及时，或者出现不必要的重复渲染。
为了避免这些问题，React 建议在代码中避免依赖 setState 的同步特性，而是使用 setState 的回调函数，或者使用 useEffect 来处理状态更新的副作用。


总结收敛
总之，React 中的 setState 可能是同步的也可能是异步的，取决于当前的执行环境。为了避免出现意想不到的问题，建议在代码中尽量避免依赖 setState 的同步特性，使用回调函数或者 useEffect 来处理状态更新的副作用。

react 如何防止子组件的重复渲染
点题收敛
React 通过 PureComponent、React.memo 和 shouldComponentUpdate 等方式来防止子组件的重复渲染。
详细回答
PureComponent：PureComponent 是 React 提供的一个内置组件，它实现了 shouldComponentUpdate 方法，可以根据组件的 props 和 state 是否发生变化来判断是否需要重新渲染组件。如果 props 和 state 没有发生变化，就会跳过组件的渲染，从而提高性能。使用 PureComponent 可以避免不必要的重复渲染，提高组件的性能。
React.memo：React.memo 是 React 提供的一个高阶组件，可以对函数组件进行浅比较，判断组件的 props 是否发生变化。如果 props 没有发生变化，就会跳过组件的渲染，从而提高性能。使用 React.memo 可以避免不必要的重复渲染，提高函数组件的性能。
shouldComponentUpdate：对于 class 组件，可以通过实现 shouldComponentUpdate 方法来判断组件是否需要重新渲染。在 shouldComponentUpdate 方法中，可以根据组件的 props 和 state 是否发生变化来判断是否需要重新渲染组件。如果 props 和 state 没有发生变化，就可以返回 false，跳过组件的渲染，从而提高性能。

总结收敛
总之，React 提供了多种方式来防止子组件的重复渲染，包括 PureComponent、React.memo 和 shouldComponentUpdate 等。这些方式可以根据组件的具体情况来选择使用，从而提高组件的性能。

为什么有时react两次（或者10次，道理一样）setState，只执行一次
点题收敛
在 React 中，当多次调用 setState 方法时，并不一定会立即触发组件的重新渲染，而是可能会将多次更新合并成一次更新，以提高性能。

详细回答
这种合并更新的机制被称为“批量更新”（batching）。React 会将多次更新放入一个更新队列中，等待后续的批量更新。在批量更新期间，React 会尽可能地合并更新，以减少重复渲染的次数。
具体来说，当使用 setState 方法进行状态更新时，React 会将更新放入更新队列中，并不会立即触发组件的重新渲染。如果在同一个事件处理函数、生命周期方法或 useEffect 回调中多次调用 setState，这些更新会被合并成一次更新，并在下一个批量更新期间一起执行。
但是，如果在异步操作（如定时器、Promise 等）中调用 setState 方法，这些更新就不会被合并，而是会立即触发组件的重新渲染。这是因为异步操作的执行时机不确定，React 无法确定何时结束当前的批量更新期间。

总结收敛
总之，当多次调用 setState 方法时，React 可能会将多次更新合并成一次更新，以提高性能。但是，如果在异步操作中调用 setState 方法，这些更新就不会被合并，而是会立即触发组件的重新渲染。

以下问题不做具体回答，大家可以尝试自己总结收敛一波
react如何处理异常
在 React 中，可以使用 try-catch 语句来捕获组件渲染时的异常，然后在错误边界中处理这些异常，以防止组件树的崩溃。
错误边界（Error Boundary）是 React 提供的一种机制，用于捕获子组件渲染时的异常，并在这些异常发生时显示备用 UI，而不是导致整个组件树崩溃。错误边界可以通过定义一个新的组件来实现，这个组件会在子组件渲染时尝试捕获异常，并在发生异常时显示备用 UI。
以下是处理异常的一些常见方法：
使用 componentDidCatch 方法：componentDidCatch 是一个生命周期方法，用于捕获子组件渲染时的异常，并在发生异常时显示备用 UI。在 componentDidCatch 方法中，可以使用 setState 方法来更新组件的状态，以触发重新渲染，并显示备用 UI。
使用 ErrorBoundary 组件：React 16 引入了 ErrorBoundary 组件，它是一个专门用于捕获子组件渲染时的异常的组件。可以将需要捕获异常的子组件作为 ErrorBoundary 的子组件，然后在 ErrorBoundary 组件中使用 componentDidCatch 方法来捕获异常并显示备用 UI。
使用 try-catch 语句：可以在组件渲染的过程中使用 try-catch 语句来捕获异常，并在发生异常时显示备用 UI。这种方法比较适合对单个组件进行异常处理，但需要在组件的 render 方法中手动编写 try-catch 语句。
总之，React 提供了多种处理异常的方法，可以根据具体的需求选择使用。使用错误边界或捕获异常的方式可以防止组件树的崩溃，并提高应用程序的稳定性和可靠性。

react有哪些性能优化的点
React 是一个非常快速、高效的 JavaScript 库，但在处理大规模的应用程序时，性能问题可能会成为一个问题。以下是一些可以优化 React 应用程序性能的常见点：
使用 React.memo：React.memo 是一个高阶组件，用于优化函数组件的渲染性能。它可以缓存组件的输出，以避免不必要的重新渲染。如果组件的 props 没有变化，则 React.memo 会返回缓存的组件输出，从而提高性能。
使用 shouldComponentUpdate 或 PureComponent：shouldComponentUpdate 是一个生命周期方法，用于控制组件是否应该重新渲染。PureComponent 是一个 React 组件类，它会自动实现 shouldComponentUpdate 方法，并在组件 props 或 state 发生变化时进行浅比较。使用这些方法可以避免不必要的重新渲染，提高性能。
使用虚拟列表：在处理大量数据时，React 可能会遇到性能问题。虚拟列表是一种优化技术，它只渲染当前可见区域的列表项，而不是渲染整个列表。这可以减少不必要的 DOM 操作，提高渲染性能。
使用分页加载：分页加载是一种优化技术，用于处理大量数据。它将数据分成多个页面，并在需要时逐个页面加载。这可以减少页面加载时间和渲染时间，提高性能。
避免不必要的重新渲染：在 React 中，不必要的重新渲染可能会导致性能问题。可以通过使用 shouldComponentUpdate 或 PureComponent 来避免不必要的重新渲染，并使用组件状态或上下文来避免重复计算。
使用 React.lazy 和 Suspense：React.lazy 和 Suspense 是一种新的优化技术，用于延迟加载组件和数据。可以将某些组件和数据分割成小块，并在需要时逐个加载。这可以减少初始加载时间和渲染时间，提高性能。
总之，React 的性能优化需要结合具体情况进行，可以根据应用程序的需求和特点选择相应的优化方法，从而提高应用程序的性能和用户体验。

redux中间件机制
Redux 中间件是在派发（dispatch）一个 action 和该 action 被 reducer 处理之间执行的函数。中间件可以拦截、解释或更改这些 actions，并在某些情况下在到达 reducer 之前对它们进行操作。使用 Redux 中间件可以实现诸如异步操作、日志记录、异常处理等功能。
Redux 中间件机制是通过对 dispatch 函数进行包装来实现的。每个中间件函数都接受 dispatch 和 getState 函数作为参数，并返回一个函数，这个函数接受 next 函数作为参数，并返回一个函数，这个函数接受 action 作为参数。这个返回的函数就是被称为“增强版”的 dispatch 函数，它会先经过所有的中间件函数处理，最后再传递给 reducer 处理。
中间件函数的代码通常如下所示：
const middleware = store => next => action => {
  // 这里可以对 action 进行处理
  // 调用 next(action) 将 action 传递给下一个中间件或 reducer
  return next(action)
}

在 Redux 中，可以通过 applyMiddleware 函数将中间件添加到 store 中。applyMiddleware 接受一组中间件函数作为参数，并返回一个增强版的 createStore 函数，这个函数会对 dispatch 函数进行包装，并将所有的中间件函数链式调用起来。具体的代码可以参考以下示例：
import { createStore, applyMiddleware } from 'redux'
import thunk from 'redux-thunk' // 中间件

const middleware = [thunk] // 将中间件放到一个数组中

const store = createStore(
  reducer, // reducer
  applyMiddleware(...middleware) // 应用中间件
)

在上面的代码中，thunk 中间件被应用到了 store 中，这使得我们可以在 action 中执行异步操作，例如调用 API 或者执行一个定时器函数。
总之，Redux 中间件机制为我们提供了一个灵活、可扩展的方案来处理复杂的应用程序逻辑。我们可以使用一组中间件函数来扩展 Redux 功能，以满足不同的应用程序需求。


redux有哪些原则
Redux 有三个核心原则：
单一数据源：整个应用的 state 都保存在一个单一的 JavaScript 对象中，称为 store。这使得整个应用的状态管理更加简单和可维护。
状态是只读的：state 不能直接被修改，唯一改变 state 的方式是派发 action。这样可以确保状态的可控性和可预测性，避免了状态的随意修改。
使用纯函数来执行修改：为了描述 action 如何改变 state，需要编写纯函数，称为 reducer。reducer 接收旧的 state 和一个 action 作为参数，返回一个新的 state。由于 reducer 是纯函数，所以它可以被预测、测试和重用。

Redux 还有一些其他的设计原则：
操作副作用要通过中间件：Redux 鼓励将所有操作副作用的代码放在中间件中处理。这包括异步操作、日志记录和其它非纯函数操作。
UI 和 state 分离：Redux 强调 UI 和 state 的分离。UI 应该只负责渲染 state，而不应该直接操作 state。所有的操作 state 的逻辑应该放在 action 和 reducer 中处理。
应用程序状态应该可以重现：Redux 中的时间旅行调试工具可以让用户回溯到之前的 state，这使得调试和重现 bug 更加容易。因此，在设计应用程序状态时，需要考虑到这个原则。

react 17 版本的面试题，及其答案(目前比较低频，持续整理中，有疑问的可以按照关键词查，具体理解)
以下是一些 React 17 版本的面试题和答案：
React 17 的新特性是什么？
答：React 17 的主要新特性是改进了 React 的事件系统，使得事件处理程序的行为更加一致，并且更好地支持像 Web Components 这样的可重用组件库。此外，React 17 还引入了一种新的渲染方法，称为“服务器渲染的渲染”，它允许使用 React 在非 DOM 环境中进行渲染，例如在 Canvas 或游戏引擎中。

React 17 中如何避免了一些常见的错误？
答：React 17 中引入了一些新的警告和错误，这些错误可以帮助开发人员更早地发现常见的错误，例如错误地使用 ref、将字符串传递给事件处理程序等等。此外，React 17 还改进了错误消息，使得它们更加易于理解和调试。


React 17 中的事件处理机制发生了什么变化？
答：React 17 中的事件处理机制已经升级，它现在更好地支持像 Web Components 这样的可重用组件库。在 React 17 中，事件处理程序的行为更加一致，无论是在 DOM 还是在自定义组件中。React 17 还引入了一个新的事件系统，称为“选择器事件系统”，它可以让开发人员使用类似于 CSS 选择器的语法来选择元素并绑定事件处理程序。


React 17 中的错误边界有什么变化？
答：在 React 17 中，错误边界的行为与之前基本相同，但是现在可以将多个错误边界嵌套在一起，以更好地控制错误的边界范围。此外，React 17 还引入了一些新的 API，使得错误边界更容易使用和调试。

React 17 中的 React.StrictMode 有什么变化？
答：在 React 17 中，React.StrictMode 的行为与之前基本相同，但是现在已经删除了对 UNSAFE_ 生命周期的支持。此外，React 17 还引入了一些新的警告和错误，使得在 StrictMode 下调试更加容易。

React 17 中如何使用服务端渲染的渲染？
答：React 17 中引入了一种新的渲染方法，称为“服务器渲染的渲染”，它允许使用 React 在非 DOM 环境中进行渲染，例如在 Canvas 或游戏引擎中。要使用这种新的渲染方法，需要使用 ReactDOMServer 类的 renderToStaticNodeStream 或 renderToNodeStream 方法来渲染应用程序，并将输出流发送到目标环境中。

React 18已经在正式发布哪些新特性
答：React 18 带来了多项重要特性，其中最核心的是并发渲染能力，支持任务中断与优先级调度，提升应用响应性。自动批处理扩展了状态更新的合并范围，减少不必要渲染。React 推荐使用新的根 API createRoot 启用并发特性。Suspense 也得到了加强，支持服务端渲染和更细粒度加载。新增了 useId Hook 用于生成稳定唯一的 ID，startTransition 用于标记过渡状态，提升交互体验。React Server Components 是一个实验性新特性，旨在减轻客户端负担。整体来看，React 18 为构建高性能、响应迅速的现代应用奠定了基础。

什么场景需要自定义hooks?
自定义 Hooks 是 React 中的一项强大的功能，它允许我们将组件之间重复的逻辑提取出来并封装成可重用的函数。自定义 Hooks 最常见的场景包括：
1. 处理组件逻辑的重复问题：例如在多个组件中都需要订阅同一个事件，可以将订阅事件的逻辑提取为一个自定义 Hooks，这样就可以在多个组件中共享这个 Hooks，减少重复代码。
2. 封装第三方库的复杂性：一些第三方库的使用比较复杂，例如日期选择器等，我们可以封装一个自定义 Hooks，将第三方库的使用细节隐藏起来，让组件代码更加简洁。
3. 处理复杂组件的状态：一些组件的状态比较复杂，例如表格组件、多步骤表单组件等，我们可以将这些组件的状态逻辑提取为自定义 Hooks，让组件代码更加清晰、易于维护。
自定义 Hooks 的优点包括：
1. 提高代码重用率：通过自定义 Hooks 可以将组件之间重复的逻辑提取出来，并封装成可重用的函数，从而提高代码的重用率。
2. 简化组件代码：通过自定义 Hooks 可以将组件内部的逻辑进行抽象和封装，从而让组件代码更加简洁。
3. 提高代码可维护性：通过自定义 Hooks 可以将逻辑进行单独的封装，使代码更加模块化，从而提高代码的可维护性。

fiber 在hooks 组件上的体现有哪些？
React Fiber 是 React 16 中的一个重大更新，它是一种新的、增量式的渲染方式。相比之前的栈式渲染方式，Fiber 可以中断、终止、恢复渲染过程，从而使得 React 可以在更加细粒度的层面上控制渲染，实现更好的性能和用户体验。
Fiber 架构下的 React，可以更好地支持 Hooks 组件。使用 Hooks 组件的时候，React Fiber 会基于 Hooks 的调用顺序，构建出一个 Effect 链表，以此来实现 Hooks 的实现。
在实现过程中，React 将每个组件看成是一个 Fiber 节点，每个 Fiber 节点都保存着组件的状态、子节点、指向父节点和兄弟节点的指针等信息。Hooks 组件会在渲染过程中被调用多次，每次调用会创建新的 Fiber 节点。当组件状态发生变化时，React 会重新构建 Fiber 树，通过比较前后两个 Fiber 树，确定哪些节点需要更新。
在 Hooks 组件中，useEffect 就是其中一种 Effect，它可以在组件挂载、更新或卸载时执行副作用。在 React Fiber 中，每个 Fiber 节点都有一个 Effect 链表，这个链表上保存了组件的副作用列表。每个 Effect 都有一个 tag，标识它的作用类型，比如更新 state、调用副作用等。当组件状态发生变化时，React 会遍历 Fiber 树，根据 Effect 链表执行副作用。
因此，可以说 React Fiber 使得 Hooks 组件的实现更加高效和灵活，可以更好地管理组件状态和副作用。

在react 中怎样的操作会导致内存泄漏？
在 React 中，内存泄漏通常是由于以下几种情况引起的：
1. 未清理的计时器和事件监听器：在组件挂载时创建了计时器和事件监听器，但在组件卸载时未清理它们，这会导致计时器和事件监听器继续运行，并且可能会导致组件卸载后仍然保留在内存中，从而导致内存泄漏。
2. 未清理的引用：当组件卸载时，如果它仍然被其他地方引用，例如在父组件中仍然保存着对子组件的引用，那么组件实例就不会被垃圾回收，这会导致内存泄漏。
3. 大量的渲染缓存：当组件渲染时，它可能会使用一些缓存的数据，例如之前计算出的结果或之前处理过的数据。如果这些缓存数据没有被正确地清理，它们可能会占用大量的内存，导致内存泄漏。
4. 长时间运行的异步任务：如果组件中有长时间运行的异步任务，例如长轮询或长时间运行的计算任务，它们可能会占用大量的内存，导致内存泄漏。
为了避免这些问题，我们可以使用 React 提供的生命周期方法和 Hooks 来清理无用的计时器和事件监听器、清理引用、清除渲染缓存、取消长时间运行的异步任务等。同时，也可以使用一些工具来检测和诊断内存泄漏问题，例如 Chrome DevTools 中的 Memory 面板和 React Profiler。

react 路由架构如何设计
React 路由架构设计一般包括以下几个方面：
1. 路由组件的设计：根据页面的层次结构，将路由划分成不同的组件，并使用 React Router 实现页面的路由切换。
2. 路由的配置：在应用程序中配置路由，包括定义路由路径、指定路由组件、传递参数等。
3. 路由守卫：通过定义路由守卫来控制页面的访问权限，例如登录验证、用户身份认证等。
4. 路由动画：通过设置过渡效果和动画，增强用户体验，使页面切换更加流畅。
5. 路由的状态管理：在应用程序中管理路由的状态，例如在不同的路由之间共享数据等。

类组件和函数组件有什么区别
React 中有两种定义组件的方式，即类组件和函数组件。
类组件是继承自 React.Component 类的 JavaScript 类，必须要有一个 render 方法来定义组件的输出。类组件可以通过 this.props 来获取父组件传递下来的 props 属性，并通过 this.state 来存储组件自己的状态。
函数组件是简单的 JavaScript 函数，函数的返回值就是组件的输出。函数组件可以通过参数来获取父组件传递下来的 props 属性，并通过 useState 等 Hook 来存储组件自己的状态。
下面是类组件和函数组件的区别：
1. 语法：类组件是一个继承自 React.Component 的 JavaScript 类，而函数组件是一个简单的 JavaScript 函数。
2. 状态管理：类组件使用 this.state 来管理状态，而函数组件使用 useState 等 Hook 来管理状态。
3. 生命周期：类组件有一系列生命周期方法，如 componentDidMount、componentDidUpdate 等，而函数组件可以使用 useEffect 等 Hook 来模拟这些生命周期方法。
4. 性能：函数组件比类组件更加轻量级，因为它不需要创建类实例，所以在渲染大量组件时，函数组件的性能会更好。
总的来说，随着 React Hooks 的推出，函数组件越来越成为 React 的主要开发方式。当你只需要展示一些简单的 UI 时，使用函数组件会更加简洁和方便，而在需要进行复杂的状态管理和生命周期控制时，则需要使用类组件。

对受控组件和非受控组件的理解
在React中，表单元素的值通常是由用户输入而来，我们可以将其存储在组件的状态中。根据状态的不同管理方式，我们可以将React的表单组件分为两种类型：受控组件和非受控组件。
1. 受控组件（Controlled Component）
受控组件指的是表单元素的值由组件的状态（state）来管理的组件。当用户输入时，React会将输入的值更新到组件的状态中，并通过设置value属性将状态的值传递给表单元素，同时通过onChange事件监听用户输入的值，再将输入的值更新到组件的状态中。这样，每当用户输入值时，状态都会得到更新，组件也会重新渲染。受控组件需要在组件中显式地处理表单的状态，实现较为繁琐，但可以方便地对表单进行验证和处理。
2. 非受控组件（Uncontrolled Component）
非受控组件指的是表单元素的值由DOM节点来管理的组件。在非受控组件中，我们可以使用ref来获取表单元素的值，但并不需要在组件中显式地处理表单的状态，也不需要监听表单元素的输入事件。这样，我们就可以在一些简单的场景中快速地构建表单组件，但是无法对表单进行验证和处理。

React组件通信场景有哪些？分别怎么实现通信呢？
在 React 中，组件之间通常有以下几种场景需要进行通信：
1. 父子组件通信：父组件向子组件传递数据或者子组件向父组件传递数据
● 父组件向子组件传递数据可以通过 props 属性进行传递
● 子组件向父组件传递数据可以通过回调函数进行传递，子组件触发回调函数，父组件接收到子组件传递的数据
2. 兄弟组件通信：在同一个父组件下的兄弟组件之间进行通信
● 可以通过将父组件中的数据传递给两个兄弟组件，然后让兄弟组件通过修改父组件中的数据进行通信
● 也可以通过使用 React Context 进行跨组件通信
3. 跨层级组件通信：在层级比较深的组件之间进行通信
● 可以通过 React Context 进行跨组件通信
4. 非父子组件通信：在没有直接父子关系的组件之间进行通信
● 可以通过使用全局状态管理工具（如 Redux 或 MobX）进行状态管理

其中，使用 props 属性进行组件通信是 React 中最为基本的方式。在父组件中定义需要传递给子组件的数据，然后通过 props 将数据传递给子组件，在子组件中可以通过 this.props 或者函数组件中的 props 参数来访问父组件传递的数据。
使用回调函数进行组件通信的方式，通常是在父组件中定义一个回调函数，并将该回调函数传递给子组件。当某些事件触发时，子组件调用该回调函数，并将数据传递给该回调函数。
使用 React Context 进行组件通信，通常需要在应用的根组件中创建一个 Context，并将需要共享的数据作为 Context 的值传递给子组件。子组件可以通过使用 useContext 钩子函数来访问 Context 中的数据。
全局状态管理工具则是将应用中的数据集中管理，从而使得所有组件都可以访问该数据。在 React 中，常见的全局状态管理工具包括 Redux 和 MobX 等，通过这些工具可以方便地管理组件之间的状态。

为什么只有react做了fiber优化？vue是否也需要做类似优化？为什么vue没做呢？
React做了Fiber优化的原因主要是因为React在早期版本中使用的是递归算法来遍历组件树，而当组件树变得过于庞大时，递归算法的性能会受到很大的影响，导致页面卡顿、掉帧等问题。为了解决这个问题，React团队引入了Fiber架构，使用迭代算法来遍历组件树，使得React能够更好地处理大型组件树，提高了性能和渲染效率。
相比之下，Vue使用的是递归算法来遍历组件树，但Vue团队也在不断地进行性能优化。例如，Vue在2.6版本中引入了虚拟滚动（Virtual Scroller）的功能，可以高效地渲染大量的数据，避免渲染整个组件树导致的性能问题。而在Vue 3中，也对渲染引擎进行了大量的重构和优化，进一步提升了性能和渲染效率。
因此，虽然Vue没有像React那样引入Fiber架构，但Vue团队一直在进行性能优化和渲染引擎的重构和优化，使得Vue能够更好地处理大型组件树和高效地渲染大量的数据。

为什么要有 useRef 呢？为什么不能 const 定义一个对象？


在React中，useRef是一个Hook函数，它可以用来保存一个可变的值，类似于class组件中的this.xxx属性。useRef可以在函数组件中进行DOM节点的引用，也可以保存组件内部的状态。其主要作用是绕开React的渲染机制，可以在组件渲染期间创建并保留一个变量，而不会触发组件的重新渲染。
相比于使用const定义一个对象，useRef有以下优点：
1. 在函数组件中，组件状态的定义必须使用useState或useReducer等Hook函数，而不能使用const定义变量。这是因为函数组件中没有实例的概念，因此无法在组件中使用this关键字或者实例属性。而使用useRef可以绕过这个限制，可以在函数组件中保存状态，并且不会触发组件的重新渲染。
2. 在组件渲染过程中，const定义的变量每次都会被重新创建。如果我们想在多次渲染中保持这个变量的值，需要将这个变量保存在组件的状态中，并且在组件每次渲染时更新这个状态。而使用useRef可以直接将这个变量保存在ref中，避免了组件状态的更新，提高了性能。
3. useRef可以用来保存DOM节点的引用，而且可以在组件渲染期间进行更新。这比使用document.getElementById等DOM API更加方便和高效。
总之，useRef的作用是保存一个可变的值，并且可以在组件渲染期间进行更新，而不会触发组件的重新渲染。它比const定义变量更加灵活和高效。
