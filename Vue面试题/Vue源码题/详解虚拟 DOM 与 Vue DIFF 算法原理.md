#### 核心点：

1. 什么是虚拟 DOM

- Vue 的虚拟 DOM（Virtual DOM）是 Vue 框架中的一种技术，用于优化 DOM 操作的效率和性能。虚拟 DOM 是一个 JavaScript 对象，它是对实际 DOM 结构的一种抽象表示。
- 每个虚拟DOM节点（VNode）代表一个真实DOM节点或一段文本。虚拟DOM对象包含与之相关的信息，如标签名、属性、子节点等。

1. 什么是 DIFF 算法

- [Vue.js](http://vue.js/) 的 Virtual DOM 实现了一种高效的 diff 算法，能够快速比较两个虚拟 DOM 树的差异。

1. 它们解决了什么问题？

- 当Vue组件的状态发生改变时，Vue会通过 DOM DIFF 算法比较新旧虚拟DOM树找出需要更新的部分，并将这些部分批量地更新到实际 DOM 中。这种批量更新可以减少对实际 DOM 的直接操作，从而**提高性能**。

1. 为什么要用虚拟 DOM？

1. 避免频繁操作 DOM，更好的实现跨平台、组件状态追踪等特性

1. DOM DIFF 算法中运用了哪些优化思路？

- 给列表项添加 Key 值，带有唯一 key 值的节点可以减少虚拟DOM的比对操作
- 将树的完全 DIFF 改为同层 DIFF，时间复杂度从 O(n3) 下降到 O(n)
- 同级比较中为了减少元素移动次数，采用了**双指针**配合**最长连续子串算法**
- Vue3 的静态标记算法，在编译阶段，通过编译器静态地分析模板，并识别其中的静态节点，在 DIFF 中可以跳过静态节点

#### 拓展回答

DOM diff 作为工程问题，需要具有一定算法思维，因此经常出现在面试场景中，毕竟这是难得出现在工程领域的算法问题。

**需要注意的是**，为了提高 diff 算法的性能，现代前端框架往往采用一些优化技巧，比如只比较同层级的节点、使用 key 值进行优化等，从而进一步提高渲染性能。



#### 为什么要使用虚拟 DOM？虚拟 DOM 的性能一定比原生 DOM 好吗？

- 当然是前端优化方面，避免频繁操作 DOM，频繁操作 DOM 会可能让浏览器回流和重绘，性能也会非常低，还有就是手动操作 DOM 还是比较麻烦的，要考虑浏览器兼容性问题，当前 jQuery 等库简化了 DOM 操作，但是项目复杂了，DOM 操作还是会变得复杂，数据操作也变得复杂
- 并不是所有情况使用虚拟 DOM 都提高性能，是针对在复杂的的项目使用。如果简单的操作，使用虚拟 DOM 要创建虚拟 DOM 对象等等一系列操作，还不如普通 的DOM 操作
- **跨平台**：虚拟 DOM 可以实现**跨平台渲染**，服务器渲染、小程序、原生应用都使用了虚拟 DOM
- **降低真实 DOM 操作**：使用虚拟 DOM，可以实现改变了当前的状态不需要立即的去更新 DOM。并且实现通过前后两次差异进行比较，只更新需要更新的内容，对于没有改变的内容不做任何操作
- **状态追踪**：虚拟 DOM 可以比较好的维护组件的状态，更好的跟踪的状态

#### Vue 2 和 Vue 3 的 DOM DIFF 完整过程

Vue 2 使用了经典的 Diff 算法，也称为双指针算法。其原理可以概括为以下几个步骤：

1. **生成新旧虚拟DOM树**：在重新渲染组件时，Vue会生成新的虚拟DOM树，并将其与旧的虚拟DOM树进行比较。
2. **深度优先遍历**：Vue 2 使用深度优先遍历算法来遍历新旧虚拟DOM树的节点。同时，Vue 2 会为每个节点添加唯一的标识符(VNode Key)以提高性能。
3. **Diff过程**：在遍历的过程中，Vue 2 会对比新旧虚拟DOM节点的类型和属性，判断是否需要更新实际DOM。具体的对比逻辑如下：

- 如果新旧虚拟DOM节点相同（类型相同且Key相同），则只需要更新节点的属性；
- 如果新旧虚拟DOM节点不同，则直接替换整个节点及其子节点；
- 如果节点存在子节点，则递归地对子节点进行Diff；
- 如果节点在旧虚拟DOM树中存在但在新虚拟DOM树中不存在，则直接删除该节点及其子节点。

1. **更新实际DOM**：根据Diff的结果，Vue 2 会将需要更新的部分进行批量更新，使实际DOM与新的虚拟DOM树保持一致。

Vue 3 采用了基于观察者的 Diff 算法，也称为静态分析算法。其主要原理如下：

1. **生成新旧虚拟DOM树**：与Vue 2 相同，Vue 3 在重新渲染组件时会生成新的虚拟DOM树，并将其与旧的虚拟DOM树进行比较。
2. **标记静态节点**：Vue 3 通过静态标记（Static Marking）技术，将那些不会发生变化的节点标记为静态节点，以减少对它们的Diff计算。
3. **Patch 过程**：在 Diff 过程中，Vue 3 采用了 Patch 策略来处理不同类型的节点：

- 对静态节点，Vue 3 将跳过其子节点的Diff过程，省略一些无谓的计算；
- 对动态节点，即有可能发生变化的节点，Vue 3 采用了优化的Heuristic算法，通过比较新旧虚拟DOM节点的选择器（Selector）信息，判断是否需要进行详细的Diff比较。

1. **更新实际DOM**：根据Patch的结果，Vue 3 将需要更新的部分进行批量更新，使实际DOM与新的虚拟DOM树保持一致。



下面，我们继续了解 Vue 是如何将两棵树的完全 DIFF 的时间复杂度从 **O(n****3****)** **降到** **O(n) 的。**

#### 正常而言两个树的完全对比 DIFF 比较算法：O(n3)

首先，我们需要理解，正常而言，想比较两棵树有什么不一样，其时间复杂度是 **O(n****3****)**：

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1697167264128-e254c6ff-a042-4d5f-9747-b5c277ecfd5c.png)

如图所示，理想的 Dom diff 自然是滴水不漏的复用所有能复用的，实在遇到新增或删除时，才执行插入或删除。

可惜程序无法猜到你的想法，想要精确复用就必须付出高昂的代价：时间复杂度 O(n³) 的 diff 算法，这显然是无法接受的，因此理想的 Dom diff 算法无法被使用。

关于 O(n³) 的由来。由于左树中任意节点都可能出现在右树，所以必须在对左树深度遍历的同时，对右树进行深度遍历，找到每个节点的对应关系，这里的时间复杂度是 O(n²)，之后需要对树的各节点进行增删移的操作，这个过程简单可以理解为加了一层遍历循环，因此再乘一个 n。

这里的核心点在于，**用传统算法对两棵树进行 DOM DIFF，时间复杂度太高，势必会导致更新效率低，因此，不管是 Vue 还是 React，都在寻求时间复杂度更高的 DOM DIFF 算法**。



#### Vue 实现 O(n) 时间复杂度同层 DOM DIFF 算法

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1697167504365-52345a14-f6d7-406e-9cce-092c5168e2bd.png)

如图所示，只按层比较，就可以将时间复杂度降低为 **O(n)**。按层比较也不是广度遍历，其实就是判断某个节点的子元素间 diff，跨父节点的兄弟节点也不必比较。

这样做确实非常高效，但代价就是，判断的有点傻，比如 ac 明明是一个移动操作，却被误识别为删除 + 新增。

**只同层比较的可行性原因：**跨 DOM 复用在实际业务场景中是很少出现的，，这时候我们就不要太追求学术思维上的严谨了，毕竟框架是给实际项目用的，实际项目中很少出现的场景，算法是可以不考虑的。

面是同层 diff 可能出现的三种情况，非常简单，看图即可：

![img](https://cdn.nlark.com/yuque/0/2023/webp/311219/1697167674492-65b36789-c7ed-464f-abe5-dbbf01c8230f.webp)

那么**同层比较是怎么达到 O(n) 时间复杂度**的呢？我们来看具体框架的思路。

Vue 的 Dom diff 一共 5 步，我们结合下图先看前三步：

![img](https://cdn.nlark.com/yuque/0/2023/webp/311219/1697167735089-22c5eec3-badc-4603-b3f0-b8e0ad107e08.webp)

如图所示，第一和第二步分别从首尾两头向中间逼近，尽可能跳过首位相同的元素，因为我们的目的是 **尽量保证不要发生 dom 位移**。

这种算法一般采用双指针。如果前两步做完后，发现旧树指针重合了，新树还未重合，说明什么？说明新树剩下来的都是要新增的节点，批量插入即可。很简单吧？那如果反过来呢？如下图所示：

![img](https://cdn.nlark.com/yuque/0/2023/webp/311219/1697167735155-f15affcf-4bc2-4cd7-8ca8-5eb68990e396.webp)

第一和第二步完成后，发现新树指针重合了，但旧树还未重合，说明什么？说明旧树剩下来的在新树都不存在了，批量删除即可。

当然，如果 1、2、3、4 步走完之后，指针还未处理完，那么就进入一个小小算法时间了，我们需要在 O(n) 时间复杂度内把剩下节点处理完。熟悉算法的同学应该很快能反映出，一个数组做一些检测操作，还得把时间复杂度控制在 O(n)，得用一个 Map 空间换一下时间，实际上也是如此，我们看下图具体做法：

![img](https://cdn.nlark.com/yuque/0/2023/webp/311219/1697167735096-7cec0918-b3d6-4f97-9cdb-e35ca5792eb6.webp)

如图所示，1、2、3、4 步走完后，Old 和 New 都有剩余，因此走到第五步，第五步分为三小步：

1. 遍历 Old 创建一个 Map，这个就是那个换时间的空间消耗，它记录了每个旧节点的 index 下标，一会好在 New 里查出来。
2. 遍历 New，顺便利用上面的 Map 记录下下标，同时 Old 在 New 中不存在的说明被删除了，直接删除。
3. 不存在的位置补 0，我们拿到 e:4 d:3 c:2 h:0 这样一个数组，下标 0 是新增，非 0 就是移过来的，批量转化为插入操作即可。

最后一步的优化也很关键，我们不要看见不同就随便移动，为了性能最优，要保证移动次数尽可能的少，那么怎么才能尽可能的少移动呢？假设我们随意移动，如下图所示：

![img](https://cdn.nlark.com/yuque/0/2023/webp/311219/1697167734946-1d6bf8af-107b-4f62-b3e0-dd033d2d21a8.webp)

但其实最优的移动方式是下面这样：

![img](https://cdn.nlark.com/yuque/0/2023/webp/311219/1697167735040-f56f1c36-55ea-4f69-a75f-47cc471fae6d.webp)

为什么呢？因为移动的时候，其他元素的位置也在相对变化，可能做了 A 效果同时，也把 B 效果给满足了，也就是说，找到那些相对位置有序的元素保持不变，让那些位置明显错误的元素挪动即是最优的。

什么是相对有序？a c e 这三个字母在 Old 原始顺序 a b c d e 中是相对有序的，我们只要把 b d 移走，这三个字母的位置自然就正确了。因此我们只需要找到 New 数组中的 **最长子序列**。具体的找法可以当作一个小算法题了，由于知道每个元素的实际下标，比如这个例子中，下标是这样的：

[b:1, d:3, a:0, c:2, e:4]

肉眼看上去，连续自增的子串有 b d 和 a c e，由于 a c e 更长，所以选择后者。

换成程序去做，可以采用贪心 + 二分法进行查找，详细可以看这道题 [最长递增子序列](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Flongest-increasing-subsequence%2F)，时间复杂度 O(nlogn)。

由于该算法得出的结果顺序是乱的，Vue 采用提前复制数组的方式辅助找到了正确序列。

**注意：上面是 Vue DIFF 算法的一个原理展示。**

Diff 总结有这么几点考虑：

1. **完全对比 O(n³) 无法接受，故降级为同层对比的 O(n) 方案。**
2. **为什么降级可行？因为跨层级很少发生，可以忽略。**
3. **同层级也不简单，难点是如何高效位移，即最小步数完成位移。**
4. **Vue 为了尽量不移动，先左右夹击跳过不变的，再找到最长连续子串保持不动，移动其他元素。**

#### Vue 列表渲染中 Key 的作用

在 Vue 的列表渲染中，key 是用于标识不同元素的唯一属性。它主要有以下作用：

1. **提供稳定的节点身份**：在使用 v-for 进行列表渲染时，Vue 会根据被迭代数据生成对应的虚拟DOM节点。如果列表项的顺序发生变化，没有设置 key 的情况下，Vue 将无法准确追踪每个虚拟DOM节点的状态，导致出现错误的更新。而设置了 key 后，Vue 可以通过 key 值来准确地检测每个节点的变化，提供更准确和高效的更新策略。
2. **优化列表渲染性能**：带有唯一 key 值的节点可以减少虚拟DOM的比对操作。Vue 在进行列表渲染时会使用 Diff 算法来找出新旧虚拟DOM节点之间的差异并进行局部更新。如果列表项没有设置 key，则会使用默认的比对规则，导致需要对全部节点进行比对。而设置了唯一的 key 值后，Vue 可以通过 key 进行快速查找，只对变化的节点进行更新，从而提高渲染性能。
3. **保持节点状态和避免重排**：当列表项重新排序或动态增删时，没有设置 key 的情况下，DOM 元素会频繁地在父组件中移动，导致浏览器重新计算元素的样式和布局，影响性能。而通过设置合适的 key 值，可以让 Vue 识别出每个元素的稳定身份，减少 DOM 元素的移动，从而保持节点的状态和避免不必要的重排。

需要注意的是，key 必须是唯一且稳定的字符串或数字，每个列表项都应该有一个对应的唯一 key 值。在使用 v-for 进行列表渲染时，建议优先选择具有稳定唯一值的属性作为 key，避免使用索引等动态变化的值。此外，不同层级的节点之间的 key 应该是不同的，并且不同列表之间的 key 也应该是不同的，以确保唯一性。

#### Vue3 的静态标记算法

Vue 3 的静态标记算法是一种在虚拟DOM Diff 过程中用来标记静态节点的技术。它的主要目的是减少对那些不会发生变化的节点进行无谓的Diff计算，从而提升渲染性能。

静态节点是指在组件渲染过程中不会改变的节点，包括元素节点、文本节点等。这些节点的内容在组件的多次更新中保持不变。

Vue 3 的静态标记算法将标记过程从Diff过程中分离出来，可以在编译阶段对模板进行静态分析并标记。具体的过程如下：

1. **编译阶段**：在Vue 3 中，模板会在编译阶段被转换为渲染函数。在此过程中，编译器会静态地分析模板，并识别其中的静态节点。
2. **静态标记**：通过静态标记算法，编译器会为静态节点添加额外的标记信息。这些标记信息可以帮助运行时的Diff算法在比较新旧虚拟DOM树时忽略那些已经被标记为静态的节点。
3. **Diff 过程**：在组件重新渲染时，Vue 3 的Diff算法会利用静态标记信息，在遍历虚拟DOM树时跳过那些被标记为静态的节点，从而减少了对它们的Diff计算。

通过静态标记算法，Vue 3 可以更加智能地处理那些不会发生变化的节点，避免了不必要的计算和更新操作，提高了渲染性能。同时，静态标记算法也为 Vue 3 引入其他优化策略（如Patch算法）提供了基础，进一步提升了组件的渲染效率。

#### Vue3 的 Patch 算法

其实我们上面提到的 DOM DIFF 算法，在 Vue 中的表现就是 Patch 算法。

Vue 3 中的 Patch 算法是用于比较新旧虚拟 DOM，并将变化应用到实际 DOM 的一种算法。它是 Vue 3 在渲染过程中使用的核心算法之一，用于实现高效的 DOM 更新。

Patch 算法的主要目标是尽量复用现有的 DOM 节点，最小化对真实 DOM 的操作，从而提高性能。具体的过程如下：

1. **创建新节点**：首先，根据新的虚拟 DOM，创建一个新的节点树。
2. **比较新旧节点**：将新的虚拟 DOM 树与旧的虚拟 DOM 树进行逐层比较。在比较过程中，Patch 算法会根据节点的类型、属性、子节点等信息来判断节点的变化情况。
3. **更新差异**：当发现节点存在差异时，Patch 算法会有针对性地进行更新操作，以尽量减少对真实 DOM 的操作。可能的更新操作包括替换节点、更新属性、移动节点位置等。
4. **递归处理子节点**：如果存在子节点，Patch 算法会递归调用自身，继续比较和更新子节点。

通过 Patch 算法，Vue 3 可以有效地识别出虚拟 DOM 中哪些节点发生了变化，并且只对变化的部分进行实际 DOM 的更新操作，从而提高了渲染的效率。

在 Patch 算法的实现中，Vue 3 还使用了一些优化策略，例如使用静态标记算法来跳过静态节点的比较和更新，以及使用 key 属性来进行更精确的更新操作。这些优化措施进一步提升了 Patch 算法的性能和效率。

总之，Patch 算法是 Vue 3 实现高效渲染的关键算法之一，它通过差异比对和最小化 DOM 操作的方式，使得 Vue 3 在数据变化时能够快速、准确地更新视图。

#### 参考资料：

- [精读《DOM diff 原理详解》](https://juejin.cn/post/6947856296771223589?searchId=20231013110945B41DCA8D5CD5AC892257)