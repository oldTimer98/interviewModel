Vue 有非常多在实践中可行的性能优化方案，可基于自身实操经验理解记忆。

同时，避免想到什么说什么，可以更加有条理性的回答问题（系统化思维），尝试将不同的性能优化进行分类记忆总结。

Vue 相关的性能优化，大致可以分为：

- **页面渲染加载性能优化**

- 避免将所有数据设置为响应式数据
- 合理使用 computed 和 watch 
- 列表性能优化
- 服务端渲染 SSR

- **页面更新性能优化**

- 静态内容标记为只渲染一次(v-once)以及缓存模板的子树(v-memo)
- 减少大型不可变数据的响应性开销
- 给 v-for 添加 key 且避免同时使用 v-if
- 合理使用 v-if 与 v-show
- 使用 keep-alive 组件

- **构建优化**

- 路由懒加载
- 包体积优化与 Tree-shaking 优化
- SourceMap 的处理



### 避免将所有数据设置为响应式数据

不要将所有的数据都放到 data 中，data 中的数据都会增加 getter 和 setter，并且会收集 watcher，这样还占内存，不需要响应式的数据我们可以直接定义在实例上。

```javascript
<template>
    <div>
  	    //...
    </div>
</template>

<script>
    export default {
        components: {},
        data: () => ({
            
        }),
        beforeCreate: function(){
            this.timer = null;
        }
    }
</script>

<style scoped>
</style>
```

### 合理使用 computed 和 watch 

在理解 computed 和 watch 的原理本质上，合理使用 computed 和 watch，能够让运行时性能更佳。

- **computed**： computed是计算属性，依赖其它属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取computed的值时才会重新计算computed的值。
- **watch**： watch 更多的是观察的作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。

当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的**缓存特性**，避免每次获取值时，都要重新计算。

当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。

### 列表性能优化

所有的前端应用中最常见的性能问题就是渲染大型列表。无论一个框架性能有多好，渲染成千上万个列表项**都会**变得很慢，因为浏览器需要处理大量的 DOM 节点。

Vue 会通过 Object.defineProperty/Proxy 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，可以通过 `Object.freeze()` 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。

```javascript
export default {
  data: () => ({
      users: {}
  }),
  async created() {
      const users = await axios.get("/api/users");
      this.users = Object.freeze(users);
  }
};
```

对于需要修改的长列表的优化，主要核心在于：仅渲染视窗可见的数据（虚拟列表）、进行函数节流、 减少驻留的 VNode 和 Vue 组件、分页等手段。

我们并不需要立刻渲染出全部的列表。在大多数场景中，用户的屏幕尺寸只会展示这个巨大列表中的一小部分。我们可以通过**列表虚拟化**来提升性能，这项技术使我们只需要渲染用户视口中能看到的部分。

要实现列表虚拟化并不简单，幸运的是，你可以直接使用现有的社区库：

- [vue-virtual-scroller](https://github.com/Akryum/vue-virtual-scroller)
- [vue-virtual-scroll-grid](https://github.com/rocwang/vue-virtual-scroll-grid)
- [vueuc/VVirtualList](https://github.com/07akioni/vueuc)

### 服务端渲染 SSR

什么是 SSR？默认情况下，Vue 组件的职责是在浏览器中生成和操作 DOM。然而，Vue 也支持将组件在服务端直接渲染成 HTML 字符串，作为服务端响应返回给浏览器，最后在浏览器端将静态的 HTML“激活”(hydrate) 为能够交互的客户端应用。

如果需要优化首屏加载速度并且首屏加载速度是至关重要的点，那么就需要服务端渲染 SSR，服务端渲染SSR 其实是优缺点并行的，需要合理决定是否真的需要服务端渲染。

#### 优点

- **更快的首屏加载**：这一点在慢网速或者运行缓慢的设备上尤为重要。服务端渲染的 HTML 无需等到所有的 JavaScript 都下载并执行完成之后才显示，所以你的用户将会更快地看到完整渲染的页面。除此之外，数据获取过程在首次访问时在服务端完成，相比于从客户端获取，可能有更快的数据库连接。这通常可以带来更高的[核心 Web 指标](https://web.dev/vitals/)评分、更好的用户体验，而对于那些“首屏加载速度与转化率直接相关”的应用来说，这点可能至关重要。
- **统一的心智模型**：你可以使用相同的语言以及相同的声明式、面向组件的心智模型来开发整个应用，而不需要在后端模板系统和前端框架之间来回切换。
- **更好的 SEO**：搜索引擎爬虫可以直接看到完全渲染的页面。由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面，如果SEO对站点至关重要，而页面又是异步获取内容，则可能需要服务器端渲染 SSR解决此问题。

- **更快的内容到达时间 time-to-content**，特别是对于缓慢的网络情况或运行缓慢的设备，无需等待所有的 JavaScript 都完成下载并执行，用户将会更快速地看到完整渲染的页面，通常可以产生更好的用户体验，并且对于那些内容到达时间 time-to-content 与转化率直接相关的应用程序而言，服务器端渲染SSR至关重要。

#### 缺点

- 开发条件所限，浏览器特定的代码，只能在某些生命周期钩子函数 lifecycle hook 中使用，一些外部扩展库 external library 可能需要特殊处理，才能在服务器渲染应用程序中运行。
- 涉及构建设置和部署的更多要求，与可以部署在任何静态文件服务器上的完全静态单页面应用程序SPA不同，服务器渲染应用程序，通常需要处于 Node.js server 运行环境。
- 更大的服务器端负载，在Node.js中渲染完整的应用程序，显然会比仅仅提供静态文件的server更加大量占用 CPU 资源 CPU-intensive-CPU 密集型，因此如果预料在高流量环境 high traffic 下使用，需要准备相应的服务器负载，并明智地采用缓存策略。

在为你的应用使用 SSR 之前，你首先应该问自己是否真的需要它。这主要取决于首屏加载速度对应用的重要程度。例如，如果你正在开发一个内部的管理面板，初始加载时的那额外几百毫秒对你来说并不重要，这种情况下使用 SSR 就没有太多必要了。然而，在内容展示速度极其重要的场景下，SSR 可以尽可能地帮你实现最优的初始加载性能。

### 静态内容标记为只渲染一次(v-once)以及缓存模板的子树(v-memo)

可以使用 v-once 指令将一部分静态内容标记为只渲染一次，避免重复的响应式计算。

在随后的重新渲染，元素/组件及其所有子项将被当作静态内容并跳过渲染。这可以用来优化更新时的性能。

```html
<!-- 单个元素 -->
<span v-once>This will never change: {{msg}}</span>

<!-- 带有子元素的元素 -->
<div v-once>
  <h1>comment</h1>
  <p>{{msg}}</p>
</div>

<!-- 组件 -->
<MyComponent v-once :comment="msg" />
  
<!-- `v-for` 指令 -->
<ul>
  <li v-for="i in list" v-once>{{i}}</li>
</ul>
```

从 3.2 起，你也可以搭配 v-memo 的无效条件来缓存部分模板。

v-memo 可缓存一个模板的子树。在元素和组件上都可以使用。为了实现缓存，该指令需要传入一个固定长度的依赖值数组进行比较。如果数组里的每个值都与最后一次的渲染相同，那么整个子树的更新将被跳过。举例来说：

```html
<div v-memo="[valueA, valueB]">
  ...
</div>
```

当组件重新渲染，如果 valueA 和 valueB 都保持不变，这个 <div> 及其子项的所有更新都将被跳过。实际上，甚至虚拟 DOM 的 vnode 创建也将被跳过，因为缓存的子树副本可以被重新使用。

正确指定缓存数组很重要，否则应该生效的更新可能被跳过。v-memo 传入空依赖数组 (v-memo="[]") 将与 v-once 效果相同。



### 减少大型不可变数据的响应性开销

Vue 的响应性系统默认是深度的。虽然这让状态管理变得更直观，但在数据量巨大时，深度响应性也会导致不小的性能负担，因为每个属性访问都将触发代理的依赖追踪。好在这种性能负担通常只有在处理超大型数组或层级很深的对象时，例如一次渲染需要访问 100,000+ 个属性时，才会变得比较明显。因此，它只会影响少数特定的场景。

Vue 确实也为此提供了一种解决方案，通过使用 [shallowRef()](https://cn.vuejs.org/api/reactivity-advanced.html#shallowref) 和 [shallowReactive()](https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive) 来绕开深度响应。浅层式 API 创建的状态只在其顶层是响应式的，对所有深层的对象不会做任何处理。这使得对深层级属性的访问变得更快，但代价是，我们现在必须将所有深层级对象视为不可变的，并且只能通过替换整个根状态来触发更新：

```javascript
const shallowArray = shallowRef([
  /* 巨大的列表，里面包含深层的对象 */
])

// 这不会触发更新...
shallowArray.value.push(newObject)
// 这才会触发更新
shallowArray.value = [...shallowArray.value, newObject]

// 这不会触发更新...
shallowArray.value[0].foo = 1
// 这才会触发更新
shallowArray.value = [
  {
    ...shallowArray.value[0],
    foo: 1
  },
  ...shallowArray.value.slice(1)
]
```

### 给 v-for 添加 key 且避免同时使用 v-if

首先，注意，v-for 和 v-if 在最佳实践中，不建议同时作用给同一个标签。

在 **Vue2 中**，**v-for 的优先级是高于 v-if**，把它们放在一起，输出的渲染函数中可以看出会先执行循环再判断条件，哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表，这会比较浪费；

另外需要注意的是在 **Vue3 中则完全相反，v-if的优先级高于v-for**，所以v-if执行时，它调用的变量还不存在，就会导致异常。

**为了过滤列表中的项目** (比如 `v-for="user in users" v-if="user.isActive"`)。此时更好的做法应该是定义一个计算属性 (比如 activeUsers)，让其返回过滤后的列表即可：

```javascript
<template>
  <div>
    <div v-for="item in filteredItems">
      {{ item.name }}
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      items: [
        { name: 'Apple', isVisible: true },
        { name: 'Banana', isVisible: false },
        { name: 'Orange', isVisible: true },
      ]
    };
  },
  computed: {
    filteredItems() {
      return this.items.filter(item => item.isVisible);
    }
  }
};
</script>
```

而给 v-for 添加 key 这个非常好理解，添加 key 的主要原因是**为了帮助 Vue 更高效地更新 DOM**。当数据发生变化时，Vue 框架会优先比较新旧节点之间的 key 值，如果相同则认为是相同的节点，直接更新其它属性值即可；如果不同，则会销毁旧节点，创建新节点，并进行必要的 DOM 操作。

如果没有设置 key 属性，那么 Vue 框架会默认使用每个元素的索引作为其 key 值，这可能会导致一些问题，如：

1. 如果数据项的顺序发生变化，Vue 会简单地将已有的 DOM 元素移动到新的位置，而不是新建/销毁对应的 DOM 元素，这可能会导致渲染错误和性能问题。
2. 如果两个元素在不同的位置但具有相同的数据，那么 Vue 可能会将它们视为相同元素，从而导致错误的渲染结果。

**使用 key 属性可以避免以上问题，确保 Vue 能够准确地追踪每个元素的状态并进行正确的 DOM 操作**。



### 合理使用 v-if 与 v-show 

v-if 和 v-show 是常见的在 Vue 显示/隐藏元素的方式。在理解原理的基础上合理使用他们，能够得到更好的更新性能。

**v-if** 是一种**惰性渲染方式**，它根据表达式的真假值来决定是否渲染元素。当表达式为真时，对应的元素会被创建并插入到 DOM 中；当表达式为假时，对应的元素会被销毁并从 DOM 中移除。这意味着在切换条件时，有可能会频繁地创建和销毁元素。

使用场景：

- 当条件很少改变时，可以使用 v-if。因为在条件不满足时，元素会被完全移除，这样可以节省内存占用。
- 当条件切换时，或者条件的计算成本比较高时，也可以考虑使用 v-if。

**v-show** 是通过 CSS 样式的显示和隐藏来控制元素的可见性。当条件为真时，元素会被显示（通过 display）；当条件为假时，元素会被隐藏。

使用场景：

- 当需要频繁切换元素的可见性时，可以使用 v-show。因为元素并未被销毁，只是简单地切换 CSS 样式，所以切换性能较好。
- 当初始渲染开销较大时，可以使用 v-show，因为元素一开始就被渲染到 DOM 中，避免了初始加载的延迟。

**总结：**

- v-if 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。
- v-if 也是**惰性**的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。
- 相比之下，v-show 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS display 属性会被切换。
- 总的来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 v-show 较好；如果在运行时绑定条件很少改变，则 v-if 会更合适。

### 使用 keep-alive 组件

<keep-alive> 是一个内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例。

当在组件之间切换的时候，有时会想保持这些组件的状态，以避免反复重渲染导致的性能等问题，使用<keep-alive> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。

重新创建动态组件的行为通常是非常有用的，但是在有些情况下我们更希望那些标签的组件实例能够被在它们第一次被创建的时候缓存下来，此时使用 <keep-alive> 包裹组件即可缓存当前组件实例，将组件缓存到内存，用于保留组件状态或避免重新渲染，和 <transition> 相似，其自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。

```html
<keep-alive>
  <component v-bind:is="currentComponent" class="tab"></component>
</keep-alive>
```

### 路由懒加载（代码分割）

Vue 是单页面应用，可能会有很多的路由引入，这样使用 Webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。

如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效。对于 Vue 路由懒加载的方式有 Vue 异步组件、动态 import、webpack 提供的 require.ensure，最常用的就是动态 import 的方式。

```javascript
{
  path: "/example",
  name: "example",
  //打包后，每个组件单独生成一个chunk文件
  component: () => import("@/views/example.vue")
}
```

在上述代码中，我们使用 import() 语法来进行动态导入组件。当路由被访问时，对应的组件会被按需加载，而不是一开始就被加载。

需要注意的是，动态路由加载在构建工具对代码进行打包时会根据路由的访问情况拆分成多个文件，因此在浏览器中访问路由时，会动态请求对应的文件。

动态加载路由可以有效减少初始首次加载的资源大小，提高应用的初次加载速度，同时也可以根据实际需求按需加载组件。

### 包体积优化与 Tree-shaking 优化

一个最有效的提升页面加载速度的方法就是压缩 JavaScript 打包产物的体积。当使用 Vue 时有下面一些办法来减小打包产物体积：

- **Tree-shaking**

- 如果使用的是相对现代的打包工具，许多 Vue 的 API 都是可以被 [tree-shake](https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking) 的。举例来说，如果你根本没有使用到内置的 <Transition> 组件，它将不会被打包进入最终的产物里。Tree-shaking 也可以移除你源代码中其他未使用到的模块。

- **模板预编译**

- 当使用构建工具进行构建时，模板会被预编译，模板预编译是指将 Vue 模板在构建过程中提前编译成渲染函数的过程。因此我们无须在浏览器中载入 Vue 编译器。由于预编译后的渲染函数只包含实际需要的 JavaScript 代码，不需要包含模板解析器等额外的库，因此可以减小打包后的文件大小。
- 模板预编译通常是在构建过程中完成的，可以通过 Vue Loader 或单独的模板编译工具（如 vue-template-compiler）来实现。在构建过程中，Vue Loader 会将模板转换为渲染函数，并将其打包到组件中。 需要注意的是，模板预编译是一种可选的优化手段，如果你的应用规模较小或对性能要求不高，可以不使用模板预编译。但对于大型应用或对性能要求敏感的场景，模板预编译可以带来显著的性能提升和包体积减小。

- 在引入新的依赖项时要小心包体积膨胀！在现实的应用中，包体积膨胀通常因为无意识地引入了过重的依赖导致的。

- 应当尽量选择提供 ES 模块格式的依赖，它们对 tree-shaking 更友好。举例来说，选择 lodash-es 比 lodash 更好。
- 查看依赖的体积，并评估与其所提供的功能之间的性价比。如果依赖对 tree-shaking 友好，实际增加的体积大小将取决于你从它之中导入的 API。像 [bundlejs.com](https://bundlejs.com/) 这样的工具可以用来做快速的检查，但是根据实际的构建设置来评估总是最准确的。

### SourceMap 的处理

在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel 编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有 BUG 的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发来说不好调式定位问题，因此 SourceMap 出现了，它就是为了解决不好调式代码问题的。

SourceMap **可以将构建后的压缩代码映射回源代码，方便开发者在浏览器中进行调试和查看原始代码**。

SourceMap 文件的作用包括：

1. **调试**：通过 SourceMap 文件，可以在浏览器的开发者工具中直接查看和调试未经压缩的源代码，而不是只能看到压缩后的代码。
2. **错误追踪**：当应用出现异常或报错时，通过 SourceMap 文件，开发者可以追踪到错误的源代码位置，快速定位问题并进行修复。
3. **性能优化**：SourceMap 文件可以帮助开发者分析应用中的性能问题，比如找出耗时的函数或模块，进行优化。

然而，在构建的过程中产出 SourceMap 是额外需要消耗（时间），**因此，想要更快的打包速度可以通过关闭 SourceMap 的产出得到**。

但是需要注意的是，不构建 SourceMap 文件必然会导致 Live 环境 Debug 困难，因此，这是一个需要取舍的问题。同时，即便我们产出了 SourceMap 文件，也不应该将其与构建的静态资源产出放置在同个静态资源目录。这样会导致其他人可以随意的调试我们的源代码。

为了安全使用 SourceMap 文件，可以考虑以下几点：

1. **生产环境配置**：在生产环境中，默认应该关闭生成 SourceMap 文件，以避免将源代码暴露给用户。通常在构建工具的配置中可以设置关闭生成 SourceMap 的选项。
2. **保护 SourceMap 文件**：如果确实需要在生产环境中使用 SourceMap 文件进行错误追踪，应该确保合理保护这些文件，防止被未授权的访问。可以通过服务器配置、权限控制或加密等方式保障 SourceMap 文件的安全。
3. **定期更新和删除**：定期更新和删除不再需要的 SourceMap 文件，以防止过时或泄露的文件被滥用。
4. **监控和报警**：如果 SourceMap 文件发生异常访问或大量下载，应设置监控和报警机制，及时发现并处理潜在的安全风险。

总之，在使用 SourceMap 文件时，应谨慎操作，遵循安全最佳实践，确保源代码的保密性和应用的安全性。



### Else

此外，我还收集了一些冷门优化，具体的一些优化技巧，可以继续阅读：

1. [揭秘 Vue.js 九个性能优化技巧](https://juejin.cn/post/6922641008106668045)