### 核心点：

1. **要知道 Vue2/Vue3 的依赖收集方式是有所不同的，Vue2 主要借助 Object.defineProperty，Vue3 主要借助 Proxy 代理对象**
2. **对两个版本的依赖收集流程有所了解，了解他们的核心共通点**
3. Vue 中的**计算属性**是如何进行**依赖收集**的？



### Vue2 / Vue3 依赖收集的核心共通点

虽然 Vue 2 与 Vue 3 实现响应式系统的方式不同，但是他们的核心思想还是一致的，都是通过 **发布-订阅模式** 来实现（因为发布者和观察者之间多了一个 **dependence** 依赖收集者，与传统观察者模式不同）。

在Vue2和Vue3中，依赖收集是实现数据响应式的关键机制之一。它们在依赖收集方面存在一些差异，下面将详细介绍Vue2和Vue3是如何进行依赖收集的。

观察者模式：一个被观察对象对应多个观察者，两者直接联系；被观察这改变时直接向所有观察者发送消息（调用观察者的更新方法）

![img](https://cdn.nlark.com/yuque/0/2023/webp/311219/1696854236650-79a034a3-8190-4745-9b5d-49a7ac3a0221.webp)

发布订阅模式：被观察对象与观察者之间可能是 **多对多** 的关系，两者都可以绑定多个另一角色；而两个角色之间还有一个 **依赖收集和管理** 的角色（提供一些观察者的操作方法）。

![img](https://cdn.nlark.com/yuque/0/2023/webp/311219/1696854236713-12eaa3b6-e9ed-4931-bad1-081a3ab0b08b.webp)

**在 Vue 中我们视图中依赖的每一个数据其实就是一个被观察者，我们的视图渲染函数（renderWatcher）和其他的 watcher/effect 函数则都是订阅者**。

当数据改变时，就会发送一个事件去触发我们的观察者进行更新，即视图更新。



### Vue2 中的依赖收集：

1. 在Vue2中，依赖收集是通过Object.defineProperty对数据的get和set方法进行劫持实现的。
2. 当模板中使用到响应式数据时，Vue2会在编译阶段解析模板，将模板中所有的数据访问表达式与对应的Watcher建立联系。
3. Watcher对象负责将模板中的数据和视图进行关联，并且会在数据改变时触发更新。
4. 在初始化阶段，Vue2会为每个组件创建一个Watcher，并在组件渲染过程中进行依赖收集。
5. 在Watcher的get方法中，会将当前的Watcher对象（Dep.target）存储到被访问数据的依赖列表中（Dep）。
6. 当被访问的数据发生变化时，会触发setter方法，通过遍历依赖列表，通知每个依赖的Watcher执行更新操作。

### Vue3 中的依赖收集：

1. 在Vue3中，依赖收集采用了Proxy代理对象的方式实现。
2. 每个组件实例都会有一个Reactive对象，通过Proxy对数据进行劫持，当访问或修改数据时会触发对应的get和set操作。
3. 在访问数据时，Vue3会通过Proxy捕获到访问操作，并将当前的Reactive对象和属性进行关联。
4. 当数据发生变化时，Proxy会触发对应的set操作，通过遍历相关的依赖列表来进行更新。
5. 与Vue2不同，Vue3采用了基于函数的响应式系统，将依赖收集与更新逻辑分离，避免了Watcher对象的创建和管理。

### Vue 中的计算属性是如何收集依赖和进行更新的？

Vue 的计算属性是一种便捷的属性，它的值是基于其他数据或计算属性衍生而来。Vue 能够**自动追踪计算属性所依赖的数据以及对应的更新时机，这是通过依赖收集机制来实现的**。

当计算属性被访问时，Vue 会开始进行依赖收集。具体的依赖收集过程如下：

1. **收集依赖**：在组件渲染过程中，当计算属性被访问时，Vue会将当前正在执行的计算属性添加到一个依赖收集器中（Dep）。
2. **触发依赖**：同时，Vue 还会访问计算属性所依赖的其他数据（例如响应式数据或其他计算属性）。在访问这些数据的过程中，Vue 会将这些数据也添加到同一个依赖收集器中。
3. **建立关联**：Vue 会建立起计算属性与所依赖数据之间的关联关系，使得当所依赖的数据发生改变时，计算属性能够被正确地更新。
4. **派发更新**：当所依赖的数据发生改变时，Vue 会通知依赖收集器中所关联的计算属性，将它们标记为需要重新计算。
5. **重新计算**：在下一次访问计算属性时，如果该计算属性被标记为需要重新计算，Vue 会重新调用计算属性的求值函数来计算新的值，并缓存起来。

### 点题收敛总结

尽管 Vue2 和 Vue3 的依赖收集机制有所差异，但它们都通过劫持数据的访问操作，建立数据与视图的联系。Vue2 使用Object.defineProperty 对数据进行劫持，通过 Watcher 对象进行依赖收集和更新；

而 Vue3 使用 Proxy 代理对象进行劫持，将数据与 Reactive 对象关联，并通过遍历依赖列表进行更新。Vue3 在性能和开发体验上做了一些优化，使得依赖收集更加高效和灵活。

而对于计算属性而言，通过依赖收集机制，使得 Vue 能够自动追踪计算属性所依赖的数据，并在相关数据发生改变时触发计算属性的更新。这样，开发者就无需手动管理计算属性的依赖关系，使得代码更加简洁和易于维护。