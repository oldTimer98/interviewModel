核心点：

1. 理解什么是函数式组件，它解决了什么问题？

1. **特点****：无状态、没有实例**
2. **使用其更多的在于****性能优化****的考虑**

1. 函数式组件在 Vue2.x 与 Vue3 的区别。



## 是什么？

如果一个组件无状态 (没有[响应式数据](https://v2.cn.vuejs.org/v2/api/#选项-数据))，也没有实例 (没有 this 上下文)，我们可以将这种组件标记为 functional，这意味它是一个**函数式组件**，这个组件只接受一些 prop。

并且函数式组件不能调用 Vue 实例方法。**函数式组件在性能方面有一定的优势**，因为它们渲染时不需要创建实例，也不需要进行组件的生命周期钩子函数操作。

举例子：

下面是一个简单的函数式组件的示例代码，在 Vue 2.x 版本中，可以使用 functional: true 来声明一个函数式组件：

```javascript
Vue.component('my-functional-component', {
  functional: true,
  render: function (createElement, context) {
    var props = context.props;
    return createElement('div', props.message);
  },
  props: {
    message: String
  }
});
```

上面的代码创建了一个名为 my-functional-component 的函数式组件，它接收一个 message 属性，并将其显示在一个 <div> 元素中。

render 函数接收两个参数：第一个参数是 createElement 函数，用来创建 VNode；第二个参数是上下文对象，其中包含了组件的一些属性，比如 props，listeners 等等。

最后，要注意在函数式组件中，**由于没有实例，所以不能使用 this 关键字访问组件的属性或方法，而是需要从上下文对象中获取相应的属性和方法**。

### 函数式组件解决了什么问题？

在 Vue 2 中，函数式组件有两个主要用例：

- 作为性能优化，因为它们的初始化速度比有状态组件快得多
- 返回多个根节点

然而，在 Vue 3 中，**有状态组件的性能已经提高到可以忽略不计的程度**。此外，有状态组件现在还包括返回多个根节点的能力。

因此，函数式组件剩下的唯一用例就是简单组件，比如创建动态标题的组件。否则，建议你像平常一样使用有状态组件。

综上，在 Vue2，我们更多的使用函数式组件的目的在于**性能优化**。而如果升级到了 Vue3，函数式组件剩下的唯一用例就是简单组件，比如创建动态标题的组件。



### 函数式组件在 Vue2.x 的实用场景

在 Vue 2 中，函数式组件的主要优势在于其**性能优化和无状态的特性**。下面是一些函数式组件在 Vue 2 中可能实用的场景：

1. 简单的展示组件：函数式组件适用于那些没有复杂交互逻辑、只负责渲染静态内容的组件。比如按钮、图标、标签等简单的 UI 组件。

```javascript
Vue.component('my-button', {
  functional: true,
  render: function (createElement, context) {
    var props = context.props;
    return createElement('button', props.message);
  },
  props: {
    message: String
  }
});
```

1. 高性能列表渲染：函数式组件通常比有状态组件具有更好的性能，特别是在需要渲染大量重复的子组件时。使用函数式组件作为列表项组件，可以提高列表的整体渲染性能。

```javascript
Vue.component('list-item', {
  functional: true,
  render: function (createElement, context) {
    var props = context.props;
    return createElement('li', props.item.text);
  },
  props: {
    item: Object
  }
});
```

1. 插槽（Slot）组件：函数式组件也适合用作插槽组件，尤其是那些只负责将内容插入到指定位置而不进行其他逻辑处理的组件。

```javascript
javascriptCopy CodeVue.component('my-slot-component', {
  functional: true,
  render: function (createElement, context) {
    return createElement('div', context.children);
  }
});
```

1. 高阶组件（Higher-order Components）：函数式组件可以作为高阶组件的一种实现方式，用于将某些共享逻辑应用于多个组件。

```javascript
function withPerformance(Component) {
  return Vue.extend({
    functional: true,
    render: function (createElement, context) {
      var start = performance.now();
      var componentVNode = createElement(Component, context.data, context.children);
      var end = performance.now();
      console.log('Performance:', Component.name, 'took', (end - start).toFixed(4), 'ms to render');
      return componentVNode;
    }
  });
}

Vue.component('my-component', withPerformance({
  name: 'MyComponent',
  props: {
    message: String
  },
  render: function (createElement, context) {
    return createElement('div', context.props.message);
  }
}));
```

上面的示例代码创建了一个名为 withPerformance 的高阶组件，它接收一个普通组件作为参数，然后返回一个新的组件。新组件是一个函数式组件，它记录了被包装组件的渲染耗时，并输出到控制台。

可以通过调用 withPerformance 函数并传入一个组件来生成一个新的组件，如上面的代码所示。新组件会自动记录被包装组件的渲染耗时，以便进行性能监控和优化。

需要注意的是，由于函数式组件没有实例，无法使用 Vue 实例的生命周期钩子函数和实例方法。因此，在高阶组件中需要使用 Vue.extend 方法来创建一个新的包含生命周期钩子函数和实例方法的“虚拟”组件。

## 函数式组件在 Vue2.x 与 Vue3 的区别

写法上的差异：

在 Vue 3 中，所有的函数式组件都是用普通函数创建的，换句话说，不需要定义 { functional: true } 组件选项。

他们将接收两个参数：props 和 context。context 参数是一个对象，包含组件的 attrs，slots，和 emit property。

此外，现在不是在 render 函数中隐式提供 h，而是全局导入 h。

```javascript
import { h } from 'vue';

const DynamicHeading = (props, context) => {
  return h(`h${props.level}`, context.attrs, context.slots);
}

DynamicHeading.props = ['level'];

export default DynamicHeading;
```

另外，函数式组件在 Vue3.x 相对 2.x 的变化：

- 在 3.x 中，函数式组件的性能提升可以忽略不计，因此我们建议**只使用有状态的组件**
- 函数式组件只能使用接收 props 和 context 的普通函数创建 (即：slots，attrs，emit)。
- **非兼容变更：**functional attribute 在单文件组件 (SFC) <template> 已被移除
- **非兼容变更：**{ functional: true } 选项在通过函数创建组件已被移除

在 Vue 2 中，函数式组件有两个主要用例：

- 作为性能优化，因为它们的初始化速度比有状态组件快得多
- 返回多个根节点

然而，在 Vue 3 中，有状态组件的性能已经提高到可以忽略不计的程度。此外，有状态组件现在还包括返回多个根节点的能力。

因此，函数式组件剩下的唯一用例就是简单组件，比如创建动态标题的组件。否则，建议你像平常一样使用有状态组件。