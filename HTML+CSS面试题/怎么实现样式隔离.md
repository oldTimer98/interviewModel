## 视频讲解： 

此处为语雀视频卡片，点击链接查看：[怎样实现样式隔离.mp4](https://www.yuque.com/u1598738/zqco83/ripvh3zsowpm4g4d#DevRg)

##  是什么

样式隔离（CSS Isolation）旨在避免不同组件或模块间的 CSS 样式相互影响，这种技术有助于维护样式的一致性和可预测性，因此在开发大型应用(特别是微前端项目)或组件库时尤为重要。



## 为什么

- 全局污染：原生CSS不支持局部作用域，容易出现全局冲突，特别在当前 spa、微前端 盛行的情况下，多人同时开发一个应用时，如果没有规则限制，很容易出现样式冲突
- 层叠混乱：并且css支持层叠，即使冲突了也没法很快知道
- 依赖管理混乱：并且，你很难知道某个样式规则被哪些地方用到，随着项目的发展你可能会积累一堆实际已经没用，但不敢删除的样式规则([append-only stylesheets](https://css-tricks.com/oh-no-stylesheet-grows-grows-grows-append-stylesheet-problem/))

- 性能差、维护成本高

- 引入顺序、组件嵌套，都可能导致样式冲突
- 怎么做：BEM、CSS modules、CSS Layer、css-in-js(styled-component)、web component、iframe、vue-scoped



## 方案拆解

### BEM命名规则

使用简单，可读性强（Block）、元素（Element）、修饰符（Modifier): `article--header__black`

- 缺点是依赖开发者遵循命名规则，容易出问题；依然有命名成本，需要小心规避不出现冲突，可能导致命名会特别长
- 包括 antd 之类的组件库，至今依然使用类似 bem 的命名规则



### CSS Modules

这也是一种流行的样式隔离技术，它通过将类名转换为唯一的局部作用域名来避免冲突。

- 实现：模块化的 css 文件，这是一种在构建时添加 scope 信息的工程化手段，例如使用 css-loader 并设置 `modules=true`，在构建过程中，每个 CSS 类名都被转换成一个包含文件名和哈希值的唯一标识符，这使得类名在全局范围内唯一，从而防止样式冲突。
- 优点：简单易用，能够用工具替代规范约束；能够复用一堆 css 预处理器
- 缺点：依赖构建工具，可能影响构建速度；最终代码可读性差，debug 成本高；[css-modules](https://github.com/css-modules/css-modules) 能力比较弱，不支持变量等，通常需要配合 less 等预处理器使用

```javascript
.title {
  color: red;
}

._3zyde4l1yATCOkgn-DBWEL {
  color: red;
}
```



### CSS-IN-JS

指的是一种将 CSS 直接嵌入到 JavaScript 中的模式，常用于现代 JavaScript 框架和库，如 React。

![img](https://cdn.nlark.com/yuque/0/2022/png/26698409/1661669838390-eff70638-fb52-4455-95b7-0889381fb289.png)

- 实现：把样式代码直接写在组件中，并最终生成为 style 代码 +  **唯一选择器**，插入页面；或生成行内样式，插入组件标签中

1. 局部作用域：在 CSS-in-JS 中，样式默认是局部作用域的，这意味着样式直接绑定到特定的组件上，而不会泄露到全局环境中。每个组件的样式都是独立的，从而避免了不同组件间的样式冲突。
2. 自动生成类名：大多数 CSS-in-JS 库会自动生成唯一的类名，这些类名通常包含随机或哈希值，以确保全局唯一性。这种机制保证了即使在不同的组件中使用了相同的类名，它们也不会相互影响。

- 优点：可选择工具非常多 styled-componets、vanilla-extract 等；样式与组件强相关，不太会造成历史遗留代码问题；
- 缺点：大多数都是运行时生成样式代码，运行时开销大(运行时代码 + 动态生成)；代码可读性差，不容易 debug；不能复用成熟的预处理工具；

```javascript
import React from 'react';
import styled from 'styled-components';

// 创建一个带样式的 div 组件
const StyledDiv = styled.div`
  background-color: palevioletred;
  color: white;
  padding: 10px;
  border-radius: 5px;
  margin: 10px 0;
  text-align: center;
`;

function MyStyledComponent() {
  return (
    <StyledDiv>
      这是一个样式化的 div!
    </StyledDiv>
  );
}

export default MyStyledComponent;
// 假设为样式化组件生成的类名为 "sc-123xyz"
var StyledDiv = styled.div.withConfig({ displayName: "StyledDiv", componentId: "sc-123xyz" })`
  /* CSS 内容被转换为 JavaScript 对象 */
`;

function MyStyledComponent() {
  return /*#__PURE__*/React.createElement(StyledDiv, null, "这是一个样式化的 div!");
}

// 在客户端运行时，StyledDiv 组件会有一个类似 "sc-123xyz" 的类名
// 并且相应的 CSS 会被注入到 <style> 标签中
```



### iframe

iframe（内联框架）可以在当前文档中嵌入另一个独立的 HTML 文档，这个嵌入的文档拥有自己完全独立的文档对象模型（DOM）、全局作用域、样式和脚本环境等。

- 优点：严格意义的样式与内容隔离，在 iframe 内部定义的 CSS 和 JavaScript 完全独立于包含它的父页面。这意味着 iframe 内部的样式不会影响到外部页面，反之亦然。
- 缺点很多：iframe 太重，成本略高，除微前端场景外不建议使用

- **性能开销**：每个 iframe 都是一个完整的文档环境，这可能导致额外的性能开销，尤其是在页面中嵌入了多个 iframe 的情况下。
- 复杂的通信机制：父页面与 iframe 内容之间的通信比较复杂，需要通过 postMessage API 或其他机制来实现。
- SEO 和可访问性影响：iframe 中的内容可能不会被某些搜索引擎索引，同时也可能对屏幕阅读器等辅助技术造成影响。
- 跨域限制：当 iframe 加载的是跨域资源时，会受到同源策略的限制，这可能限制了父页面与 iframe 内容之间的交互。



### web component

用于封装html结构、js逻辑、样式结构的浏览器原生 api，能够有效隔离 web component 与页面代码

- 原理：得益于其 **Shadow DOM** 的特性，Web Component 内部可以创建一个封闭的 DOM 环境，内部定义的样式不会泄露到外部，同样外部的样式也不会影响到 Shadow DOM 内部。这意味着你可以为 Web Components 定义专属样式，而不用担心与页面上的其他元素发生样式冲突：

```javascript
<!DOCTYPE html>
<html>
<head>
    <title>My Custom Element with Style Isolation</title>
    <style>
        .wrapper {
            color: red;
            background: yellow;
        }
    </style>
</head>
<body>
    <div class="wrapper">这是外部的元素，应用了外部样式</div>
    <my-custom-element></my-custom-element>

    <script>
        class MyCustomElement extends HTMLElement {
            constructor() {
                super(); // 总是首先调用 super() 构造函数

                // 创建一个 shadow root
                const shadow = this.attachShadow({ mode: 'open' });

                // 添加一些 HTML 内容到 shadow root
                const wrapper = document.createElement('div');
                wrapper.setAttribute('class', 'wrapper');
                wrapper.textContent = '这是我的自定义元素内容!';

                // 在 Shadow DOM 中定义样式
                const style = document.createElement('style');
                style.textContent = `
                    .wrapper {
                        color: white;
                        background: blue;
                        padding: 10px;
                        border-radius: 8px;
                    }
                `;

                // 将样式和元素附加到 shadow DOM
                shadow.appendChild(style);
                shadow.appendChild(wrapper);
            }
        }

        // 定义新的元素
        customElements.define('my-custom-element', MyCustomElement);
    </script>
</body>
</html>
```

- 优点：浏览器原生支持；严格意义上的样式隔离，与 iframe 效果差不多；
- 缺点：

- **兼容性问题**：虽然现代浏览器大多支持 Web Components，但仍存在一些兼容性问题，特别是在老旧的浏览器（如早期的 Internet Explorer）中。这可能需要额外的工作来保证跨浏览器的一致性。
- **学习曲线**：对于未熟悉 Web Components 的开发者来说，学习如何正确使用它们可能需要时间。这包括理解 `Shadow DOM、Custom Elements 和 HTML Templates` 的使用和最佳实践。
- **工具链集成**：虽然 Web Components 可以与现代前端工具链一起使用，但它们的集成可能不如一些流行的前端框架（如 React、Vue）那么平滑和广泛。
- **样式共享限制**：由于 Shadow DOM 的封闭性，从外部共享样式到 Web Component 内部可能比较困难。需要使用 CSS 变量、<slot> 元素或其他方法来实现样式共享。
- **性能考虑**：在某些情况下，大量使用 Web Components 可能对性能有一定影响，尤其是在创建和销毁大量组件的场景中。虽然这通常不是问题，但在性能敏感的应用中需要考虑。
- **样式管理**：在使用 Web Components 时，由于每个组件都有自己的 Shadow DOM，因此管理和维护项目级别的统一样式可能更加复杂。
- **社区和生态系统**：相比于一些流行的前端框架，Web Components 社区和生态系统可能没有那么丰富和成熟。这可能影响到可用资源、学习材料和社区支持。



### Vue Scoped

vue  sfc 提供的样式隔离手段

- 优点：简单，且支持 deep 等指令后，能够实现子组件的样式效果；配合 sfc 规则，样式结构更清晰
- 缺点：只适用于 vue 框架；只适用于组件级别的样式定义

```javascript
<style scoped>
.example {
  color: red;
}
</style>

<template>
  <div class="example">hi</div>
</template>

<style>
.example[data-v-f3f3eg9] {
  color: red;
}
</style>

<template>
  <div class="example" data-v-f3f3eg9>hi</div>
</template>
```



### css 新 @layer 规范

`@layer` 旨在改进 CSS 的层级管理和冲突解决，它提供了一种新的方法来组织和管理样式表中的样式规则：对于处在不同层中的样式，无视样式本身的权重，后声明的层中的样式优先级更高，不在层中的样式优先级最高。

使用 `@layer` 的主要优势在于它允许开发者显式地定义样式规则的层级（layers），这有助于管理大型样式表中的层叠和继承问题。在复杂的项目中，不同来源的样式（如第三方库、框架、自定义样式等）可能会产生冲突。`@layer` 规范通过提供一种方式来组织这些样式，使得管理和维护变得更加简单。

```javascript
@layer framework, components, themes;

@layer framework {
  /* 第三方框架样式 */
  ....
}

@layer components {
  /* 组件样式 */
}

@layer themes {
  /* 主题样式 */
}
```

注意实例第一行代码 `@layer framework, components, themes;`，这个顺序决定了各个层中定义的样式规则的层叠顺序，越往后的层优先级越高。



- 优点：

- `**更好的组织性**`：@layer 允许将样式分组到不同的层中，使得代码更加有序和可维护，特别是在大型项目中。
- **官方规范**：这是一个浏览器原生支持的隔离方案，逻辑上不需要再引入其它复杂的工程化工具即可实现，整体会更有保障一些；
- **明确的层叠控制**：通过定义层的顺序，开发者可以更清楚地控制哪些样式会覆盖其他样式，减少了意外覆盖的情况。
- **模块化**：可以将特定的样式集中到独立的层中，有助于样式的模块化和重用。
- **简化维护**：每个层可以单独维护和更新，这使得管理大量样式规则变得更简单。
- **提高性能**：理论上，通过使用 @layer，浏览器可以更高效地处理样式表，特别是在启用或禁用特定层的样式时。

- 缺点：

- **兼容性问题**：截至 2023 年，@layer 规范尚未在所有浏览器中得到广泛支持。因此，在不支持该特性的浏览器中，使用 @layer 可能会遇到兼容性问题。
- **调试困难**：在一些开发工具中，可能不容易直观地看到不同层之间的层叠关系，这可能使调试变得更加困难。