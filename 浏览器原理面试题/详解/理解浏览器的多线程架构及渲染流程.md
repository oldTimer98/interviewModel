## 浏览器中主要的 5 大进程

- 浏览器进程：负责界面显示、用户交互、子进程管理、提供储存等。
- 渲染进程：每个 tab 都有单独的渲染进程，核心用于渲染页面。
- 网络进程：主要处理网络资源加载（html、css、js等）。
- GPU进程：3D 绘制，提高性能。
- 插件进程：Chrome 中安装的一些插件。

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1693713492778-08e14377-6691-4e8b-983c-88e7655d6cc6.png)

通常，我们打包出来的 HTML、CSS、JavaScript 等文件，经过浏览器运行之后就会显示出页面，这个过程就是浏览器的渲染进程来操作实现的，渲染进程的主要任务就是**将静态资源转化为可视化界面：**

![img](https://cdn.nlark.com/yuque/0/2023/webp/311219/1693713257991-9a5ae099-916d-4539-9694-af43f06e3028.webp)

### 浏览器多进程的优势

相比于单进程浏览器，多进程有如下优点：

- 避免单个page crash影响整个浏览器
- 避免第三方插件crash影响整个浏览器
- 多进程充分利用多核优势
- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

简单点理解：**如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。**

当然，内存等资源消耗也会更大，有点空间换时间的意思。

### 梳理浏览器内核中线程之间的关系

到了这里，已经对浏览器的运行有了一个整体的概念，接下来，先简单梳理一些概念

#### GUI渲染线程与JS引擎线程互斥

由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。

因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。

#### JS阻塞页面加载

从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。

譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。 然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。

所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

#### WebWorker，JS的多线程？

前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？

所以，后来HTML5中支持了Web Worker。

MDN的官方解释是：

```plain
js
复制代码Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面

一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件 

这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window

因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误
```

这样理解下：

- 创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）
- JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）

所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程， 只待计算出结果后，将结果通信给主线程即可，perfect!

而且注意下，**JS引擎是单线程的**，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。

其它，关于Worker的详解就不是本文的范畴了，因此不再赘述。

#### WebWorker与SharedWorker

既然都到了这里，就再提一下SharedWorker（避免后续将这两个概念搞混）

- WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享

- 所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。

- SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用

- 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。

看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程



## 渲染进程详解

重点来了，我们可以看到，上面提到了这么多的进程，那么，对于普通的前端操作来说，最终要的是什么呢？答案是**渲染进程。**

可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。

**请牢记，浏览器的渲染进程是多线程的。**

那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）：

1. GUI渲染线程

- 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
- 注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中**等到JS引擎空闲时**立即被执行。

1. JS引擎线程

- 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
- JS引擎线程负责解析Javascript脚本，运行代码。
- JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
- 同样注意，**GUI渲染线程与JS引擎线程是互斥的**，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

1. 事件触发线程

- 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
- 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
- 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

1. 定时触发器线程

- 传说中的setInterval与setTimeout所在线程
- 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
- 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
- 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。

1. 异步http请求线程

- 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
- 将检测到状态变更时，如果设置有回调函数，异步线程就**产生状态变更事件**，将这个回调再放入事件队列中。再由JavaScript引擎执行。

看到这里，如果觉得累了，可以先休息下，这些概念需要被消化，毕竟后续将提到的事件循环机制就是基于事件触发线程的，所以如果仅仅是看某个碎片化知识， 可能会有一种似懂非懂的感觉。要完成的梳理一遍才能快速沉淀，不易遗忘。

可通过这张图巩固记忆：

![img](https://cdn.nlark.com/yuque/0/2023/webp/311219/1693906120421-e00dd090-e71b-4eb4-9101-55fb4712a3a7.webp)

## 首次渲染

对于中间的浏览器，它就是一个黑盒，下面就来看看这个黑盒是如何将静态资源转化为前端界面的。由于渲染机制比较复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的静态资源经过这些子阶段，最后输出页面。我们将一个处理流程称为渲染流水线，其大致流程如下图所示：

![img](https://cdn.nlark.com/yuque/0/2023/webp/311219/1693713257953-c093458c-4dd9-4834-ae6b-7fcbd11eee88.webp)

大致的渲染流程如下：

- 1、浏览器无法直接使用HTML，需要将HTML转化成DOM树（document）
- 2、浏览器无法解析纯文本的css样式，需要对css进行解析，解析成styleSheets（document.styleSheets）
- 3、计算出DOM树中每个节点的具体样式（Attachment）
- 4、创建渲染（布局）树，将DOM树中可见节点添加到布局树中。并计算节点渲染到页面的坐标位置（layout）
- 5、通过布局树进行分层（根据定位属性，透明属性，transform属性，clip属性等）生成图层树
- 6、将不同图层进行绘制，转交给合成线程处理。最终生成页面，并显示到浏览器上（painting,Display）

对于这五个流程，每一阶段都有对应的产物，分别是：**DOM树、CSSOM树、渲染树、盒模型、界面。**

下图为渲染引擎工作流程中各个步骤所对应的模块：

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1693713564665-bc98cef0-20ac-4890-9442-10664b90ab10.png)

从图中可以看出，渲染引擎主要包含的模块有：

- **HTML解析器**：解析HTML文档，主要作用是将HTML文档转换成DOM树；
- **CSS解析器**：将DOM中的各个元素对象进行计算，获取样式信息，用于渲染树的构建；
- **JavaScript解释器**：使用JavaScript可以修改网页的内容、CSS规则等。JavaScript解释器能够解释JavaScript代码，并通过DOM接口和CSSOM接口来修改网页内容、样式规则，从而改变渲染结果；
- **页面布局**：DOM创建之后，渲染引擎将其中的元素对象与样式规则进行结合，可以得到渲染树。布局则是针对渲染树，计算其各个元素的大小、位置等布局信息。
- **页面绘制**：使用图形库将布局计算后的渲染树绘制成可视化的图像结果。

例子1

```html
<head>
  <!-- css不会阻塞HTML即系 --> 
  <link rel="stylesheet" href="./index.css">
</head>
<body>
  <!-- 浏览器可以部分渲染 -->
  <!-- 在渲染dom时，需要等待样式加载完成 -->
  <div></div>
  <!-- 需要css tree 和dom tree 构成布局树 ->
  <!-- css阻塞页面渲染 -->
  <!-- parserHTML -> parserStyleSheet -> updateLayerTree -> paint -->
</body>
```

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1693713653531-d33270c2-1659-42c5-9aa0-f8d175acd9a7.png)

例子2

```html
<body>
  <!-- 浏览器可以部分渲染 -->
  <div></div>
  <!-- 如果放在这，可能会发生重绘，甚至回流 -->
  <!-- 当html渲染时，会先扫描(预加载)js和css 渲染从上到下，边解析边渲染 -->
  <!-- 浏览器会先渲染了div，然后解析完下面这个链接后，再渲染一次div -->
  <link rel="stylesheet" href="./index.css">
</body>
```

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1693713653600-5429ae21-3cb0-4101-ac62-c223abf58ba9.png)

例子3

```html
<head>
  <link rel="stylesheet" href="./index.css">
</head>
<body>
  <!-- 浏览器可以部分渲染 -->
  <div>hello</div>
  <!-- js会阻塞dom的解析，需要暂停DOM解析去执行js -->
  <!-- js可能会操作样式，所以需要等待样式加载完成 -->
  <script>
    let s = 0;
    for (let i = 0; i < 100000000; i++) {
      s += i;
    }
  </script>
  <!-- 继续加载 -->
  <div>world</div>
</body>
```

script会阻塞html的解析以及这个script到上一个script之间的html结构的渲染。

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1693713653565-221ce766-d838-4050-b808-434d665bf42f.png)

## 关键渲染路径

理解关键渲染路径 -- [关键渲染路径](https://developer.mozilla.org/zh-CN/docs/Web/Performance/Critical_rendering_path)。

**关键渲染路径**是浏览器将 HTML，CSS 和 JavaScript 转换为屏幕上的像素所经历的步骤序列。优化关键渲染路径可提高渲染性能。关键渲染路径包含了 [文档对象模型](https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model)(DOM)，[CSS 对象模型](https://developer.mozilla.org/zh-CN/docs/Web/API/CSS_Object_Model) (CSSOM)，渲染树和布局。

在解析 HTML 时会创建文档对象模型。HTML 可以请求 JavaScript，而 JavaScript 反过来，又可以更改 DOM。HTML 包含或请求样式，依次来构建 CSS 对象模型。浏览器引擎将两者结合起来以创建渲染树。布局确定页面上所有内容的大小和位置。确定布局后，将像素绘制到屏幕上。

优化关键渲染路径可以缩短首次渲染的时间。了解和优化关键渲染路径对于确保重排和重绘可以每秒 60 帧的速度进行，以确保高效的用户交互并避免[卡顿](https://developer.mozilla.org/zh-CN/docs/Glossary/Jank)是很重要的。

通常而言，关键渲染路径对应如下的渲染步骤图：

![img](https://cdn.nlark.com/yuque/0/2023/jpeg/311219/1693713913214-e5d28fd3-0cbc-4f40-9d5c-0ae33748857a.jpeg)

- JavaScript：一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如做一个动画或者往页面里添加一些 DOM 元素等。
- Style：计算样式，这个过程是根据 CSS 选择器，对每个 DOM 元素匹配对应的 CSS 样式。这一步结束之后，就确定了每个 DOM 元素上该应用什么 CSS 样式规则。
- Layout：布局，上一步确定了每个 DOM 元素的样式规则，这一步就是具体计算每个 DOM 元素最终在屏幕上显示的大小和位置。web 页面中元素的布局是相对的，因此一个元素的布局发生变化，会联动地引发其他元素的布局发生变化。比如， 元素的宽度的变化会影响其子元素的宽度，其子元素宽度的变化也会继续对其孙子元素产生影响。因此对于浏览器来说，布局过程是经常发生的。
- Paint：绘制，本质上就是填充像素的过程。包括绘制文字、颜色、图像、边框和阴影等，也就是一个 DOM 元素所有的可视效果。一般来说，这个绘制过程是在多个层上完成的。
- Composite：渲染层合并，由上一步可知，对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。

在页面性能优化的技巧中，大家一定听过，尽可能的减少页面的重绘和重排。

上面的 Layout，也就是对应浏览器渲染过程中的重排的过程，而 Paint，对应的就是重绘的过程，而 Composite 就是最后的渲染层合并。

对于页面的每一帧渲染（或者理解为动画渲染）其实也是一样，我们可以来看这么一张图：

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1693714094509-21ce420a-3723-456d-9f56-f5f82f8529f0.png)

我们把上面页面的每一帧渲染过程，想象成一个金字塔。而如果我们改变了底部的某些东西，金字塔就必须从底部开始重建。

什么意思呢？在某一帧中，如果只有元素的 Paint，那么只需要经历 Paint --> Composite 的过程。

而如果有元素的 Layout，则页面需要经历 Layout --> Paint --> Composite 的过程。

而如果我们能寻找到只有 Composite 变换的渲染，则页面无需经历 Paint 和 Layout，此时页面是渲染性能就是最好的！

因此**，我们想要高性能的** **CSS** **动画，也是需要尽可能的减少页面的重排与重绘！**

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1693714079733-46ec475c-0875-4b39-8144-3f160ab2392f.png)

举个例子，我们想改变一个物体的显示与隐藏的切换，下面哪一种方式是更好的选择：

- display: block 与 display: none 的切换
- opacity: 0 与 opacity: 1 的切换

对于 display: block 与 display: none 的切换，是会引起页面的重排（Layout），而 opacity 的变换，仅仅只会导致页面的 Composite（有一些浏览器可能是 Paint + Composite），因此，opacity 方案是更好的选择。

### Layout

- **生成每个元素的几何形状和位置**
- **非常消耗性能****，因为渲染引擎必须重新考虑相关元素及其所有子元素后，才能计算新的布局**
- **当操作 DOM 树、影响布局的样式、更改浏览器窗口大小、ClassName 属性更改时会发生 Layout**

会触发 Layout 的 CSS 属性：

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1693714145898-0a5712b7-fc97-4aaf-8e34-685a8e558de9.png)

### Paint

- **将每个元素的像素绘制到不同的层中**
- **渲染引擎遍历所有元素以****确定可见的内容和应显示的内容****（十分消耗性能）**
- **绘制文字、添加轮廓（outline）、阴影（shadow）或更改背景颜色（background）**

会触发 Layout 的 CSS 属性：

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1693714185146-f752ee10-2479-46cb-893d-186fc4bab913.png)

### Composite

- **只有不透明度****（opacity）****以及变换****（transform）****只触发 Composite**
- **Blink 和 Webkit 内核为 CSS transform 和 opacity 创建了新的层（****Graphics Layers****）**
- **translatez(0) 用于强制创建层（****Graphics Layers****），该层在动画启动后会立即进行绘制**
- **通过** [The Web's Black Magic](https://www.youtube.com/watch?v=9rizDPIIYEY)**，了解** **rendering** **和** **compositing** **的最佳解释**



##   