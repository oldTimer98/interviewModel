## 基础

- 浏览器渲染时会将 dom、cssom 合并成 renderObject 树，之后按特定规则将 renderObject 树拆分为多个 render layer —— 渲染层，实现分层渲染(每一层都是 renderObject 树的一部分)

- 特殊：translatez、opacity、canvas、video 等

- 分层渲染能大大优化渲染性能：

- 不会因为局部小量更新导致全局重绘；
- 部分特性可以只在渲染层执行重绘，例如 transform、opacity，不需要重排、重绘

- 分层后，每一个 Render Layer 会生成一个独立渲染位图，浏览器需要按正确的顺序将其合并成一张图，绘制到屏幕上

## 进阶

### 浏览器渲染流程

![img](https://cdn.nlark.com/yuque/0/2022/png/26698409/1658046579572-e6146e27-c80f-4157-a788-453b377110b0.png)

渲染过程大致可分为：Network => Parse => Render(style, layout, paint, 有时候还有合成  compositing) 阶段：

- Parse

- html => dom tree
- css => Style Rules(CSSOM)

- Render

- style：计算节点样式属性，生成 render Tree

- DOM + CSSOM => RenderObject => Render Tree
- Render Tree 中只包含需要渲染 or 布局的元素，如 `display: none` 或 script、head 等标签不会出现；但 `visibility: hidden` 会出现

- Layout：根据屏幕 viewport 与 render Object 的盒子属性，计算每一个 Render Object 节点的位置、宽高

- 注意：如果遇到无法计算宽高的节点(如图片)，会补充一个占位区域

- Paint：根据 layout 计算出的逻辑布局以及 render tree 的样式信息，计算各个节点的位图效果；这里为了提升渲染效率，会选择将渲染任务拆解成多个，形成 render Layer

- 每一个触发分层的节点，以及该节点的子孙节点都划分为一个 render Layer；render Layer本身也会形成一颗树壮结构；
- ![img](https://cdn.nlark.com/yuque/0/2022/png/26698409/1658045972230-c9b1b6c9-3a74-4163-b966-b1f24fc71087.png)
- 触发分层(简单理解)：

- document
- video、canvas 标签
- will-change、translateZ、opacity
- index 比 renderlayer 层大的元素，会触发隐式合成层
- chrome96 后对分层规则做了很多复杂的优化，不过大致上还是遵守上述逻辑

- 为什么要切割：

- 有利于改善频繁变更元素的渲染效果：video、canvas
- 单层频繁变更不会影响其它层，能够减少全局重新布局、重绘的次数
- 开启硬件加速后，可以以 render layer 为单位将部分计算任务发送到 GPU，实现硬件加速
- 部分样式效果可以直接在 render layer 实现，不会触发重排、重绘，如：transform、opacity

- 副作用：巨大的内存消耗，特别在过去有一种隐式合成层带来的所谓的“层爆炸”问题

- Composition：调用合成器线程(compositor)，将 render layer 按正确顺序合并成最终渲染效果

- render layer 传递到 compositor 后，某些特殊的渲染层会被创建为合成层（Compositing Layers），这部分 layer 会被传递到 GPU 处理；只有下述情况下会创建独立 compositing layer

- compositing layer 包含 3D 或 perspective transform CSS 属性；
- 包含启动了加速解码功能的 video
- 包含 3d 或 2d 加速 context 的canvas
- 包含 transform 或 opacity 动画
- 包含 css 滤镜
- 父级 compositing layer

- 接下来需要将多个 Compositing layer 合并成 GraphicsLayer

- 由于 GraphicsLayer 占用一套完整的上下文接口和数据，占用内存较大，所以浏览器会尽量控制 GraphicsLayer 的数量
- GraphicsLayer 之间也形成了树壮结构

- GraphicsLayer 负责将合成层的位图合并在一起，并最终显示到界面上

- 总结一下，有4种树状结构：

- DOM
- RenderObject tree：与 dom 树的可视元素一一对应；树节点 render object 包含内容与样式规则，以及渲染指令
- RenderLayer tree：由 RenderLayer 组成的树；RenderObject 树在遇到特定规则时会将某节点提升为单独的 RenderLayer 对象，所以 renderLayer 对应到 RenderObject 子树；在合成阶段，RenderLayer 传递到 compositor 后会被表达为 Compositing Layer
- GraphicsLayer tree：mapping GraphicsLayers one-to-many RenderLayers.
- ![img](https://cdn.nlark.com/yuque/0/2022/png/26698409/1658048762893-d3646c8b-c77f-4c00-a9e1-88c17afb9104.png)

### 性能优化

主渲染过程主要用到两个线程：

- 渲染线程：负责style、layout、
- 合成器线程：

在这个过程中，可做的性能优化有：

- 注意管理 z-index 值，避免隐式合成带来的 render layer 层爆炸，[参考](https://docs.google.com/presentation/d/1WOhbWLkhMyo4vZUaHq-FO-mt0B2sejXw-lMwohD5iUo/edit#slide=id.g2a8a2080a_088)
- 可以主动将一些频繁变动的元素提升为 compositing layer，例如使用 will-change
- 尽量为图像元素补充宽高属性，可以避免图像加载带来的重排
- 使用 transform 替代 top/left 等，因为 transform 的变换发生在 renderLayer 层，不需要经过前置 layout 等操作



资料：

- https://segmentfault.com/a/1190000014520786
- https://zhuanlan.zhihu.com/p/451219118
- https://web.dev/stick-to-compositor-only-properties-and-manage-layer-count/
- https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#render
- https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome



## J



## 