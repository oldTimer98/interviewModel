要理解 Composite Layers，首先来看一个非常重要概念，浏览器的 Layer Border。

首先，我们构建一个非常简单的 DEMO，上下两个 DIV，以不同的方式向右侧运动：

1. divA 使用 left 向右侧进行动画
2. divB 使用 transfrom: translate() 向右侧进行动画

简单的代码如下：

```plain
<div></div>
<div></div>
```

可以得到这样一种，两个 div 元素的向右运动动画：

![img](https://cdn.nlark.com/yuque/0/2023/gif/311219/1693712834162-7d88cd3f-1504-445f-ab98-659d732763fe.gif)

这样一看没有什么特殊的。

接下来，我们打开 Chrome 开发者工具，点击右上角的三个小点，选择 More tools，选择 Rendering，最后，勾选上前面三个选项（Chrome > More tools > Rendering）：

1. Paint flashing
2. Layout Shift Regions
3. Layer borders

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1693712834120-cbc9cdf8-5f54-489f-9c27-9cb4e450297e.png)

此时，再观察我们的两个 div 元素，就会出现不一样的效果：

![img](https://cdn.nlark.com/yuque/0/2023/gif/311219/1693712834281-91c6639f-90de-49c6-a86c-8106bd06bcf6.gif)

分析一下上面的效果，有几处是我们需要注意的：

1. 上方的 div 元素，周围有一圈绿色的边框，而下方的 div，周围有一圈黄色的边框
2. 上方的 div 在移动的过程中，一直存在绿色区域，表示其一直处于重绘中（Paint flahing）
3. 上方的 div 在动画结尾处，回归原位时，会触发一次蓝色区域，这表示其触发了一次重排（Layout）

我们再来看一次我们勾选的三个选项：

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1693712834254-15f6ae69-827a-4ebf-9088-a9bf2784a5d3.png)

先说结论，上述使用 transform: translate3d() 进行位移的元素，其在运动过程中不会触发页面的重绘重排，只有页面的 Composite 的过程！

这就非常有意思了，这里有一个非常非常重要的概念 -- Composite Layers 与 GraphicsLayer。

**简单来说，浏览器为了提升动画的性能，为了在动画的每一帧的过程中不必每次都重新绘制整个页面。在特定方式下可以触发生成一个合成层（Composite Layers），合成层拥有单独的 GraphicsLayer。**

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1693712834391-da7577ec-ac9b-4507-a95b-22673ba5e662.png)

需要进行动画的元素包含在这个合成层之下，这样动画的每一帧只需要去重新绘制这个 GraphicsLayer 即可，从而达到提升动画性能的目的。

如果我们想尽可能的优化我们的 CSS 动画，或者在日常 CSS 开发中，尽可能的提升 CSS 的性能，这是一个非常重要的概念。**通过生成独立的 GraphicsLayer，让此层内的重绘重排不引起整个页面的重绘重排。**

这也就是我们常说的，CSS 3D 硬件加速的最本质的原因。

那么一个元素什么时候会触发创建一个 Graphics Layer 层？

从目前来说，满足以下任意情况便会创建层：

- 硬件加速的 iframe 元素（比如 iframe 嵌入的页面中有合成层）
- 硬件加速的插件，比如 flash 等等
- 使用加速视频解码的
- 3D 或者 硬件加速的 2D Canvas 元素
- 3D 或透视变换(perspective、transform) 的 CSS 属性
- 对自己的 opacity 做 CSS 动画或使用一个动画变换的元素
- 拥有加速 CSS 过滤器的元素
- 元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)
- 元素有一个 z-index 较低且包含一个复合层的兄弟元素

因此，通常最为常见的创建一个复合层的方式就是：

1. transform
2. opacity
3. filter（使用频率较低）

我们可以通过合理的使用这几个元素，有效提升页面的性能，譬如**使用 transform 代替 left、top，实现位移动画。**

## 什么是 GPU 渲染加速？

GPU 渲染加速除了与上面的内容紧密相连外，还需要了解另外一个非常有意思的属性 -- **will-change**。

根据 MDN，属性 will-change 为 web 开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。

譬如：

```css
.sidebar {
  will-change: transform;
}
```

这会使声明了该样式属性的元素生成一个图形层，告诉浏览器接下来该元素将会进行 transform 变换，让浏览器提前做好准备。

是的，这个属性是 CSS 中，除了 transform: translateZ(0) 外，**另外一种强制开启硬件加速的方式。**

通常，我们有两种，强制可以让元素开启硬件加速的方式。

1. transform: translateZ(0)
2. will-change: transform;

如何更好的理解硬件加速？我尝试讲讲我的理解。

当我们使用 transform 和 opacity 对元素进行动画时，浏览会尝试优化这段动画。浏览器将所有内容作为纹理（texture）传输到 GPU，而不是对每一帧上的像素进行光栅化。GPU 非常擅长执行此类基于纹理的转换，因此，我们得到了非常流畅、高性能的动画，这称为“硬件加速”。

而有趣的是，GPU 和 CPU 的对页面的渲染效果略有不同。当 CPU 将渲染任务交给 GPU 时，我们有时会看到页面动画会有一些轻微的变化。（譬如动画的抖动）

而此时，will-change 就非常适合成为 GPU 和 CPU 之间的桥梁。通过 will-change 属性，提前告知浏览器，让浏览器提前做好准备。

当然，通过将元素的渲染委托给 GPU，它将消耗更多的内存资源，而这种资源是有限的，尤其是在低端移动设备上。

因此，想使用好 will-change 属性并不是很容易：

- 在一些低端设备上，will-change 会导致很多小问题，譬如会使图片模糊，有的时候很容易适得其反，所以使用的时候还需要多加测试。
- 不要将 will-change 应用到太多元素上：浏览器已经尽力尝试去优化一切可以优化的东西了。有一些更强力的优化，如果与 will-change 结合在一起的话，有可能会消耗很多机器资源，如果过度使用的话，可能导致页面响应缓慢或者消耗非常多的资源。
- 有节制地使用：通常，当元素恢复到初始状态时，浏览器会丢弃掉之前做的优化工作。但是如果直接在样式表中显式声明了 will-change 属性，则表示目标元素可能会经常变化，浏览器会将优化工作保存得比之前更久。所以最佳实践是当元素变化之前和之后通过脚本来切换 will-change 的值。
- 不要过早应用 will-change 优化：如果你的页面在性能方面没什么问题，则不要添加 will-change 属性来榨取一丁点的速度。 will-change 的设计初衷是作为最后的优化手段，用来尝试解决现有的性能问题。它不应该被用来预防性能问题。过度使用 will-change 会导致生成大量图层，进而导致大量的内存占用，并会导致更复杂的渲染过程，因为浏览器会试图准备可能存在的变化过程，这会导致更严重的性能问题。
- 给它足够的工作时间：这个属性是用来让页面开发者告知浏览器哪些属性可能会变化的。然后浏览器可以选择在变化发生前提前去做一些优化工作。所以给浏览器一点时间去真正做这些优化工作是非常重要的。使用时需要尝试去找到一些方法提前一定时间获知元素可能发生的变化，然后为它加上 will-change 属性。