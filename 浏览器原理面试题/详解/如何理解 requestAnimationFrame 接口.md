## 视频讲解： 

此处为语雀视频卡片，点击链接查看：[如何理解+requestAnimationFrame+接口.mov](https://www.yuque.com/u1598738/zqco83/zy70e7sf07z42t15#mw5FY)

##   基本概念

- 是什么：这是一个监听“**帧**”的接口，在浏览器进入下一帧时触发回调
- 为什么：

- 在 raf 之前，我们只能通过 setTimeout/setInterval 等接口调度动画逻辑，但这两个接口与浏览器渲染“帧”的时机并不相关，会在错误的“时机”触发回调，可能反而让浏览器渲染管线变得紊乱
- 思考一个问题，浏览器的帧率是不固定的 —— 取决于帧内工作量，那么借助定时器做的定时回调并不能确保跟“帧”率匹配，可能会在一帧内触发多次，那么最终可能会造成渲染紊乱，影响帧任务的执行性能
- 使用 raf 后，我们能确保一定在帧开始之前触发回调，也就能跟渲染管线对齐，避免不必要的计算

- 应用场景：

- 各种类型的动画，比如：元素、canvas、webgl
- 防抖节流
- fps 计算



## 深入理解

### raf vs setTimeout 

- demo show

- ![img](https://cdn.nlark.com/yuque/0/2022/png/26698409/1670056170325-cc4a7617-99fb-44fd-8616-76c34699fb7f.png)
- raf 在每一帧样式计算之前触发；setTimeout 没办法把握准确时机
- raf 在一帧中只会触发一次；setTimeout 多次，导致 js 线程负载更高

- raf：

- 由**浏览器决定调用时机**，浏览器每次绘制一个新的帧之前触发，能保证回调函数在屏幕每一次的绘制间隔中只被执行一次
- 页面处理未激活的状态时，该页面的屏幕绘制任务也会被系统暂停，因此跟着系统步伐走的rAF也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了 CPU 开销
- 使用 raf 绘制动画时，由于 raf 发生在页面计算布局、绘制任务之前，因此 raf 回调中执行的 dom 更新能够在当前帧实时绘制；相对的，setTimeout 可能得等到下一帧

- setTimeout

- 由**用户决定触发时间**，但setTimeout 设置的函数会在一定的延迟时间（毫秒）后执行，但实际上，由于 JavaScript 是单线程执行的，如果当前有其他任务在执行，setTimeout 的回调可能会被推迟执行。
- 页面失活时，依然执行



### 渲染流水线原理：

- 浏览器以帧（任务流）为单位，循环调度任务，我们通常称之为**渲染流水线**
- 单个帧中需要执行许多任务

![img](https://cdn.nlark.com/yuque/0/2022/png/26698409/1670050237213-c59658ec-2b24-4748-9d10-c5d081cc3119.png)

1. **事件处理**：浏览器首先需要处理用户交互事件，比如**点击，滚动，输入**等等。这一步会触发 JS 代码的运行；
2. 触发 RAF
3. **解析 CSS 生成 CSSOM 树**：同时，浏览器还解析外部和内部的 CSS 信息，生成 CSSOM 树。
4. **构造 Render 树**：根据 DOM 树和 CSSOM 树构造 Render 树。 Render 树是包含颜色和高度宽度等属性以及它们对应的元素和内容的树形结构，它在 DOM 树和 CSSOM 树的基础上，删去了那些不需要进行显示的部分，比如 head 标签或者 display：none 的元素。
5. **布局**：布局阶段是根据构建的布局树来确定元素在设备视口（viewport）内的确切位置和大小，通常我们称这个阶段为"重排"。
6. **绘制**：绘制阶段是将布局树中的每个节点转换为屏幕上的实际像素，我们通常把这个阶段称为"重绘"。
7. **合成**：由于一些效果（如滚动，动画等）可能导致部分区域需要重新绘制，绘制后的元素会被分成不同的层，然后由 GPU 进行合成（Compositing）, 最后将最终图像渲染到屏幕上。

- 触发 requestIdleCallback(如果有空的话，有空的判定是： 16ms - 当前帧执行耗时>0)

- 我们的目标是维持这个渲染流水线的流畅度，保证 60FPS，但最终帧率取决于上述步骤的最终执行性能
- 假设使用 RAF 做动画或时间相关的回调：

- 一帧触发一次，在回调中可能修改 dom、样式等，这些改动在接下来的渲染环节生效

- 假设使用定时器，一帧可能触发多次，副作用：

- 当一帧触发多次时，动画可能会出现跳帧、掉帧等现象，导致动画效果变差。
- 浪费，因为可能只有最后一次的变更是有意义，会被渲染到页面的
- JS 执行在单独线程，与渲染流水线不相关，随时抢占执行时间分片，导致一帧内可能执行多次 定时器 回调，最终导致帧率下降
- 如果回调中存在某些强制重排的接口(例如 `offsetTop`)，那么一帧内就需要执行两次重排(为什么是两次)，这是很浪费性能的
- 即使窗口失活，动画也会持续，浪费性能



### 如何优化帧渲染性能？(目标：60fps)

- 避免长时间执行 js 脚本，可以使用 web worker 执行或者分片计算方式做负载均衡，避免影响渲染流水线
- 优化事件回调(scroll )、异步任务性能
- 减少重排次数、范围(避免交错读写样式、使用 transform 等)
- 使用 raf 绘制动画(更好的方式，应该是 css)