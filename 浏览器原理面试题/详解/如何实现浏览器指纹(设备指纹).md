核心点：

1. 理解什么是浏览器指纹
2. 掌握实现浏览器指纹的原理
3. 了解浏览器指纹的实际应用场景



## 什么是浏览器指纹

**浏览器指纹**是通过收集和识别网页浏览器特征的一种技术。它基于用户使用浏览器时产生的各种信息（例如操作系统、浏览器版本、插件、屏幕分辨率、系统语言等），用于唯一标识和区分不同的设备或用户。

简单而言，**浏览器指纹****能够实现在用户未登陆或者使用无痕模式的时候，依旧能够准确识别出该用户。**

**场景：用户第一天未登录的情况下浏览了页面 A，隔天用户使用同个浏览器并且使用了无痕模式再次浏览了页面 A，此时我们的页面能够依据浏览器指纹，识别出两次不带登陆态的用户是同一个人，从而实现一些**精准推送**。**

浏览器指纹技术虽然在一些场景中具有实用价值，但也有隐私和安全方面的问题，需要了解这个点。



## 原理及实现？

信息熵（entropy）是接收的每条消息中包含的信息的平均量，熵越高，则能传输越多的信息，熵越低，则意味着传输的信息越少。

浏览器指纹是由许多浏览器的特征信息综合起来的，其中特征值的信息熵也是不尽相同。

浏览器指纹一般而言，能分成几大类：

1. 浏览器基本指纹
2. Canvas 指纹
3. 音频指纹



**浏览器的基本指纹**指的浏览器的一些特性信息：

比如硬件类型（Apple）、操作系统（Mac OS）、用户代理（User agent）、系统字体、语言、屏幕分辨率、浏览器插件 (Flash, Silverlight, Java, etc)、浏览器扩展、浏览器设置 (Do-Not-Track, etc)、时区差（Browser GMT Offset）等众多信息，这些指纹信息“类似”人类的身高、年龄等，有很大的冲突概率，只能作为辅助识别。



**Canvas 指纹**

原理在于，使用 Canvas 绘制相同的元素，但是由于不同的浏览器所处的系统的差别，字体渲染引擎不同，对抗锯齿、次像素渲染等算法也不同，通过将基于 Canvas 绘制的元素转成图片编码，不同的浏览器就可以得到不同的结果，通过对这个不同结果进行哈希，就能拿到浏览器的 Canvas 指纹。



代码也比较简单：

```javascript
import sha256 from 'crypto-js/sha256';

const outScreenCanvas = document.createElement('canvas')
const ctx = outScreenCanvas.getContext("2d");
// Text with lowercase/uppercase/punctuation symbols
const txt = "BrowserLeaks,com <canvas> 1.0";
ctx.textBaseline = "top";
// The most common type
ctx.font = "14px 'Arial'";
ctx.textBaseline = "alphabetic";
ctx.fillStyle = "#f60";
ctx.fillRect(125,1,62,20);
// Some tricks for color mixing to increase the difference in rendering
ctx.fillStyle = "#069";
ctx.fillText(txt, 2, 15);
ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
ctx.fillText(txt, 4, 17);

const canvasImageData = outScreenCanvas.toDataURL();
const canvasFinger = sha256(canvasImageData);
```

随便使用 Canvas 在不同的浏览器绘制同一段内容，再将 Canvas 图像转换为 base64 编码的数据URL。

最终利用 sha256 生成一个固定长度的哈希值。



音频指纹

与 Canvas 指纹非常类似，其原理也是基于硬件设备或者软件的差别，来产生不同的音频输出，然后计算得到不同的 hash 来作为音频指纹。

1. 方法一：生成音频信息流(三角波)，对其进行FFT变换，计算SHA值作为指纹。
2. 方法二：生成音频信息流（正弦波），进行动态压缩处理，计算MD5值。

两种方法都是在音频输出到音频设备之前进行清除，用户根本就毫无察觉就被获取了指纹。

以 fingerprintjs2 的音频指纹源码为例：

```javascript
var each = function(obj, iterator) {
    if (Array.prototype.forEach && obj.forEach === Array.prototype.forEach) {
        obj.forEach(iterator)
    } else if (obj.length === +obj.length) {
        for (var i = 0, l = obj.length; i < l; i++) {
            iterator(obj[i], i, obj)
        }
    } else {
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                iterator(obj[key], key, obj)
            }
        }
    }
  }
  
  var AudioContext = window.OfflineAudioContext || window.webkitOfflineAudioContext

  var context = new AudioContext(1, 44100, 44100)

  var oscillator = context.createOscillator()
  oscillator.type = 'triangle'
  oscillator.frequency.setValueAtTime(10000, context.currentTime)

  var compressor = context.createDynamicsCompressor()
  each([
    ['threshold', -50],
    ['knee', 40],
    ['ratio', 12],
    ['reduction', -20],
    ['attack', 0],
    ['release', 0.25]
  ], function (item) {
    if (compressor[item[0]] !== undefined && typeof compressor[item[0]].setValueAtTime === 'function') {
      compressor[item[0]].setValueAtTime(item[1], context.currentTime)
    }
  })
  
  oscillator.connect(compressor)
  compressor.connect(context.destination)
  oscillator.start(0)
  context.startRendering()
  
  var audioTimeoutId = setTimeout(function () {
    console.warn('Audio fingerprint timed out. Please report bug at https://github.com/Valve/fingerprintjs2 with your user agent: "' + navigator.userAgent + '".')
    context.oncomplete = function () { }
    context = null
    return done('audioTimeout')
  }, 100)
  
  context.oncomplete = (event) => {
    try {
      clearTimeout(audioTimeoutId)
      audioFingerprint.value = event.renderedBuffer.getChannelData(0).slice(4500, 5000)
        .reduce(function (acc, val) { return acc + Math.abs(val) }, 0)
        .toString()
      oscillator.disconnect()
      compressor.disconnect()
      audioFingerprintHash.value = sha256(audioFingerprint.value)
    } catch (error) {
      console.log(error)
      return
    }
  }
```



### 综合指纹

非常重要。理解下面这段话：

上述的

1. 浏览器基本指纹
2. Canvas 指纹
3. 音频指纹

可能在不同的浏览器下无法达到 100% 的唯一，但是通过将它们进行组合，就能几乎得到唯一的指纹。



## 实用场景

### 针对性的广告推送

在网站上浏览某个商品，了解了相关的商品信息，但并没有下单购买，甚至没有进行登录操作。过两天用同台电脑访问其他网站的时候却发现很多同类商品的广告。

### 协助识别同一设备、打击黑产

在某博客中你有多个小号（水军），这些小号的存在就是为了刷某个帖子的热度或者进行舆论引导，即便你在切换账号的时候清空了 cookie、本地缓存，重开路由器甚至使用vpn来进行操作，但是管理人员可能还是知道这是同一个人在操作，从而被打击。



## 如何防范

浏览器指纹也有一些可以防止的措施。

#### Do Not Track

在http头部可以声明这样一个标志“DNT”意味“Do Not Track”，如果值为1表示为不要追踪我的网页行为，0则为可以追踪。 即便没有cookie也可以通过这个标志符告诉服务器我不想被追踪到，不要记录我的行为。

不好的消息是大多数网站目前并没有遵守这个约定，完全忽略了“Do Not Track”这个信号。



#### 禁用JS

这是一个比较暴力的方法，直接禁止网站使用JavaScript可以非常有效地防御浏览器指纹追踪，但是这样会导致页面较大部分地功能不可用。

而且非常不幸的是，即便禁止了 JS 但是还可以通过 CSS 来采取浏览器的信息，例如：

```plain
@media(device-width: 1080px) {
  body {
    background: url("https://example.org/1080.png");
  }
}
```

可以在服务器中看1080.png图片的请求日志，就可以得知哪些用户的屏幕是1080px的， 在 Mozilla Firefox 中，甚至曾经存在过可以直接查询 Windows 系统版本和 Windows 主题的 CSS 查询。现在这个问题已经被[修复](https://link.juejin.cn?target=https%3A%2F%2Fbugzilla.mozilla.org%2Fshow_bug.cgi%3Fid%3D1396066)。

所以可以看到，浏览器指纹，只要网站想，其实浏览器指纹是非常难以防范的。