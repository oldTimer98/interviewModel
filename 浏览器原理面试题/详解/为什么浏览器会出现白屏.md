## 是什么

页面因为某些原因导致崩溃，无法正常渲染内容的现象；白屏的影响极大，对用户侧可能意味着无法获取任何有效信息；对开发者意味着扣工资

## 为什么

关键静态资源异常，js 未捕获异常，死循环，运行时 bug 等

## 怎么优化

补充完善的异常检测；做好代码边界检查；关键路径补充熔断(react errorBoundary 等)机制；



## 深度剖析

### 白屏异常类型

1. **纯白屏**

1. 可以理解为一整个页面从刷新进入后一直处于白屏阶段，无任何响应，无 Loading 出现

1. **Loading 白屏、或骨架屏白屏**

1. 初始化阶段出现阻塞异常（前端核心JS资源加载失败、API请求失败后的未捕获的异常、JS解析过程的抛出异常等）都会造成这类白屏。可能已经出现了类似 Loading 等页面加载动画。

1. **局部元素缺失的白屏**

1. 当具体页面渲染过程中，出现阻塞元素渲染的异常，比如数据异常、关键资源加载异常等、导致元素的关键配置信息无法构建完成，则会出现局部元素缺失的白屏



### 可能导致白屏的原因：

- 静态资源异常，特别是 html 与 js 文件 404，特别在 react、vue 的 csr 场景，主文件丢失会直接导致白屏
- 衍生开来，css、图片、异步 JavaScript 等非关键路径资源 404，会不会导致 白屏？
- 运行时 bug，少见，但在小程序一类。。。场景中，需要特别关注
- js 代码问题：
- 未处理异常：

- `undefine.xx`，
- `obj()`，
- `JSON.parse(obj) 或者非法 json 字符串` 
- 现代 mvvm 框架中，[单个组件未处理异常导致全局 crash](https://codepen.io/cfjedimaster/embed/BEXoOw?height=265&theme-id=0&default-tab=js%2Cresult&user=cfjedimaster&slug-hash=BEXoOw&pen-title=Error1B&name=cp_embed_2)

- 死循环



### 如何检测白屏

- load + beforeUnload，load 的时候在storage 记个状态，如果没有unload就证明crash了
- 定时检测页面元素数量，低于阈值时表明可能出现白屏异常
- serviceWorker

- Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃；
- Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；
- 使用 `postMessage` 发送心跳信号

- 基于图片对比算法处理白屏检测
- 各种基于 DOM 的衍生检测方案（检测DOM层级、换算成分数）
- 采样检测界面中的元素是否为白屏态元素



我们展开聊聊**采样检测界面中的元素是否为白屏态元素**以及**检测DOM层级、换算成分数**两种方案。



#### 采样检测界面中的元素是否为白屏态元素

**实现思路：**界面中选定多个特定或随机坐标，检测对应点的元素是否为特定元素。

通过 **document.elementsFromPoint** 获取坐标处的多层级元素，判断对应元素所呈现的是否是白屏

特定元素的判断逻辑：**预先设定特定的白屏态元素集合**，如html, body, #app, 再比较元素 node 的属性判断是否为相同元素。

核心代码：

```javascript
function samplingCheck() {
    let emptyPoints = 0;
    for (let i = 1; i <= 9; i++) {
      const xElements = document.elementsFromPoint(
        (window.innerWidth * i) / 10,
        window.innerHeight / 2
      );
      const yElements = document.elementsFromPoint(
        window.innerWidth / 2,
        (window.innerHeight * i) / 10
      );
      if (isEmptyContainer(xElements[0])) {
        emptyPoints++;
      }
      if (i !== 5) {
        if (isEmptyContainer(yElements[0])) {
          emptyPoints++;
        }
      }
    }
    callback({
      status: emptyPoints >= 16 ? 'BlankScreen' : 'OK',
    });
}
```



#### 检测DOM层级、换算成分数

**实现思路：**比较和借鉴了业界主流的做法：按照广度优先遍历目标的 DOM Node 的后代，每一层级的 Nodes 分别按分数计算规则累计分数。

**分数计算规则**：当元素可见（有高度且在可视窗口内），按照 score = 1 / (2^(curDepth - 1)) 计算得分，元素的得分权重随 depth 增加而减少；否则此元素得分为 0。

核心代码：

```javascript
function skipMeasure(node, depth) {
  const DEFAULT_IGNORE_TAGS = ['SCRIPT', 'STYLE', 'META', 'HEAD'];
  const DEFAULT_MAX_DEPTH = 4;
  return !!DEFAULT_IGNORE_TAGS.includes(node.tagName) || DEFAULT_MAX_DEPTH < depth;
}
 
function measureDomScore(node, curDepth = 0, totalScore = 0, threshold = DEFAULT_THRESHOLD) {
  if ((!node || skipMeasure(node, curDepth) || threshold <= totalScore)) return totalScore;
  const score = (function() {
    if (!curDepth) return 0;
    const bound = getBounding(node);
    const elementTop = bound.top;
    const elementHeight = bound.height;
 
    return elementTop > innerHeight || elementHeight <= 0 ? 0 : 1 / Math.pow(2, curDepth - 1);
  })();
  return [].reduceRight.call(
    node.children,
    function(totalScore, target) {
      return measureDomScore(target, curDepth + 1, totalScore, threshold);
    },
    totalScore + score
  );
}
```



#### 方案权衡：

| **检测方式**                                    | **适用范围**                     | **优劣势**                                                   |
| ----------------------------------------------- | -------------------------------- | ------------------------------------------------------------ |
| **采样检测界面中的元素是否为疑是白屏的元素**    | 纯白屏                           | 优势：逻辑较为简单检测逻辑的性能OK劣势：采样点的**检测范围不全**，存在误判风险**通用性不足。**elementsFromPoint对于局部元素范围的支持的扩展性不足需要**预先选定白屏态元素集合**，不能很好支持骨架屏白屏的判定。在通用性和各类场景的覆盖上存在不足 |
| **检测DOM层级换算成分数，作为判定白屏的置信度** | 纯白屏，骨架屏白屏，局部元素白屏 | 优势：通用性较好，通过指定不同的root元素的检测范围、和DOM分数阈值，来适配到不同系统的不同场景。能够支持到骨架屏、局部范围的白屏的场景 检测性能OK劣势：DOM分数的阈值设定，不同的系统场景无法统一。可能需要额外的文档和工具，帮助使用方判断如何制定分数阈值 |

### 如何预防：代码健壮性

- 不要相信上游数据(接口、函数参数、上下文状态、store 等等)，做好必要的输入数据检测
- try-catch：同步、异步(async-await) 均可，可以放在容易出错的可疑区域(如 `JSON.parse`)
- 关注 npm 包的 breaking change
- 主动抛出异常，在开发阶段及时发现异常
- react 中使用 ErrorBoundary 兜底；vue 中使用 `vue.config.errorHandler` 或 `renderError` 等接口
- 补充必要的单元测试，特别是边界值、非法值测试
- 捕获未知异常，并主动上报：

- window.onerror：全局兜底，but无法捕获资源 or js 代码异常
- `window.addEventListener('error', function(){}, true)` 捕获静态资源错误，但资源异常不会冒泡，所以必须用捕获方式
- `window.addEventListener("unhandledrejection", func)`捕获异步异常

- 跨域脚本做好跨域处理

- 客户端：在script标签增加crossorigin="anonymous"属性
- 服务端：静态资源响应头Access-Control-Allow-Origin: *



进一步学习参考资料：

- [前端白屏的检测方案，让你知道自己的页面白了 - 掘金](https://juejin.cn/post/7176206226903007292)
- [开发者中心](https://developer.umeng.com/docs/193624/detail/445269)
- [白屏监控--应用性能监控全链路版-火山引擎](https://www.volcengine.com/docs/6431/104850)
- https://github.com/GoogleChrome/web-vitals/blob/main/src/onLCP.ts
- [shin-monitor/src/lib/error.ts at main · pwstrick/shin-monitor](https://github.com/pwstrick/shin-monitor/blob/main/src/lib/error.ts)
- [GitHub - xy-sea/web-see: 前端监控SDK，可用来收集并上报：代码报错、性能数据、页面录屏、用户行为、白屏检测等个性化指标数据](https://github.com/xy-sea/web-see)
- [Background Tasks API - Web APIs | MDN](https://developer.mozilla.org/en-US/docs/Web/API/Background_Tasks_API#example)
- [Coordinates](https://javascript.info/coordinates)
- [Mutation observer](https://javascript.info/mutation-observer)
- [Using Breadcrumbs](https://docs.sentry.io/product/issues/issue-details/breadcrumbs/)
- [Action列表--应用性能监控全链路版-火山引擎](https://www.volcengine.com/docs/6431/133602)