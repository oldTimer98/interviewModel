核心点，理解在资源加载方面，可以做的事情：

1. **理解 CDN，使用 CDN**
2. **预加载关键资产以提高加载速度（Preload）**
3. **预拉取资源以加快未来的导航速度（Prefetch）**
4. **尽早建立网络连接（Preconnect、dns-prefetch）**
5. **能够完全厘清 Preload、Prefetch、Preconnect 的区别**

**合理运用右侧导航树，找到自己的知识盲区，查缺补漏！**

## 理解 CDN，使用 CDN

CDN（Content Delivery Network，内容分发网络）是由分布在不同地理位置的代理服务器及其数据中心组成的网络： 

A content delivery network or content distribution network (CDN) is a geographically distributed network of proxy servers and their data centers. 

希望在空间距离上为用户就近提供服务，以提高可用性和性能： 

The goal is to provide high availability and high performance by distributing the service spatially relative to end-users.

内容交付网络 (CDN) **通过使用分布式服务器网络向用户交付资源来提高站点性能。**由于 CDN 可以减少服务器负载，因此可以降低服务器成本，并且非常适合处理流量峰值。

在 CDN 服务器上缓存资源使得请求无需一路传输到源站即可获得服务。因此，资源的交付速度更快；这也减少了源服务器的负载。

CDN 的性能优势源于以下几个点： 

1. **CDN 服务器比源服务器更靠近用户，因此具有更短的往返时间 (RTT)延迟；**
2. **网络优化允许 CDN 比“直接”从源服务器加载内容更快地交付内容；**
3. **最后，CDN 缓存消除了请求传输到源服务器的需要。**

CDN 涉及的关键技术：

- **内容发布：它借助于建立索引、缓存、流分裂、组播（Multicast）等技术，将内容发布或投递到距离用户最近的远程服务点（POP）处；**
- **内容路由：它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程 POP 上均衡用户的请求，以使用户请求得到最近内容源的响应；**
- **内容交换：它根据内容的可用性、服务器的可用性以及用户的背景，在POP的缓存服务器上，利用应用层交换、流分裂、重定向（ICP、WCCP）等技术，智能地平衡负载流量；**
- **性能管理：它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。**

通过下图，理解 CDN：

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1694070307623-a2118f3c-668a-47af-b61c-46492ba17795.png)

### CDN 相关的一些关键术语

1. 缓存：将从根服务器请求来的资源按要求缓存。
2. 回源：当有用户访问某个资源的时候，如果被解析到的那个 CDN 节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。没有人访问，CDN 节点不会主动去源站请求资源。

- 一级缓存 访问二级缓存是否有相关数据，如果有，返回一级缓存。
- 二级缓存 Miss，触发 二级缓存 回源请求，请求源站对应数据。获取结果后，缓存到本地缓存，返回数据到一级缓存。
- 一级缓存 获取数据，缓存本地后，返回给用户。

### CDN的特点总结

1、资源访问加速: 本地Cache加速，提高了企业站点（尤其含有大量图片和静态页面站点）的访问速度，并大大提高以上性质站点的稳定性

2、消除运营商间网络互联的瓶颈问题: 镜像服务消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。

3、远程加速: 远程访问用户根据DNS负载均衡技术 智能自动选择Cache服务器，选择最快的Cache服务器，加快远程访问的速度

4、带宽优化: 自动生成服务器的远程Mirror（镜像）cache服务器，远程用户访问时从cache服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点WEB服务器负载等功能。

5、集群抗攻击: 广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种D.D.o.S攻击对网站的影响，同时保证较好的服务质量 。



推荐继续阅读：

1. [Content delivery networks (CDNs)](https://web.dev/content-delivery-networks/)
2. [高性能利器：CDN我建议你好好学一下！](https://juejin.cn/post/7002781373014474759?searchId=20230907150632A558B72C68978B24977A)
3. [【前端词典】CDN 带来这些性能优化 - 掘金](https://juejin.cn/post/6844903892849786893?searchId=20230907150632A558B72C68978B24977A)



## 预加载关键资产以提高加载速度（Preload）

核心：如何使用 <link rel="preload"> 来达成提高加载速度目的。

这里有部分内容：[如何理解 preload 指令](https://www.yuque.com/u1598738/vqazlv/uo05n05ems8p1mtf)

预加载最适合用于浏览器通常较晚使用的资源。



*在本例中，Pacifico 字体是在样式表通过* [@font-face](https://web.dev/reduce-webfont-size/#defining-a-font-family-with-@font-face)) *规则定义的。浏览器只有在完成下载和解析样式表后才会加载字体文件。*

通过预加载某个资源，我们可以希望浏览器可以比正常发现它更早地获取该资源，如果它对当前页面很重要。

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1694070867018-594e813d-c173-4fc0-9f1b-2774e7b7ae5d.png)

在本例中，已预加载了 Pacifico 字体，所以下载会与样式表并行进行。

通过在 HTML 文档的头部添加带有 rel="preload" 的 <link> 标记来预加载资源：

```html
<link rel="preload" as="script" href="critical.js">
```

**浏览器会缓存预加载的资源，以便在需要时立即可用。**（它不会执行脚本或应用样式表。）

### 浏览器对资源优先级的划分

我们先对浏览器请求各种资源的优先级顺序有一个大概的认识，在默认情况下，有如下的划分：

1. 第一个级别就是这个页面的主资源，它所包含的当前主页（index.html）、 css 资源、font 资源
2. 第二个级别就是 JS 资源、在视口区域的图片、Fetch API、XHR
3. 第三个级别可以是我们网站的标题的图标 Favicon
4. 第四个级别是 async/defer 标签的 JS 资源、不在视口里的图片、视频这些
5. prefetch 的资源...

### preload 的 as 规则

在使用 preload 的时候，会有一个特殊的属性 as，像是这样：

```html
<head>
  <link rel="preload" as="script" href="foo.js">
</head>
```

as 的作用是什么？**preload 的优先级顺序和这个属性指定的资源类型相关。**

preload 的 as 属性是用于告知浏览器预加载资源的类型，以便浏览器能够正确处理这些资源。下面是一些常见的 as 规则：

1. as="script"：表示被预加载的资源是 JavaScript 脚本文件。通过使用此规则，可以将关键的 JavaScript 文件提前加载，以便在页面需要时能够立即执行。
2. as="style"：表示被预加载的资源是 CSS 样式表。这个规则用于提前下载并应用关键的 CSS 文件，以避免渲染延迟和样式闪烁。
3. as="font"：表示被预加载的资源是字体文件。使用此规则，可以提前下载字体文件，以确保在页面需要使用时能够立即应用正确的字体。
4. as="image"：表示被预加载的资源是图像文件。通过预加载图像，可以减少图像的加载时间，从而提高页面的整体加载速度。
5. as="audio"：表示被预加载的资源是音频文件。使用此规则，可以在需要播放音频时，提前加载音频文件，以确保播放的即时性。
6. as="video"：表示被预加载的资源是视频文件。通过预加载视频文件，可以避免视频加载的延迟，并提供更流畅的视频播放体验。
7. as="document"：表示被预加载的资源是HTML文档。这个规则用于提前下载并缓存HTML文档，以加速页面的导航和渲染。

除了上述常见的 as 规则外，还有其他一些可能的值，如 as="fetch"（表示被预加载的资源可以通过 Fetch API 进行处理）等。需要注意的是，不同浏览器对 as 属性的支持程度可能会有所不同，因此在使用时应先检查浏览器兼容性，并根据实际需求选择合适的规则。如果未指定 as 属性，默认情况下将作为通用类型进行处理。

举一个例子，假如我们指定了 as 的值是 style，也就是把它当做 css 资源，那它的优先级就会变得最高。

但是也有一个例外：虽然 font 的优先级是最高，但把 as 的值指定为 font 并不会把此资源的优先级放到最高，文档专门为 font 的 preload 指定了优先级：位于第二级。目前来说，除了 font，其他都按照和资源优先级相同的规则。

as 属性可以说是必须要设置的，除了上面可以给优先级排级别以外，还有一个原因：如果不设置的话，它会被作为一个 XHR 请求去触发，浏览器可能不能正确的认识到，我们其实已经把资源预加载了，这样子就会加载两次了，完全没有了优化的效果。

### 如何区分 preload 和 prefetch

- preload   是告诉浏览器页面**必定**需要的资源，浏览器**一定会**加载这些资源；
- prefetch 是告诉浏览器页面**可能**需要的资源，浏览器**不一定会**加载这些资源。

preload 是确认会加载指定资源，如在我们的场景中，x-report.js 初始化后一定会加载 PcCommon.js 和 TabsPc.js, 则可以预先 preload 这些资源；

prefetch 是预测会加载指定资源，如在我们的场景中，我们在页面加载后会初始化首屏组件，当用户滚动页面时，会拉取第二屏的组件，若能预测用户行为，则可以 prefetch 下一屏的组件。

### 合理且正确的使用 preload

使用 preload 前，在遇到资源依赖时进行加载：

![img](https://cdn.nlark.com/yuque/0/2023/webp/311219/1694071667329-513eacac-4af4-40a9-97b0-e38d4581094c.webp)

使用 preload 后，不管资源是否使用都将提前加载：

![img](https://cdn.nlark.com/yuque/0/2023/webp/311219/1694071667389-e40dc9b5-9c9c-4228-8635-d1910d5db346.webp)

可以看到，preload 的资源加载顺序将被提前：

![img](https://cdn.nlark.com/yuque/0/2023/webp/311219/1694071667368-f7ae2c5c-3964-4deb-8639-80397b1e51df.webp)

使用 preload 后，Chrome 会有一个警告： 

![img](https://cdn.nlark.com/yuque/0/2023/webp/311219/1694071681713-26a2dd8b-625c-4198-b6db-0439a5a547fc.webp)

若不确定资源是必定会加载的，则不要错误使用 preload，以免本末倒置，给页面带来更沉重的负担。

当然，可以在 PC 中使用 preload 来刷新资源的缓存，但在移动端则需要特别慎重，因为可能会浪费用户的带宽。

preload 和 prefetch 混用的话，并不会复用资源，而是会重复加载。

```plain
复制代码<link rel="preload"   href="https://at.alicdn.com/t/font_zck90zmlh7hf47vi.woff" as="font">
<link rel="prefetch"  href="https://at.alicdn.com/t/font_zck90zmlh7hf47vi.woff" as="font">
```

使用 preload 和 prefetch 的逻辑可能不是写到一起，但一旦发生对用一资源 preload 或 prefetch 的话，会带来双倍的网络请求，这点通过 Chrome 控制台的网络面板就能甄别： 

![img](https://cdn.nlark.com/yuque/0/2023/webp/311219/1694071712082-d63b2aed-a46d-488f-a97b-32c4d17afc2a.webp)

## **预拉取资源以加快未来的导航速度（Prefetch）**

必须要在理解了 preload 的基础上，再进行 prefetch 的理解。

上面的内容，再复述一次：

- preload   是告诉浏览器页面**必定**需要的资源，浏览器**一定会**加载这些资源；
- prefetch 是告诉浏览器页面**可能**需要的资源，浏览器**不一定会**加载这些资源。

preload 是**确认会加载指定资源**，如在我们的场景中，x-report.js 初始化后一定会加载 PcCommon.js 和 TabsPc.js, 则可以预先 preload 这些资源；

prefetch 是**预测会加载指定资源**，如在我们的场景中，我们在页面加载后会初始化首屏组件，当用户滚动页面时，会拉取第二屏的组件，若能预测用户行为，则可以 prefetch 下一屏的组件。

并且，prefetch 的请求的优先级是在上面几个的最后面。也就是说，在**第五个级别**。

再回顾一次，浏览器请求各种资源的优先级顺序有如下的划分：

1. 第一个级别就是这个页面的主资源，它所包含的当前主页（index.html）、 css 资源、font 资源
2. 第二个级别就是 JS 资源、在视口区域的图片、Fetch API、XHR
3. 第三个级别可以是我们网站的标题的图标 Favicon
4. 第四个级别是 async/defer 标签的 JS 资源、不在视口里的图片、视频这些
5. prefetch 的资源...

明白了这一点，我们大概就知道它的应用场景了，一个典型的应用场景就是 prefetch 在未来可能打开的路由页面。举一个例子来说明这个问题，假如有一个搜索页面，点击搜索出来的结果是跳转新的路由，其实如果搜索结果好，一般用户都会点击前几条，所以我们就可以 prefetch 前几条搜索结果对应的路由。

像我们的现在的应用，一般都会有懒加载，我们可以给非首页但是打开频率很高的页面加 prefetch。

它的使用就是直接加一个 link 标签，这样它就会在浏览器空闲的时候下载了：

```html
<link rel="prefetch" as="script" href="a.bundle.js">
```

其中 as 的取值有 document 、style、script、images ...

如果使用 webpack ，没有使用 preload 那么坑，可以直接在引入的地方加魔法注释：

如果使用 webpack ，没有使用 preload 那么坑，可以直接在引入的地方加魔法注释：

```javascript
import(/*webpackPrefetch: true */ 'a.bundle.js')
```

截止目前，prefetch 的支持性没有特别好，只覆盖了 80 % 的浏览器 。所以我们一般都是需要 polyfill 的，可以使用 XHR 或者 fetch 去模拟，由于上面我们给出来 fetch 的模拟方法，现在给出 XHR 的模拟方法：

除了直接给资源加 prefetch 标签。还有一个触发 prefetch 的思路，我们可以在入口到达可视窗口的时候，自动 prefetch。[这个库](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FGoogleChromeLabs%2Fquicklink) 就实现了这样的功能。它使用了 Intersection API 监听元素到达可视窗口，到达了就进行 prefetch。

prefetch 的内容会被缓存起来，但是也是有有效期的，Chrome 中是 5 分钟。这一点我们使用的时候也可以注意一下。

同时，一般只在用户网络比较好的情况下才预加载，浏览器也有监听网速的 API：

```javascript
let prefetch = true;
const connection = navigator.connection;
if (connection) {
  if (connection.effectiveType === 'slow-2g') {
    prefetch = false;
  }
}
```

### prefetch 实用场景

1. 预取后续页面

当后续页面可预测时，可以使用 prefetch 预取 HTML 文档，以便单击链接时立即加载页面。

虽然使用 prefetch 预取资源确实会使用额外的带宽，但它可以提高大多数性能指标。[第一个字节的时间 (TTFB)](https://web.dev/ttfb/)通常会低得多，因为文档请求会导致缓存命中。由于 TTFB 会较低，因此后续基于时间的指标通常也会较低，包括[最大内容绘制 (LCP)](https://web.dev/lcp/)和[首次内容绘制 (FCP)](https://web.dev/fcp/)。

1. 预取静态资源

当可以预测用户可能访问的后续部分时，预取静态资源，例如脚本或样式表。当这些资源在多个页面之间共享时，这尤其有用。

例如，Netflix 利用用户在注销页面上花费的时间来预取 React，这将在用户登录后使用。因此，他们将未来导航的交互时间减少了 30%。

1. 预取按需 JavaScript 块

[对 JavaScript 包进行代码分割](https://web.dev/reduce-javascript-payloads-with-code-splitting)允许我们最初仅加载应用程序的部分内容并延迟加载其余部分。如果您使用此技术，则可以将预取应用于不是立即需要但可能很快就会被请求的路由或组件。

例如，如果您的页面包含一个按钮，该按钮可打开一个包含表情符号选择器的对话框，则可以将其分为三个 JavaScript 块：home、dialog 和 picker。主页和对话框可以最初加载，而选择器可以按需加载。像 webpack 这样的工具允许我们指示浏览器预取这些按需块。

### prefetch 预取资源的一些特点

- prefetch 图像可以显着缩短 LCP 图像元素的 LCP 时间。
- prefetch CSS 可以改进 FCP 和 LCP，因为下载样式表的网络时间将被消除。由于样式表是阻塞渲染的，因此它们在预取时可以减少 LCP。如果后续页面的 LCP 元素是通过该background-image属性请求的 CSS 背景图像，则该图像也将作为预取样式表的依赖资源进行预取。
- prefetch JavaScript 将允许预取脚本的处理比导航期间首先由网络获取脚本的处理要快得多。这可能会影响响应指标，例如[首次输入延迟 (FID)](https://web.dev/fid/)和[下次绘制交互 (INP)](https://web.dev/inp/)。在通过 JavaScript 在客户端上呈现标记的情况下，可以通过减少资源加载延迟来改进 LCP，并且可以更快地进行包含页面 LCP 元素的标记的客户端呈现。
- prefetch 当前页面尚未使用的 Web 字体可以消除布局变化。[font-display: swap;在使用 的](https://developer.chrome.com/docs/lighthouse/performance/font-display/)情况下，消除了字体的交换周期，从而加快了文本渲染速度并消除了布局变化。如果将来的页面使用预取的字体，并且该页面的 LCP 元素是使用 Web 字体的文本块，则该元素的 LCP 也会更快。

## 尽早建立网络连接（Preconnect、dns-prefetch）

OK，我们继续，那 preconnect 又是什么呢？

相对于上述的 preload 和 prefetch，preconnect 相对好理解一些。

它的作用使用了提前和第三方资源建立连接的。在我们请求一个资源之前，可能会涉及 DNS 寻址、TLS 握手、TCP 握手、重定向等。这期间就花费了很多时间了。如果我们加上 preconnect：

```html
<link rel="preconnect" href="https://example.com">
```

浏览器就知道我们将要连接这个网站，跳转也好、请求资源也好，它会做好早期的连接工作。但是浏览器只会保留 10 S，如果 10 S 不用就会浪费了这资源了。

还有一个和它很相似的 dns-prefetch，只不过这个只预解析 DNS ：

```html
<link rel="dns-prefetch" href="https://example.com">.
```

### 理解为什么需要 preconncet

在浏览器可以从服务器请求资源之前，它必须建立连接。建立安全连接涉及三个步骤：

- 查找域名并将其解析为 IP 地址。
- 建立与服务器的连接。
- 为了安全起见，对连接进行加密。

在每个步骤中，浏览器都会向服务器发送一段数据，然后服务器发回响应。从出发地到目的地再返回的旅程称为[往返](https://developer.mozilla.org/docs/Glossary/Round_Trip_Time_(RTT))。

根据网络条件，单次往返可能需要大量时间。连接设置过程可能涉及最多三次往返，在未优化的情况下甚至更多。

提前处理好所有这些事情会让应用程序感觉更快。

基于此，我们有了：

1. <link rel=preconnect>
2. <link rel=dns-prefetch>

添加 rel=preconnect 到 <link> 会通知浏览器您的页面打算建立与另一个域的连接，并且您希望该过程尽快启动。资源加载速度会更快，因为在浏览器请求资源时设置过程已经完成。

通知浏览器您的意图就像 <link> 向页面添加标签一样简单：

```html
<link rel="preconnect" href="https://example.com">
```

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1694073728485-aa4e937c-8102-486c-9de8-cfb2f7dee2a5.png)

通过尽早建立与重要第三方来源的连接，您可以将加载时间加快 100–500 毫秒。

### 适合使用 preconnect 的场景

OK，什么时候，开始考虑使用 preconnect 而不是 prefetch ？有两个很好的例子：

1. 由于现在发布都是走的增量更新（通过在文件后添加 hashcode 的方式），有时我们会遇到这样的情况：知道将从特定 CDN 请求资源，但不知道其确切路径。

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1694073858410-808b5b8b-e0e2-4ec4-a996-e38a1ad36407.png)

此时，preconnect 这个 CDN 域名就很有必要：

```html
<link rel="preconnect" href="https://cdn.example.com">
```



2. 另一种常见情况是从[图像 CDN](https://web.dev/image-cdns)加载图像，其中图像的确切路径取决于用户浏览器上的媒体查询或运行时功能检查。

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1694073909879-13aacc66-ffcf-4087-a6eb-56d6892870ae.png)

这种情况下，preconnect 这个 CDN 域名也能够实现一定的性能优化。

在这两种情况下，如果我们要获取的资源很重要，就通过预先连接 preconnect 到服务器来节省尽可能多的时间。在您的页面请求该文件之前，浏览器不会下载该文件，但至少它可以提前处理连接方面的问题，从而使用户免于等待多次往返。

### dns-prefetch 和 preconnect 的异同

OK，那 dns-prefetch 和 preconnect 又有什么不一样呢？

dns-prefetch 和 preconnect 都是用于优化网络性能的标签，但它们有一些区别：

- dns-prefetch：用于预解析域名，即在浏览器加载网页时提前解析指定的域名对应的 IP 地址。这样可以减少 DNS 查询时间，加速后续资源的获取。
- preconnect：用于预连接，即在浏览器加载网页时提前建立与指定域名的连接。这不仅包括 DNS 解析，还包括建立 TCP 连接、执行 TLS 握手等过程。通过预先建立连接，可以减少连接建立的延迟，并提高后续资源请求的效率。

如果我们的页面需要连接到许多第三方域，则使用 preconnect 预先链接所有第三方域会适得其反。preconnect 的使用最好仅用于**最关键的连接**。

对于其余所有内容，我们就可以使用 <link rel=dns-prefetch>  来节省 DNS 查找时间，该步骤通常仅需要大约 [20-120 毫秒](https://www.keycdn.com/support/reduce-dns-lookups)。

语法如下：

```html
<link rel="dns-prefetch" href="http://example.com">
```

### dns-prefetch 和 preconnect 在兼容性方面的差异

preconnect 的兼容性列表：

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1694074263465-b8b0484e-f634-467f-9cbe-99d3db8a2c8c.png)

dns-prefetch 的兼容性：

![img](https://cdn.nlark.com/yuque/0/2023/png/311219/1694074282635-a84e0a2c-08f1-4d5f-a99a-85ba896948c3.png)

可见，dns-prefetch 有着更好的兼容性。因此，某些低端设备场景下，我们可以使用 dns-prefetch 作为 preconnect 的优雅降级措施：

```html
// GOOD
<link rel="preconnect" href="http://example.com">
<link rel="dns-prefetch" href="http://example.com">

// BAD
<link rel="preconnect dns-prefetch" href="http://example.com">
```

dns-prefetch 与 preconnect 出现在同一 <link> 标签中，会导致低版本 Safari 出现错误。而分开写则不会有这个问题，当 preconnect 失效，dns-prefetch 还可以正常工作。

当我们知道很快就会从第三方域下载某些内容，但不知道该资源的确切 URL 时，dns-prefetch 与 preconnect 这两个属性有助于提高页面速度。

但是，切记，如果我们的页面需要连接到许多第三方域，则使用 preconnect 预先链接所有第三方域会适得其反。preconnect 的使用最好仅用于**最关键的连接**。