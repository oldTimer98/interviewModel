## 基础

- canvas 卡顿原因：渲染的内容越多、绘制区域越大、接口调用次数越多，越容易出现卡段
- 解决方案：

- 减少接口调用次数，减少修改 canvas 属性(font、fill、strokeStyle 等)
- 分层渲染(echarts)
- 使用离屏渲染
- 避免绘制可视区域之外的内容

## 进阶

### canvas 绘制过程：

一般来说，canvas 程序的绘制过程大致可以总结为如下步骤：

- 计算：处理数据逻辑，计算每个对象的状态，确定最终绘制内容
- 绘制：调用 canvas API 绘制内容
- 渲染：浏览器执行真正的渲染逻辑，此时通常会借助 gpu 完成图像绘制

![img](https://cdn.nlark.com/yuque/0/2022/png/26698409/1663777585107-7d0e88ef-8f13-4b78-9936-94f5cdf4b427.png)

- 一旦上述过程超过 16ms 就会感觉卡顿，导致掉帧；因此，我们需要确保单次擦除-绘制在 16ms 内完成才能保持较稳定的的 fps
- 关键指标：fps，30、60 左右；移动端、pc 端；Performance api、raf 接口；

### 优化方案：

- 减少上下文状态变更(fillStyle/strokeStyle)：canvas 是一个状态机，状态变更的成本远比普通对象属性变更大很多

| 属性                 | 开销  | 开销（非法赋值） |
| -------------------- | ----- | ---------------- |
| line[Width/Join/Cap] | 40+   | 100+             |
| [fill/stroke]Style   | 100+  | 200+             |
| font                 | 1000+ | 1000+            |
| text[Align/Baseline] | 60+   | 100+             |
| shadow[Blur/OffsetX] | 40+   | 100+             |
| shadowColor          | 280+  | 400+             |

- 减少绘制接口调用
- 避免绘制可视区域外的内容：可以在绘制时计算每一个图形的四边形与视口四边形是否重叠，判断是否需要绘制该图形
- 局部清楚 —— 重绘
- 减少单次图形计算量，或者配合 webworker 并行计算出最终绘制指令
- 减少图片操作(包括：圆角、裁剪)，可以考虑在原始图片上直接施加预期效果
- 设置不同渲染帧率：例如游戏场景中，前景人物动画变化频繁；但背景地图元素可能变动频率很低，那么可以为此设置更低的帧率，全局减少计算负载
- 分层渲染：将不同内容分布在不同 canvas 实例上；多个 canvas 实例通过 z-index 控制层叠顺序，形成同一

- 问题：

- 方案设计上比较麻烦，需要考虑内容变动频率、上下层叠规则等，将不同内容分配到不同层
- canvas 实例本身维护成本也比较高，不过过度分层

![img](https://cdn.nlark.com/yuque/0/2022/png/26698409/1663773604434-3289cb88-26d6-4064-af44-57a53686e670.png)

- 离屏渲染(实验特性)：使用 `OffscreenCanvas` api + webworker，实现离屏渲染后重绘回主屏画布

- 问题：兼容性差，特别是 Safari 都不支持，部分移动端 webview 版本也不支持

- 使用 webgl



资料：

- https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas
- https://juejin.cn/post/7135229172409958431