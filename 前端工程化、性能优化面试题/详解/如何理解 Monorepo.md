## 是什么

![img](https://cdn.nlark.com/yuque/0/2023/png/32786640/1693314733900-3da32027-9dcc-433e-b98e-95d96ca3f34f.png)

monorepo 是一种将多个项目代码存储在一个仓库里的**软件开发策略**，现如今非常多开源仓库、知名公司等广泛采用这种方式管理代码，例如：[vue](https://github.dev/vuejs/vue)、antd 等；也有许多公司在积极拥抱 monorepo 技术。

PS：google 的仓库管理策略更绝 —— 所有代码在一个仓库！最开始也是期望把 训练营里面的项目统一用 monorepo 管理的：https://gitee.com/vanfe/devil-camp



## 为什么

看似职责不够单一，代码糅合在一起，设计不够合理，但：

- 更容易实现代码复用(源码管理比依赖管理简单很多)，也更容易治理
- 更容易复用基础设施
- 更容易 CR
- 微前端/微服务化后，项目粒度有过度拆解的趋势，导致项目总量往往越来越多；强制 monorepo 能给高层带来更便捷的管理维度
- 更容易针对整个团队，设定统一的编码规范等；也能够规范许多开发行为
- 子项目间模块关系更透明，理论上更容易做集成部署；更容易做基础设施升级
- 倡导一种透明、公平、开放、共享的工程师文化，促进合作；
- 可能带来更高的开发效率；
- 其实，不过是一种分久必合合久必分的历史趋势罢了



当然，必然是有缺点的：

![img](https://cdn.nlark.com/yuque/0/2023/png/32786640/1693314811159-accfb0ac-e84e-482c-9b0d-bc43242fa6c1.png)

- 代码权限(如果需要的话)管理变得很复杂，git 维度下甚至做不到
- 上手成本更高，除了特定模块外，新人还需要串联了解子项目之间的依赖关系
- 本地开发对 IDE 要求更高
- 依赖管理、代码搜索、FG、分支模型、任务编排。。。blabla，最终整体对技术的要求会高很多(不过这本质是工程问题，不是 monorepo 问题)
- 单点失败直接影响整个项目工程(其实这也算是预期内的)



## 怎么做：

- 没有任何工具也能做
- yarn/pnpm/npm workspace
- lerna
- rush、nx、bazel、turborepo、bit 等新一代集成 monorepo 工程化方案

有心尝试的同学可以：https://gitee.com/vanfe/devil-camp => 基于 rush 搭建的 monorepo 基础工程模板；



### 现存工具实践分析

找一个方向，好好翻翻文档，大致理解不同方案优缺点就行了

- yarn/pnpm/npm workspace：最简单的方案

- 其中，**pnpm 是神器**！能够解决幽灵依赖、安装性能等问题
- 但都只实现了最基本的**依赖管理**、依赖共享能力

- lerna：具备基本的任务调度能力，支持一键构建、发布等；配合 xxx workspace 方案可实现较实用的工程化环境

- 但：不支持按需构建、不支持离线缓存，等等

- rush stack：微软开源的 monorepo 管理工具

- 支持自定义脚本，并且能为不同场景定义对于不同场景定义不同的运行方式（按依赖顺序并行、串行、单独执行，隐藏特点：支持循环依赖检测）
- 微软内部有上百个项目的大仓实践（其他 monorepo 管理工具没有看到过有如此大规模的实践）
- **与 pnpm 结合紧密**（PY 交易，核心开发同一拨人）
- rush stack 集合了许多实用开箱即用工具：**文档生成、构建任务编排工具、依赖自动识别、远程缓存**等等

- nx

- 同样提供了整仓信息，以及自行维护了一套项目依赖关系图
- 基于项目依赖结构的任务编排能力
- 按需执行任务 & 远程缓存
- 支持项目级别的脚手架能力
- 提供了 react、next、ng 等环境下友好开发的诸多插件
- 。。。。

- bazel：google 开源的 monorepo 工具，支持多种语言，但对 js 支持不高



## 反思

仅仅是把项目放在一起那么简单吗？不，这是一个关于大规模工程治理的工程问题！

- 最低要求：

- 依赖共享、规避依赖冲突
- 模块、代码复用
- 集成测试、集成部署、任务调度
- 开发调试

- 怎么做好：

- 代码防劣化、性能防劣化
- 单测、本地单测性能、benchmark
- 大规模项目按需构建、按需测试
- 文档治理
- Trunk-Base Develop => 火车
- 。。。

![img](https://cdn.nlark.com/yuque/0/2023/png/32786640/1693315062746-dd298f74-3a2d-4d6f-85de-6770e1bc77cf.png)

回顾历史：monorepo vs Polyrepo：

- 过往，最开始并没有太多源码管理、功能共享策略，一个应用相关的东西全部塞在一起，管理方便但开发效率非常低，CI/CD 成本极高
- 后来借助 npm 等工具，尝试将单体巨石应用拆解为若干子项目(Polyrepo)，之后合并打包出最终应用形态(这依然是目前叫常见的方案)

- 优点：每个项目都可能很独立，独立开发、测试、部署等；CI/CD 效率大大提升；方便执行更细粒度的**权限管控**、回滚等
- 缺点：

- 各个项目都需要增加许多重复配置，例如 eslinconfig、webpack config 等
- 基础设施分散，工程化环境的迭代难度较大
- 代码复用难度大
- 仓库依赖叫隐晦
- 规范较难统一，难以落地

- 现在，人们对前端工程化的认知越来越深，对开发效率的追求越来越高，于是延伸出更成熟的 monorepo 工具链
- 但，monorepo 不是银弹：

- 大多数依赖写在根目录，导致 lock 文件特别复杂，变动特别频繁，反而需要不断解决冲突
- IDE、eslint、typescript 等性能劣化
- 管理不好时，会出现大量隐式依赖，管理难度更大
- 短期看迁移成本比较高
- 吸引力很强，但在复杂场景中需要说服许多团队，放弃过往 git history，接入 monorepo，难度还是比较高的



## 资料：

- https://zhuanlan.zhihu.com/p/504554070
- https://www.lernajs.cn/
- https://github.com/korfuri/awesome-monorepo/blob/master/README-zh-CN.md
- https://elliott.dev/posts/rush-vs-nx