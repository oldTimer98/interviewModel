## 视频讲解： 

此处为语雀视频卡片，点击链接查看：[大文件上传.mp4](https://www.yuque.com/u1598738/zqco83/tx93taqxlzs1ng8e#bS2Zg)

##    背景

当今 web 应用功能强大，偶尔可能出现需要通过 web 页面上传上百 G 文件场景(例如人工智能服务中的训练与模型数据)，文件越大，必然上传时间越长，这可能导致几个问题：

- 上传过程一旦出现网络波动，前功尽弃，需要重新开始；
- 上传过程容易出现服务端过载、浏览器内存溢出等问题，失败可能性极高；
- 上传时间较长，可能影响用户体验。

为此，通常需要为大文件上传场景设计一套较通用的分片上传机制，确保系统健壮性。

## 基本方案

- 将单个大任务拆解成多个小任务，一方面能够有效避免单个大任务超时情况；另一方面子任务出错时，只需要重试该子任务即可；
- 服务端需要知道什么时候算是接收完了，所以需要理解：有哪些子任务，以及切片的索引；
- 服务端接收到所有数据后，需要按照切片索引顺序合并恢复，并存储到云存储环境中(如 阿里云 oss)；



## 具体方案

- 主流程：

- 浏览器端选定文件后，首先计算整个文件 md5 值，并发送到服务端，由服务端判定该文件是否已经存在，若已存在则直接跳过后续步骤，实现文件秒传
- 在浏览器端使用 `file.prototype.slice` 切割文件，切割后：

- 按顺序记录索引与切片 md5 值
- 发送 索引与 切片 md5 值到服务端
- 【优化】将切片索引、md5、切片内容一并存储到 indexdb，方便实现页面刷新后重新上传
- 服务端记录任务信息

- 浏览器端开始上传切片，分两步：

- 首先尝试发送 md5，服务端判断该切片是否已经存在，若存在则跳过上传过程，实现分片秒传
- 发送分片内容

- 上传过程实时展示上传进度，支持用户取消上传

```javascript
function uploadFile(file) {
    const CHUNK_SIZE = 1 * 1024 * 1024; // 分片大小，这里以1MB为例
    const totalChunks = Math.ceil(file.size / CHUNK_SIZE);

    for (let i = 0; i < totalChunks; i++) {
        const chunk = file.slice(i * CHUNK_SIZE, (i + 1) * CHUNK_SIZE);
        uploadChunk(chunk, i);
    }
}

function uploadChunk(chunk, chunkIndex) {
    const formData = new FormData();
    formData.append('chunk', chunk);
    formData.append('index', chunkIndex);

    fetch('/upload', { method: 'POST', body: formData })
        .then(response => response.json())
        .then(data => console.log('Chunk uploaded', data))
        .catch(error => console.error('Error in uploading chunk', error));
}

// 调用示例
const file = document.querySelector('input[type="file"]').files[0];
uploadFile(file);
```

- 改进：

- 有没有可能使用 websocket 进一步提速？
- 上传之前可否使用 jszip 压缩内容？
- 如何实现暂停、取消？



## 难点

1. **分片大小的确定**：选择合适的分片大小是一个挑战。太小的分片会增加请求次数，影响效率；而太大的分片可能导致内存占用过高，甚至上传失败。
2. **网络稳定性和重试机制**：分片上传过程中可能会遇到网络波动，需要有效地处理网络错误并实现分片的自动重试。
3. **分片上传顺序和重组**：分片可能不按顺序到达服务器，因此服务器端需要正确地重组分片。这涉及到分片顺序的管理和文件重构的正确性，通常处理方案：

1. 分片编号：在上传每个分片时，附带一个分片编号（或索引）。这个编号代表了分片在原文件中的顺序。例如，如果文件被分为10个片段，编号可以是0到9。

1. 服务器端顺序处理：服务器端接收到分片后，根据分片编号将其存储在临时位置。服务器需要跟踪哪些编号的分片已经上传。
2. 重组文件：当所有分片都上传完毕（服务器可以通过检查分片编号来确认），服务器端开始按照编号顺序重组文件。通常这涉及到读取每个分片的内容，并按顺序将它们合并成一个完整的文件。
3. 完整性验证：在文件重组后，必须进行一次完整性校验确保内容正确，这可以通过比对文件的大小、hash值等方式来实现
4. 错误处理和重试机制：如果某个分片在上传过程中丢失或损坏，需要有机制允许重新上传该分片。

1. **并发上传的控制**：并发上传分片可以提高效率(对 http1、2 分别有怎样的影响)，但是过多的并发可能会导致浏览器或服务器端资源压力增大，因此往往需要一套机制来限制并发请求数

```javascript
function concurrentRequestLimit(requests, maxConcurrent) {
    let activeRequests = 0;
    let requestQueue = [...requests];

    function processNext() {
        if (requestQueue.length === 0) {
            return Promise.resolve();
        }

        if (activeRequests < maxConcurrent) {
            activeRequests++;
            const request = requestQueue.shift();
            
            return request().then(() => {
                activeRequests--;
                return processNext();
            });
        } else {
            return new Promise(resolve => {
                setTimeout(() => resolve(processNext()), 1000); // 等待一段时间后重试
            });
        }
    }

    return processNext();
}

// 使用示例
const mockRequest = () => new Promise(resolve => setTimeout(resolve, 1000));
const requests = Array(10).fill(mockRequest); // 创建10个模拟请求
```

1. **断点续传**：实现断点续传功能需要记录已上传的分片信息（indexDB，但是要考虑副作用），以便在断网或其他中断情况后，能够从上次中断的地方继续上传。
2. **服务器资源消耗**：服务器端需要处理大量的并发请求和大文件的重组，这可能会对服务器资源造成较大的消耗。
3. **前端资源占用**：在前端进行文件切片处理可能会占用大量的内存，特别是在处理超大文件时。

1. 可以考虑流式处理文件
2. 分步加载文件
3. 限制文件上传大小

1. **用户体验**：如何在不影响用户体验的情况下进行分片上传，比如上传进度的显示和错误处理。
2. **跨浏览器兼容性**：不同浏览器对文件操作的API支持程度不同，需要确保在主流浏览器上的兼容性和一致性。



## 学习资料

- https://juejin.cn/post/6844903860327186445
- https://juejin.cn/post/6844904055819468808#heading-3
- https://juejin.cn/post/6844903860327186445#heading-1