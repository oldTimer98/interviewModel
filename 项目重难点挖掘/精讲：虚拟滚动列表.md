## Why:

在浏览器渲染逻辑中，有一个非常基础的性能问题：**需要渲染的内容越多，性能越差**，这放在大列表或无限滚动场景尤为突出。解决问题的核心思路就是“**减少需要渲染的内容**”，常见解法：

1. 分页加载，减少单次需要绘制的内容，但这改变了用户交互，需要用户有意识地去“点击”分页按钮，有时候产品同学是无法接受的；
2. 虚拟滚动，对用户来说交互没有太大变化，同时又能避免长列表带来的性能损耗，算得上是双赢，因此已经成为一种被广泛采纳的优化手段。



## What:

虚拟滚动是一种优化大量数据列表的性能的技术，它通过减少滚动事件的触发次数和减少页面渲染的 DOM 元素数量来提高列表的性能。虚拟滚动的核心原理是将列表分段，每一段的高度为列表项的高度乘以一定的数量，在滚动时只触发当前段的滚动事件，同时动态渲染当前可见区域内的 DOM 元素，而不渲染其他不可见区域的列表项。举个例子：

初始位置：

![img](https://cdn.nlark.com/yuque/0/2023/png/32786640/1692520588219-22299b2c-e6b5-40aa-bc30-8d1f045de4b5.png)

滚动后：![img](https://cdn.nlark.com/yuque/0/2023/png/32786640/1692520576047-04ba5c37-8acf-482d-9be1-b8406c68754b.png)

从上面两图我们可以总结出，整个虚拟列表划分为三个区域，分别是上缓冲区(0/2个元素)，可视区(n个元素)，下缓冲区(2个元素)。当我们滚动到一个元素离开可视区范围内时，就去掉上缓冲区顶上的一个元素，然后再下缓冲区增加一个元素，最终呈现出如下效果：

![img](https://cdn.nlark.com/yuque/0/2023/png/32786640/1692521252545-4fa3bcc8-8575-4798-88c9-7209c0184e2d.png)

虚拟滚动组件的主要优点包括：

1. 提升性能：虚拟滚动组件能够减少页面中需要加载数据的总量，从而减少页面的加载时间。
2. 节省内存：虚拟滚动组件只会加载当前可见的数据，而不是一次性全部加载。这样可以避免在展示大量数据的页面中出现内存占用过高的问题。
3. 优化用户体验：虚拟滚动组件不会让用户感受到明显的滚动卡顿，也不会出现因为数据量过大而无法快速定位数据的问题。从而提升用户体验。



## How:

主要有两种实现虚拟滚动列表的思路：

1. **固定高度**，即列表每个项的高度固定统一，滚动后按高度计算视图内需要展示的列表项；
2. **动态高度**，即列表项高度需要在页面运行起来，渲染完毕之后才能确定高度，这种场景相对更复杂许多；考虑到这个场景相对比较复杂，这里补充一些计算列表项高度的提示：

1. 获取列表项高度 可以通过 JavaScript 获取每个列表项的高度，例如使用 offsetHeight 或 clientHeight 属性。这种方法需要在渲染每个列表项时计算其高度，然后将高度存储在一个数组中，以便后续计算可见部分的位置和数量。
2. 估算列表项高度 如果列表项的高度不是非常关键，可以使用估算高度的方法来计算可见部分的数量和位置。例如，可以使用平均高度来估算列表项的高度，并根据列表项数量和可见区域的高度来计算可见部分的位置和数量。这种方法可以在一定程度上提高性能，但可能会导致一些列表项的高度被错误估算。
3. 动态计算高度 如果列表项的高度是动态变化的，那么我们需要在列表项高度变化时，重新计算可见部分的位置和数量。这可以通过监听列表项高度变化事件来实现。



### 方案 1：固定高度方案

1. 首先计算出由 x 个元素撑起的盒子(称之为container)的高度，撑开盒子，让用户能进行滚动操作。
2. 计算出可视区的起始索引、上缓冲区的起始索引以及下缓冲区的结束索引（就像上图滚动后，上缓冲区的起始索引为2，可视区起始索引为4，下缓冲区结束索引为9）。
3. 采用绝对定位，计算上缓冲区到下缓冲区之间的每一个元素在contianer中的top值，只有知道top值才能让元素出现在可视区内。

![img](https://cdn.nlark.com/yuque/0/2023/webp/32786640/1692520671098-bf3f808f-bd74-40f3-9598-f88f38fd13eb.webp)

1. 将上缓冲区到下缓冲区的元素塞到container中。



代码：

```jsx
import { useState } from 'react';

const FixedSizeList = (props) => {
  const { height, width, itemSize, itemCount, children: Child } = props;
  // 记录滚动掉的高度
  const [scrollOffset, setScrollOffset] = useState(0);

  // 外部容器高度
  const containerStyle = {
    position: 'relative',
    width,
    height,
    overflow: 'auto',
  };

  // 1000个元素撑起盒子的实际高度
  const contentStyle = {
    height: itemSize * itemCount,
    width: '100%',
  };
    
  const getCurrentChildren = () => {
    // 可视区起始索引
    const startIndex = Math.floor(scrollOffset / itemSize);
    // 上缓冲区起始索引
    const finialStartIndex = Math.max(0, startIndex - 2);
    // 可视区能展示的元素的最大个数
    const numVisible = Math.ceil(height / itemSize);
    // 下缓冲区结束索引
    const endIndex = Math.min(itemCount - 1, startIndex + numVisible + 2);
    const items = [];
    // 根据上面计算的索引值，不断添加元素给container
    for (let i = finialStartIndex; i < endIndex; i++) {
      const itemStyle = {
        position: 'absolute',
        height: itemSize,
        width: '100%',
        // 计算每个元素在container中的top值
        top: itemSize * i,
      };
      items.push(
        <Child key={i} index={i} style={itemStyle} />
      );
    }
    return items;
  }

  // 当触发滚动就重新计算
  const scrollHandle = (event) => {
    const { scrollTop } = event.currentTarget;
    setScrollOffset(scrollTop);
  }

  return (
    <div style={containerStyle} onScroll={scrollHandle}>
       <div style={contentStyle}>
          {getCurrentChildren()}
       </div>
    </div>
  );
};

export default FixedSizeList;
```



### 方案 2：不定高度方案

不定高度时，方案复杂度会高许多，难点：

- 难点一：由于每个元素高度不一，我们起先无法直接计算出container的总高度。
- 难点二：每个元素高度不一，每个元素的top值不能通过itemSize * index直接计算出top值。
- 难点三：每个元素高度不一，不能直接通过scrollOffset / itemSize计算出已被滚动掉的元素的个数，很难获取到可视区的起始索引。



针对难点一，我们可以通过遍历所有的Row计算出总高度，但我认为计算出精确总高度的必要性不大，同时也为了兼容第三种虚拟列表，我们不去计算精确的总高度。现在我们回到出发点，思考container的高度的作用是什么？其实就是为了足够大，让用户能进行滚动操作，那我们可以自己假设每一个元素的高度，在乘上个数，弄出一个假的但足够高的container让用户去触发滚动事件。当然这种方案会带来一些小bug（这个bug的影响不大，我认为是可以忽略的）。



其实难点二和难点三本质都一样，元素高度不一，导致不知道被滚动掉了多少元素，只要知道被滚动掉的元素的个数，top值和索引都迎刃而解。

我们可以采用这种解决方案，那就是每次只需要计算上缓冲区到下缓冲区之间的元素，并记录他们，并且记录下最底下的那个元素的索引，当用户进行滚动时，如果我们是向上滚动，就可以直接从已经计算好的记录里取，如果向下滚动，我们根据上一次记录的最大的索引的那个元素不断累加新元素的高度，直到它大于已经滚动掉的高度，此时的索引值就是可视区的起始索引了，这个起始索引所对应的top就是累加的高度。

文字看起来生硬拗口，我们可以看下面这张图。

![img](https://cdn.nlark.com/yuque/0/2023/webp/32786640/1692520839313-b184b4e2-4008-4def-af7a-e6fd7e1fa3f8.webp)

每一个元素的top值都能通过上一个元素的top值 + 上一个元素的height计算出来。举个例子，假设我们需要知道item14的top值：

1. 我们先在记录里找有没有item13的数据，如果有，我们就拿item13.top + item13.heighht得到item14的top。
2. 如果记录中（由上图得知我们只记录了item1-item10的数据）没有，我们就拿到记录中最后一个元素的数据（item10）进行累加，先计算并记录item11的，再计算并记录item12的，再计算并记录item13的，最后就是item14的了。

代码实现：

```javascript
const rowSizes = new Array(1000).fill(true).map(() => 25 + Math.round(Math.random() * 55))
const getItemSize = (index) => rowSizes[index];

const Row = ({ index, style }) => {
  return (
    <div className={index % 2 ? 'list-item-odd' : 'list-item-even'} style={style} >
      Row {index}
    </div>
  )
}

const App = () => {
  return (
    <VariableSizeList
      className="list"
      height={200}
      width={200}
      itemSize={getItemSize}
      itemCount={1000}
    >
      {Row}
    </VariableSizeList>
  );
}
import { useState } from 'react';

// 元数据
const measuredData = {
  measuredDataMap: {},
  LastMeasuredItemIndex: -1,
};

const estimatedHeight = (defaultEstimatedItemSize = 50, itemCount) => {
  let measuredHeight = 0;
  const { measuredDataMap, LastMeasuredItemIndex } = measuredData;
  // 计算已经获取过真实高度的项的高度之和
  if (LastMeasuredItemIndex >= 0) {
    const lastMeasuredItem = measuredDataMap[LastMeasuredItemIndex];
    measuredHeight = lastMeasuredItem.offset + lastMeasuredItem.size;
  }
  // 未计算过真实高度的项数
  const unMeasuredItemsCount = itemCount - measuredData.LastMeasuredItemIndex - 1;
  // 预测总高度
  const totalEstimatedHeight = measuredHeight + unMeasuredItemsCount * defaultEstimatedItemSize;
  return totalEstimatedHeight;
}

const getItemMetaData = (props, index) => {
  const { itemSize } = props;
  const { measuredDataMap, LastMeasuredItemIndex } = measuredData;
  // 如果当前索引比已记录的索引要大，说明要计算当前索引的项的size和offset
  if (index > LastMeasuredItemIndex) {
    let offset = 0;
    // 计算当前能计算出来的最大offset值
    if (LastMeasuredItemIndex >= 0) {
      const lastMeasuredItem = measuredDataMap[LastMeasuredItemIndex];
      offset += lastMeasuredItem.offset + lastMeasuredItem.size;
    }
    // 计算直到index为止，所有未计算过的项
    for (let i = LastMeasuredItemIndex + 1; i <= index; i++) {
      const currentItemSize = itemSize(i);
      measuredDataMap[i] = { size: currentItemSize, offset };
      offset += currentItemSize;
    }
    // 更新已计算的项的索引值
    measuredData.LastMeasuredItemIndex = index;
  }
  return measuredDataMap[index];
};

const getStartIndex = (props, scrollOffset) => {
  const { itemCount } = props;
  let index = 0;
  while (true) {
    const currentOffset = getItemMetaData(props, index).offset;
    if (currentOffset >= scrollOffset) return index;
    if (index >= itemCount) return itemCount;
    index++
  }
}

const getEndIndex = (props, startIndex) => {
  const { height, itemCount } = props;
  // 获取可视区内开始的项
  const startItem = getItemMetaData(props, startIndex);
  // 可视区内最大的offset值
  const maxOffset = startItem.offset + height;
  // 开始项的下一项的offset，之后不断累加此offset，直到等于或超过最大offset，就是找到结束索引了
  let offset = startItem.offset + startItem.size;
  // 结束索引
  let endIndex = startIndex;
  // 累加offset
  while (offset <= maxOffset && endIndex < (itemCount - 1)) {
    endIndex++;
    const currentItem = getItemMetaData(props, endIndex);
    offset += currentItem.size;
  }
  return endIndex;
};

const getRangeToRender = (props, scrollOffset) => {
  const { itemCount } = props;
  const startIndex = getStartIndex(props, scrollOffset);
  const endIndex = getEndIndex(props, startIndex);
  return [
    Math.max(0, startIndex - 2),
    Math.min(itemCount - 1, endIndex + 2),
    startIndex,
    endIndex,
  ];
};

const VariableSizeList = (props) => {
  const { height, width, itemCount, itemEstimatedSize, children: Child } = props;
  const [scrollOffset, setScrollOffset] = useState(0);

  const containerStyle = {
    position: 'relative',
    width,
    height,
    overflow: 'auto',
    willChange: 'transform'
  };

  const contentStyle = {
    height: estimatedHeight(itemEstimatedSize, itemCount),
    width: '100%',
  };

  const getCurrentChildren = () => {
    const [startIndex, endIndex, originStartIndex, originEndIndex] = getRangeToRender(props, scrollOffset)
    const items = [];
    for (let i = startIndex; i <= endIndex; i++) {
      const item = getItemMetaData(props, i);
      const itemStyle = {
        position: 'absolute',
        height: item.size,
        width: '100%',
        top: item.offset,
      };
      items.push(
        <Child key={i} index={i} style={itemStyle} />
      );
    }
    return items;
  }

  const scrollHandle = (event) => {
    const { scrollTop } = event.currentTarget;
    setScrollOffset(scrollTop);
  }

  return (
    <div style={containerStyle} onScroll={scrollHandle}>
      <div style={contentStyle}>
        {getCurrentChildren()}
      </div>
    </div>
  );
};

export default VariableSizeList;
```



## 课后习题：

1. 如果之前没体验过，建议同学课后写一套基于固定高度的虚拟滚动实现；
2. 衍生开来，去了解下为什么“需要渲染的节点越多，性能越差”？扩展学习：浏览器回流重排、关键渲染路径等概念；
3. 再再衍生开来，虚拟滚动关键在于“按需渲染”，我们遇到的很多性能场景是不是也可以基于同样的准则，尽可能减少“工作项”呢？例如：

1. 大文件分片上传：拆整为零，减少单次需要上传的数据量；
2. lint-staged：只对变更的文件做检查操作；
3. canvas 分层渲染：按图形图像的变更频率拆分不同层级，尽可能保证单次只重绘部分内容；
4. 等等