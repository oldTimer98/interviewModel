### 关键流程：

1. 用户调用**截图接口**，参数：目标网址、headers、截屏分辨率 等
2. node 接口接收到请求后，创建 puppeteer 实例
3. puppeteer 携带 headers，打开目标网址
4. 网页渲染完毕后，puppeteer 调用 screenshot 接口截图
5. 保存截图
6. 返回截图地址



### 难点：

1. headers 明文传输有很高泄露风险，怎么办？

1. 目标应用配合改造，签发一些短周期、权限受限的 token
2. 目标应用配合改造，提供无状态版本的页面后门
3. 不支持 headers ！

1. puppeteer 进程资源消耗较重，需要考虑大规模并发场景下的性能与健壮性问题：

1. 限流：实现一套的限流方案，控制截图并发度(令牌桶？)
2. 架构拆解：将服务拆解为一个基于 node 的 web service(主进程)，以及若干 puppeteer 工作进程

1. 主进程负责负载均衡，将请求转发到空闲的工作进程
2. 工作进程负责截图
3. 主-工作进程之间通过心跳同步运行状态

1. puppeteer 运行性能较差，需要做好各种优化(tab 池、资源缓存等)
2. 截图过程可能会比预想的长，可能会超出单次 http 请求的超时时间，需要更好的接口调用体验，可选方案：

1. 客户端发送请求时，设置一个更大的超时时间
2. 异步返回：

1. 请求后立即返回一个唯一 id 标识该次请求
2. 额外提供任务状态查询接口，返回该任务执行进度
3. 截图完成后将 oss 地址记录到数据库，下次直接返回

1. 考虑到 spa 等 csr 场景中，页面初始化后通常还会频繁调整页面内容，为保证截图效果，需要有一定机制检测html 内容结构基本趋于稳定，且图片等外部资源加载完毕后在执行截图动作，具体方案(仅供参考)：

1. 固定时间点：提供截图时间点参数，进入页面后一直到这个时间点才截图
2. 自动检测：**页面稳定**后再截图

1. 借助资源的 load 事件检测多媒体资源是否加载完毕；
2. 借助 mutationObserver 接口检测 dom 结构是否趋于稳定；
3. 借助 requestIdleCallback 接口检测 js 负载是否区域平稳

1. 防御 ddos 攻击？